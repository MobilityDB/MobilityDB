<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Bounding Box Operators</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.1 User's Manual"><link rel="up" href="ch06.html" title="Chapter 6. Temporal Types: Generic Operations (Part 2)"><link rel="prev" href="ch06s03.html" title="Comparisons"><link rel="next" href="ch06s05.html" title="Miscellaneous"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Bounding Box Operators</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06s03.html">Prev</a> </td><th width="60%" align="center">Chapter 6. Temporal Types: Generic Operations (Part 2)</th><td width="20%" align="right"> <a accesskey="n" href="ch06s05.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="temporal_types_bbox"></a>Bounding Box Operators</h2></div></div></div><p>When creating indexes for temporal types, what is stored in the index is not the actual value but instead, a bounding box representing the value. In this case, the index will provide a list of candidate values that <span class="emphasis"><em>may</em></span> satisfy the query predicate, and a second step is needed to filter out candidate values by computing the query predicate on the actual values.</p><p>However, when the bounding boxes have a large empty space not covered by the actual values, the index will generate many candidate values that do not satisfy the query predicate, which reduces the efficiency of the index. In these situations, it may be better to represent a value not with a <span class="emphasis"><em>single</em></span> bounding box, but instead with <span class="emphasis"><em>multiple</em></span> bounding boxes. This increases considerably the efficiency of the index, provided that the index is able to manage multiple bounding boxes per value. The following functions are used for generating multiple bounding boxes for a single temporal value.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="temporal_spans_merge"></a><a class="indexterm" name="idm3722"></a><p>Return an array of temporal spans from the instants or segments of a temporal value</p><p><code class="varname">spansMerge(temp, max_count = 0) → spans[]</code></p><p>If the last argument is not specified, the resulting array will have one span per instant or segment of the temporal value, depending on whether the interpolation is discrete or continuous. Otherwise, the specified number of spans will be obtained by merging consecutive instants or segments.</p><pre class="programlisting">
SELECT spansMerge(ttext '{A@2000-01-01, B@2000-01-02, A@2000-01-03, B@2000-01-04,
  A@2000-01-05}');
/* {"[2000-01-01, 2000-01-01]", "[2000-01-02, 2000-01-02]",
    "[2000-01-03, 2000-01-03]", "[2000-01-04, 2000-01-04]"} */
SELECT spansMerge(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 2@2000-01-04,
  1@2000-01-05]');
/* {"[2000-01-01, 2000-01-02])", "[2000-01-02, 2000-01-03])",
    "[2000-01-03, 2000-01-04])", "[2000-01-04, 2000-01-05])"} */
SELECT spansMerge(ttext '[A@2000-01-01, B@2000-01-02, A@2000-01-03, B@2000-01-04,
  A@2000-01-05]', 3);
/* {"[2000-01-01, 2000-01-03])", "[2000-01-03, 2000-01-04])",
    "[2000-01-04, 2000-01-05])"} */
SELECT spansMerge(tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], 
  [Point(1 1)@2000-01-03, Point(2 2)@2000-01-04], [Point(1 1)@2000-01-05]}', 2);
-- {"[2000-01-01, 2000-01-04])", "[2000-01-05, 2000-01-05])"}
</pre></li><li class="listitem"><a name="tboxes_merge"></a><a class="indexterm" name="idm3731"></a><p>Return an array of temporal boxes from the instants or segments of a temporal number</p><p><code class="varname">tboxesMerge(tnumber, max_count = 0) → tbox[]</code></p><p>If the last argument is not specified, the resulting array will have one box per instant or segment of the temporal number, depending on whether the interpolation is discrete or continuous. Otherwise, the specified number of boxes will be obtained by merging consecutive instants or segments.</p><pre class="programlisting">
SELECT tboxesMerge(tint '{1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05}');
/* {"TBOXINT XT([1, 2),[2000-01-01, 2000-01-01])",
    "TBOXINT XT([2, 3),[2000-01-02, 2000-01-02])",
    "TBOXINT XT([1, 2),[2000-01-03, 2000-01-03])",
    "TBOXINT XT([4, 5),[2000-01-04, 2000-01-04])"} */
SELECT tboxesMerge(tint '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05]');
/* {"TBOXINT XT([1, 3),[2000-01-01, 2000-01-02])",
    "TBOXINT XT([1, 3),[2000-01-02, 2000-01-03])",
    "TBOXINT XT([1, 5),[2000-01-03, 2000-01-04])",
    "TBOXINT XT([1, 5),[2000-01-04, 2000-01-05])"} */
SELECT tboxesMerge(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05]', 3);
/* {"TBOXFLOAT XT([1, 2],[2000-01-01, 2000-01-03])",
    "TBOXFLOAT XT([1, 4],[2000-01-03, 2000-01-04])",
    "TBOXFLOAT XT([1, 4],[2000-01-04, 2000-01-05])"} */
SELECT tboxesMerge(tfloat '{[1@2000-01-01, 2@2000-01-02], [1@2000-01-03, 4@2000-01-04],
  [1@2000-01-05]}', 2);
/* {"TBOXFLOAT XT([1, 4],[2000-01-01, 2000-01-04])",
    "TBOXFLOAT XT([1, 1],[2000-01-05, 2000-01-05])"} */
</pre></li><li class="listitem"><a name="stboxes_merge"></a><a class="indexterm" name="idm3740"></a><p>Return either an array of spatial boxes from the segments of a (multi)line or an array of spatiotemporal boxes from the instants or segments of a temporal point</p><p><code class="varname">stboxesMerge(lines, max_count = 0) → stbox[]</code></p><p><code class="varname">stboxesMerge(tpoint, max_count = 0) → stbox[]</code></p><p>If the last argument is not specified, the resulting array will have either one box per segment of the (multi)line or one box per instant or segment of a temporal point, depending on whether the interpolation is discrete or continuous. Otherwise, the specified number of boxes will be obtained by merging consecutive instants or segments.</p><pre class="programlisting">
SELECT stboxesMerge(geometry 'Linestring(1 1,2 2,3 1,4 2,5 1)');
/* {"STBOX X((1,1),(2,2))","STBOX X((2,1),(3,2))",
    "STBOX X((3,1),(4,2))","STBOX X((4,1),(5,2))"} */
SELECT stboxesMerge(geometry 'Linestring(1 1,2 2,3 1,4 2,5 1)', 2);
-- {"STBOX X((1,1),(3,2))","STBOX X((3,1),(5,2))"}
SELECT stboxesMerge(geometry 'MultiLinestring((1 1,2 2),(3 1,4 2),(5 1,6 2))', 2);
-- {"STBOX X((1,1),(4,2))","STBOX X((5,1),(6,2))"}
</pre><pre class="programlisting">
SELECT stboxesMerge(tgeompoint '{Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, 
  Point(3 1)@2000-01-03, Point(4 2)@2000-01-04, Point(5 1)@2000-01-05}');
/* {"STBOX XT(((1,1),(1,1)),[2000-01-01, 2000-01-01])",
    "STBOX XT(((2,2),(2,2)),[2000-01-02, 2000-01-02])",
    "STBOX XT(((3,3),(3,3)),[2000-01-03, 2000-01-03])",
    "STBOX XT(((4,4),(4,4)),[2000-01-04, 2000-01-04])"} */
SELECT stboxesMerge(tgeompoint '[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(3 1)@2000-01-03, Point(4 2)@2000-01-04, Point(5 1)@2000-01-05]');
/* {"STBOX XT(((1,1),(2,2)),[2000-01-01, 2000-01-02])",
    "STBOX XT(((2,1),(3,2)),[2000-01-02, 2000-01-03])",
    "STBOX XT(((3,1),(4,2)),[2000-01-03, 2000-01-04])",
    "STBOX XT(((4,1),(5,2)),[2000-01-04, 2000-01-05])"} */
SELECT stboxesMerge(tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], 
  [Point(3 1)@2000-01-03, Point(4 2)@2000-01-04], [Point(5 1)@2000-01-05]}', 2);
/* {"STBOX XT(((1,1),(4,2)),[2000-01-01, 2000-01-04])",
    "STBOX XT(((5,1),(5,1)),[2000-01-05, 2000-01-05])"} */
</pre></li></ul></div><p>Another set of bounding box operators test whether the bounding boxes of their arguments satisfy the predicate and result in a Boolean value. As stated in <a class="xref" href="ch04.html" title="Chapter 4. Temporal Types">Chapter 4, <i>Temporal Types</i></a>, the bounding box associated to a temporal type depends on the base type: It is the <code class="varname">tstzspan</code> type for the <code class="varname">tbool</code> and <code class="varname">ttext</code> types, the <code class="varname">tbox</code> type for the <code class="varname">tint</code> and <code class="varname">tfloat</code> types, and the <code class="varname">stbox</code> type for the <code class="varname">tgeompoint</code> and <code class="varname">tgeogpoint</code> types. Furthermore, as seen in <a class="xref" href="ch03s03.html" title="Conversions">the section called “Conversions”</a>, many PostgreSQL, PostGIS, or MobilityDB types can be converted to the <code class="varname">tbox</code> and <code class="varname">stbox</code> types. For example, numeric and span types can be converted to type <code class="varname">tbox</code>, types <code class="varname">geometry</code> and <code class="varname">geography</code> can be converted to type <code class="varname">stbox</code>, and time types and temporal types can be converted to types <code class="varname">tbox</code> and <code class="varname">stbox</code>.</p><p>A first set of operators consider the topological relationships between the bounding boxes. There are five topological operators: overlaps (<code class="varname">&amp;&amp;</code>), contains (<code class="varname">@&gt;</code>), contained (<code class="varname">&lt;@</code>), same (<code class="varname">~=</code>), and adjacent (<code class="varname">-|-</code>). The arguments of these operators can be a base type, a box, or a temporal type and the operators verify the topological relationship taking into account the value and/or the time dimension depending on the type of the arguments.</p><p>Another set of operators consider the relative position of the bounding boxes. The operators <code class="varname">&lt;&lt;</code>, <code class="varname">&gt;&gt;</code>, <code class="varname">&amp;&lt;</code>, and <code class="varname">&amp;&gt;</code> consider the value dimension for <code class="varname">tint</code> and <code class="varname">tfloat</code> types and the X coordinates for the <code class="varname">tgeompoint</code> and <code class="varname">tgeogpoint</code> types, the operators <code class="varname">&lt;&lt;|</code>, <code class="varname">|&gt;&gt;</code>, <code class="varname">&amp;&lt;|</code>, and <code class="varname">|&amp;&gt;</code> consider the Y coordinates for the <code class="varname">tgeompoint</code> and <code class="varname">tgeogpoint</code> types, the operators <code class="varname">&lt;&lt;/</code>, <code class="varname">/&gt;&gt;</code>, <code class="varname">&amp;&lt;/</code>, and <code class="varname">/&amp;&gt;</code> consider the Z coordinates for the <code class="varname">tgeompoint</code> and <code class="varname">tgeogpoint</code> types, and the operators <code class="varname">&lt;&lt;#</code>, <code class="varname">#&gt;&gt;</code>, <code class="varname">#&amp;&lt;</code>, and <code class="varname">#&amp;&gt;</code> consider the time dimension for all temporal types.</p><p>Finally, it is worth noting that the bounding box operators allow to mix 2D/3D geometries but in that case, the computation is only performed on 2D.</p><p>We refer to <a class="xref" href="ch03s09.html" title="Bounding Box Operations">the section called “Bounding Box Operations”</a> for the bounding box operators.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch06.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Comparisons </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Miscellaneous</td></tr></table></div></body></html>
