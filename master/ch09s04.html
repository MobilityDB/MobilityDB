<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Multidimensional Tiling</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.1 User's Manual"><link rel="up" href="ch09.html" title="Chapter 9. Temporal Types: Analytics Operations"><link rel="prev" href="ch09s03.html" title="Similarity"><link rel="next" href="ch10.html" title="Chapter 10. Temporal Types: Aggregation and Indexing"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Multidimensional Tiling</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch09s03.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Temporal Types: Analytics Operations</th><td width="20%" align="right"> <a accesskey="n" href="ch10.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="temporal_types_tiling"></a>Multidimensional Tiling</h2></div></div></div><p>
			Multidimensional tiling is the mechanism used to partition the domain of temporal values in buckets or tiles of varying number of dimensions. In the case of a single dimension, the domain can be partitioned by value or by time using buckets of the same size or duration, respectively. For temporal numbers, the domain can be partitioned in two-dimensional tiles of the same size for the value dimension and the same duration for the time dimension. For temporal points, the domain can be partitioned in space in two- or three-dimensional tiles, depending on the number of dimensions of the spatial coordinates. Finally, for temporal points, the domain can be partitioned in space and time using three- or four-dimensional tiles. Furthermore, the temporal values can also be fragmented according to a multidimensional grid defined over the underlying domain.
		</p><p>
			Multidimensional tiling can be used for various purposes. For example, it can be used for computing multidimensional histograms, where the temporal values are aggregated according to the underlying partition of the domain. On the other hand, multidimensional tiling can be used for distributing a dataset across a cluster of servers, where each server contains a partition of the dataset. The advantage of this partition mechanism is that it preserves proximitity in space and time, unlike the traditional hash-based partition mechanisms used in big data environments.
		</p><div class="figure-float"><div class="figure"><a name="tiling"></a><p class="title"><b>Figure 9.4. Multidimensional tiling for temporal floats.</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="images/tiling.svg" width="405"></object></div></div></div><br class="figure-break"></div><p>
			<a class="xref" href="ch09s04.html#tiling" title="Figure 9.4. Multidimensional tiling for temporal floats.">Figure 9.4, “Multidimensional tiling for temporal floats.”</a> illustrates multidimensional tiling for temporal floats. The two-dimensional domain is split into tiles having the same size for the value dimension and the same duration for the time dimension. Suppose that this tiling scheme is used for distribute a dataset across a cluster of six servers, as suggested by the gray pattern in the figure. In this case, the values are fragmented so each server will receive the data of contiguous tiles. This implies in particular that four nodes will receive one fragment of the temporal float depicted in the figure. One advantage of this distribution of data based on multidimensional tiling is that it reduces the data that needs to be exchanged between nodes when processing queries, a process typically referred to as <span class="emphasis"><em>reshuffling</em></span>.
		</p><p>Many of the functions in this section are <span class="emphasis"><em>set-returning functions</em></span> (also known as a <span class="emphasis"><em>table functions</em></span>) since they typically return more than one value. In this case, the functions are marked with the <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
 symbol.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="bucket_functions"></a>Bucket Functions</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="bucketList"></a><a class="indexterm" name="idm5398"></a><p>Return a set of buckets that cover the span with buckets of the same size or duration aligned with the origin <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">bucketList(bounds unitspan,size number,origin number=0) → {(index,span)}</code></p><p><code class="varname">bucketList(bounds tstzspan,duration interval,origin timestamptz='2000-01-03') → </code></p><p><code class="varname">  {(index,span)}</code></p><p>The result is a set of pairs <code class="varname">(index,span)</code>. If the origin is not specified, it is set by default to 0 for number spans and Monday, January 3, 2000 for periods. The indices start by 1.</p><pre class="programlisting">
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(intspan '[15, 25]', 2) AS bl) t;
-- 1 | [14,16)
-- 2 | [16,18)
-- 3 | [18,20)
-- ...
SELECT bucketList(floatspan '[-10, -1]', 2.5, -7);
-- (1,"[-12, -9.5)")
-- (2,"[-9.5, -7)")
-- (3,"[-7, -4.5)")
-- ...
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(tstzspan '[2001-01-15, 2001-01-25]','2 days') AS bl) t;
-- 1 | [2001-01-15, 2001-01-17)
-- 2 | [2001-01-17, 2001-01-19)
-- 3 | [2001-01-19, 2001-01-21)
-- ...
SELECT bucketList(tstzspan '[2001-01-15, 2001-01-25]', '2 days', '2001-01-02');
-- (1,"[2001-01-14, 2001-01-16)")
-- (2,"[2001-01-16, 2001-01-18)")
-- (3,"[2001-01-18, 2001-01-20)")
-- ...
</pre></li><li class="listitem"><a name="valueBucket"></a><a class="indexterm" name="idm5419"></a><p> Return the start value of the bucket that contains the input number</p><p><code class="varname">valueBucket(value number,size number,origin number=0) → number</code></p><p>If the origin is not specified, it is set by default to 0.</p><pre class="programlisting">
SELECT valueBucket(3, 2);
-- 2
SELECT valueBucket(3.5, 2.5, 1.5);
-- 1.5
</pre></li><li class="listitem"><a name="spanBucket"></a><a class="indexterm" name="idm5428"></a><p>Return the span in the bucket space that contains the input number</p><p><code class="varname">spanBucket(value number,size number,origin number=0) → span</code></p><p>If the origin is not specified, it is set by default to 0.</p><pre class="programlisting">
SELECT spanBucket(2, 2);
-- [2, 4)
SELECT spanBucket(2, 2, 1);
-- [1, 3)
SELECT spanBucket(2, 2.5);
-- [0, 2.5)
SELECT spanBucket(2, 2.5, 1.5);
-- [1.5, 4)
</pre></li><li class="listitem"><a name="timeBucket"></a><a class="indexterm" name="idm5437"></a><p>Return the start timestamp of the bucket that contains the input timestamp</p><p><code class="varname">timeBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03') → </code></p><p><code class="varname">  timestamptz</code></p><p>If the origin is not specified, it is set by default to Monday, January 3, 2000.</p><pre class="programlisting">
SELECT timeBucket(timestamptz '2001-05-01', interval '2 days');
-- 2001-04-29 01:00:00
SELECT timeBucket(timestamptz '2001-05-01', interval '2 days', timestamptz '2001-01-01');
-- 2001-04-30 01:00:00
</pre></li><li class="listitem"><a name="periodBucket"></a><a class="indexterm" name="idm5448"></a><p>Return the period in the bucket space that contains the input timestamp</p><p><code class="varname">periodBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03') → </code></p><p><code class="varname">  tstzspan</code></p><p>If the origin is not specified, it is set by default to Monday, January 3, 2000.</p><pre class="programlisting">
SELECT periodBucket('2001-01-04', interval '1 week');
-- [2001-01-03, 2001-01-10)
SELECT periodBucket('2001-01-04', interval '1 week', '2001-01-07');
-- [2000-12-31, 2001-01-07)
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tile_functions"></a>Tile Functions</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="tileList"></a><a class="indexterm" name="idm5462"></a><p>Return a set of tiles that covers the box with multidimensional tiles of the same size and duration <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>
 <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">tileList(bounds tbox,size float,duration interval,vorigin float=0,</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → {(index,tile)}</code></p><p><code class="varname">tileList(bounds stbox,xsize float,[ysize float,zsize float,] </code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)',borderInc bool=true) → {(index,tile)}</code></p><p><code class="varname">tileList(bounds stbox,xsize float,[ysize float,zsize float,]duration interval,</code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)',torigin timestamptz='2000-01-03',</code></p><p><code class="varname">  borderInc bool=true) → {(index,tile)}</code></p><p>The result is a set of pairs <code class="varname">(index,tile)</code>. If the origin of the value and/or time dimensions are not specified, they are set by default to 0 or <code class="varname">'Point(0 0 0)'</code> for the value dimension (depending on the box type) and to Monday, January 3, 2000 for the time dimension. The optional argument <code class="varname">borderInc</code> states whether the upper border of the extent is included and thus, extra tiles containing the border are generated.</p><p>In the case of a spatiotemporal grid, <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. The SRID of the tile coordinates is determined by the input box and the sizes are given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</p><pre class="programlisting">
SELECT (gr).index, (gr).tile
FROM (SELECT tileList(tfloat '[15@2001-01-15, 25@2001-01-25]'::tbox, 2.0, '2 days')
  AS gr) t;
-- 1 | TBOX XT([14,16),[2001-01-15,2001-01-17))
-- 2 | TBOX XT([16,18),[2001-01-15,2001-01-17))
-- 3 | TBOX XT([18,20),[2001-01-15,2001-01-17))
-- ...
SELECT tileList(tfloat '[15@2001-01-15,25@2001-01-25]'::tbox, 2.0, '2 days', 11.5);
-- (1,"TBOX XT([13.5,15.5),[2001-01-15,2001-01-17))")
-- (2,"TBOX XT([15.5,17.5),[2001-01-15,2001-01-17))")
-- (3,"TBOX XT([17.5,19.5),[2001-01-15,2001-01-17))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3)@2001-01-15,
  Point(15 15)@2001-01-25]'::stbox, 2.0);
-- (1,"STBOX X((2,2),(4,4))")
-- (2,"STBOX X((4,2),(6,4))")
-- (3,"STBOX X((6,2),(8,4))")
-- ...
SELECT tileList(tgeompoint 'SRID=3812;[Point(3 3)@2001-01-15,
  Point(15 15)@2001-01-25]'::stbox, 2.0, geometry 'Point(3 3)');
-- (1,"SRID=3812;STBOX X((3,3),(5,5))")
-- (2,"SRID=3812;STBOX X((5,3),(7,5))")
-- (3,"SRID=3812;STBOX X((7,3),(9,5))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3 3)@2001-01-15,
  Point(15 15 15)@2001-01-25]'::stbox, 2.0, geometry 'Point(3 3 3)');
-- (1,"STBOX Z((3,3,3),(5,5,5))")
-- (2,"STBOX Z((5,3,3),(7,5,5))")
-- (3,"STBOX Z((7,3,3),(9,5,5))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3)@2001-01-15,
  Point(15 15)@2001-01-25]'::stbox, 2.0, interval '2 days');
-- (1,"STBOX XT(((2,2),(4,4)),[2001-01-15,2001-01-17))")
-- (2,"STBOX XT(((4,2),(6,4)),[2001-01-15,2001-01-17))")
-- (3,"STBOX XT(((6,2),(8,4)),[2001-01-15,2001-01-17))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3 3)@2001-01-15,
  Point(15 15 15)@2001-01-25]'::stbox, 2.0, interval '2 days',
  'Point(3 3 3)', '2001-01-15');
-- (1,"STBOX ZT(((3,3,3),(5,5,5)),[2001-01-15,2001-01-17))")
-- (2,"STBOX ZT(((5,3,3),(7,5,5))),[2001-01-15,2001-01-17)")
-- (3,"STBOX ZT(((7,3,3),(9,5,5))),[2001-01-15,2001-01-17)")
-- ...
</pre></li><li class="listitem"><a name="tile"></a><a class="indexterm" name="idm5504"></a><p>Return the tile of the multidimensional grid that contains the value and the timestamp <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>
</p><p><code class="varname">tile(value float,time timestamptz,size float,duration interval,</code></p><p><code class="varname">  vorigin float=0.0,torigin timestamptz='2000-01-03') → tbox</code></p><p><code class="varname">tile(point geometry,xsize float,[ysize float,zsize float],</code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)') → stbox</code></p><p><code class="varname">tile(point geometry,time timestamptz,xsize float,[ysize float,zsize float,]duration</code></p><p><code class="varname">  interval,sorigin geompoint='Point(0 0 0)',torigin timestamptz='2000-01-03') → stbox</code></p><p>If the origin of the value and/or time dimensions are not specified, they are set by default to 0 or <code class="varname">Point(0 0 0)</code> for the value dimension and Monday, January 3, 2000 for the time dimension, respectively.</p><p>In the case of a spatiotemporal grid, <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. The SRID of the tile coordinates is determined by the input point and the sizes are given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</p><pre class="programlisting">
SELECT tile(15, '2001-01-15', 2, interval '2 days');
-- TBOX XT([14,16),[2001-01-15,2001-01-17))
SELECT tile(15, '2001-01-15', 2, interval '2 days', 1, '2001-01-02');
-- TBOX XT([15,17),[2001-01-14,2001-01-16))
SELECT tile(geometry 'Point(1 1 1)', 2.0);
-- STBOX Z((0,0,0),(2,2,2))
SELECT tile(geometry 'Point(1 1)', '2001-01-01', 2.0, interval '2 days');
-- STBOX XT(((0,0),(2,2)),[2001-01-01, 2001-01-03))
SELECT tile(geometry 'Point(1 1)', '2001-01-01', 2.0, interval '2 days',
  'Point(1 1)', '2001-01-02');
-- STBOX XT(((1,1),(3,3)),[2000-12-31, 2001-01-02))
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="split_functions"></a>Split Functions</h3></div></div></div><p>These functions fragment a temporal value with respect to a sequence of buckets (see <a class="xref" href="ch09s04.html#bucket_functions" title="Bucket Functions">the section called “Bucket Functions”</a>) or tiles (see <a class="xref" href="ch09s04.html#tile_functions" title="Tile Functions">the section called “Tile Functions”</a>).</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="valueSplit"></a><a class="indexterm" name="idm5541"></a><p>Fragment the temporal number with respect to span buckets <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">valueSplit(tnumber,size number,origin number=0) → {(number,tnumber)}</code></p><p>The result is a set of pairs <code class="varname">(number,tnumber)</code>. If the origin of values is not specified, it is set by default to 0.</p><pre class="programlisting">
SELECT (sp).number, (sp).tnumber
FROM (SELECT valueSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05, 10@2001-01-10]',
  2) AS sp) t;
--  0 | {[1@2001-01-01 00:00:00+01, 1@2001-01-02 00:00:00+01)}
--  2 | {[2@2001-01-02 00:00:00+01, 2@2001-01-05 00:00:00+01)}
--  4 | {[5@2001-01-05 00:00:00+01, 5@2001-01-10 00:00:00+01)}
-- 10 | {[10@2001-01-10 00:00:00+01]}
SELECT valueSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 2.0, 1.0);
-- (1,"{[1@2001-01-01 00:00:00+01, 3@2001-01-03 00:00:00+01)}")
-- (3,"{[3@2001-01-03 00:00:00+01, 5@2001-01-05 00:00:00+01)}")
-- (5,"{[5@2001-01-05 00:00:00+01, 7@2001-01-07 00:00:00+01)}")
-- (7,"{[7@2001-01-07 00:00:00+01, 9@2001-01-09 00:00:00+01)}")
-- (9,"{[9@2001-01-09 00:00:00+01, 10@2001-01-10 00:00:00+01)}")
</pre></li><li class="listitem"><a name="timeSplit"></a><a class="indexterm" name="idm5558"></a><p>Fragment the temporal value with respect to time buckets <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>
 <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">timeSplit(ttype,duration interval,origin timestamptz='2000-01-03') → </code></p><p><code class="varname">  {(time,temp)}</code></p><p>The result is a set of pairs <code class="varname">(time,temp)</code>. If the origin of time is not specified, it is set by default to Monday, January 3, 2000.</p><pre class="programlisting">
SELECT (ts).time, (ts).temp
FROM (SELECT timeSplit(tfloat '[1@2001-02-01, 10@2001-02-10)', '2 days') AS ts) t;
-- 2001-01-31 | [1@2001-02-01, 2@2001-02-02)
-- 2001-02-02 | [2@2001-02-02, 4@2001-02-04)
-- 2001-02-04 | [4@2001-02-04, 6@2001-02-06)
-- ...
SELECT (ts).time, astext((ts).temp) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-02-01, Point(10 10)@2001-02-10]',
  '2 days', '2001-02-01') AS ts) AS t;
-- 2001-02-01 | [POINT(1 1)@2001-02-01, POINT(3 3)@2001-02-03)
-- 2001-02-03 | [POINT(3 3)@2001-02-03, POINT(5 5)@2001-02-05)
-- 2001-02-05 | [POINT(5 5)@2001-02-05, POINT(7 7)@2001-02-07)
-- ...
</pre><p>Notice that we can fragment a temporal value in cyclic (instead of linear) time buckets. The following two examples show how to fragment a temporal value by hour and by day of the week.</p><pre class="programlisting">
SELECT (ts).time::time AS hour, merge((ts).temp) AS temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-03]', '1 hour') AS ts) t
GROUP BY hour ORDER BY hour;
/* 00:00:00 | {[1@2001-01-01 00:00:00+01, 1.1875@2001-01-01 01:00:00+01),
               [5.5@2001-01-02 00:00:00+01, 5.6875@2001-01-02 01:00:00+01)} */
/* 01:00:00 | {[1.1875@2001-01-01 01:00:00+01, 1.375@2001-01-01 02:00:00+01),
               [5.6875@2001-01-02 01:00:00+01, 5.875@2001-01-02 02:00:00+01)} */
/* 02:00:00 | {[1.375@2001-01-01 02:00:00+01, 1.5625@2001-01-01 03:00:00+01),
               [5.875@2001-01-02 02:00:00+01, 6.0625@2001-01-02 03:00:00+01)} */
/* 03:00:00 | {[1.5625@2001-01-01 03:00:00+01, 1.75@2001-01-01 04:00:00+01),
               [6.0625@2001-01-02 03:00:00+01, 6.25@2001-01-02 04:00:00+01)} */
/* ... */
SELECT EXTRACT(DOW FROM (ts).time) AS dow_no, TO_CHAR((ts).time, 'Dy') AS dow,
  asText(round(merge((ts).temp), 2)) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-14)',
  '1 hour') AS ts) t
GROUP BY dow, dow_no ORDER BY dow_no;
/* 0 | Sun | {[POINT(1 1)@2001-01-01, POINT(1.69 1.69)@2001-01-02),
             [POINT(5.85 5.85)@2001-01-08, POINT(6.54 6.54)@2001-01-09)} */
/* 1 | Mon | {[POINT(1.69 1.69)@2001-01-02, POINT(2.38 2.38)@2001-01-03),
             [POINT(6.54 6.54)@2001-01-09, POINT(7.23 7.23)@2001-01-10)} */
/* 2 | Tue | {[POINT(2.38 2.38)@2001-01-03, POINT(3.08 3.08)@2001-01-04),
             [POINT(7.23 7.23)@2001-01-10, POINT(7.92 7.92)@2001-01-11)} */
/* ... */
</pre></li><li class="listitem"><a name="valueTimeSplit"></a><a class="indexterm" name="idm5586"></a><p>Fragment the temporal number with respect to the tiles in a value-time grid <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">valueTimeSplit(tumber,size number,duration interval,vorigin number=0,</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → {(number,time,tnumber}</code></p><p>The result is a set of triples <code class="varname">(number,time,tnumber)</code>. If the origin of values and/or time are not specified, they are set by default to 0 and to Monday, January 3, 2000, respectively.</p><pre class="programlisting">
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tint '[1@2001-02-01, 2@2001-02-02, 5@2001-02-05,
  10@2001-02-10]', 5, '5 days') AS sp) t;
--  0 | 2001-02-01 | {[1@2001-02-01, 2@2001-02-02, 2@2001-02-05)}
--  5 | 2001-02-01 | {[5@2001-02-05, 5@2001-02-06)}
--  5 | 2001-02-06 | {[5@2001-02-06, 5@2001-02-10)}
-- 10 | 2001-02-06 | {[10@2001-02-10]}
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tfloat '[1@2001-02-01, 10@2001-02-10)', 5.0, '5 days', 1.0,
  '2001-02-01') AS sp) t;
-- 1 | 2001-01-01 | [1@2001-01-01, 6@2001-01-06)
-- 6 | 2001-01-06 | [6@2001-01-06, 10@2001-01-10)
</pre></li><li class="listitem"><a name="spaceSplit"></a><a class="indexterm" name="idm5605"></a><p>Fragment the temporal point with respect to the tiles in a spatial grid <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>
 <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">spaceSplit(tgeompoint,xsize float,[ysize float,zsize float,]</code></p><p><code class="varname">  origin geompoint='Point(0 0 0)',bitmatrix boolean=true,borderInc bool=true) →</code></p><p><code class="varname">  {(point,tpoint)}</code></p><p>The result is a set of pairs <code class="varname">(point,tpoint)</code>. If the origin of the space dimension is not specified, it is set by default to <code class="varname">'Point(0 0 0)'</code>. The arguments <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. If the argument <code class="varname">bitmatrix</code> is not specified, then the computation will use a bit matrix to speed up the process. The optional argument <code class="varname">borderInc</code> states whether the upper border of the extent is included and thus, extra tiles containing the border are generated.</p><pre class="programlisting">
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1)@2001-03-01, Point(10 10)@2001-03-10]',
  2.0) AS sp) t;
-- POINT(0 0) | {[POINT(1 1)@2001-03-01, POINT(2 2)@2001-03-02)}
-- POINT(2 2) | {[POINT(2 2)@2001-03-02, POINT(4 4)@2001-03-04)}
-- POINT(4 4) | {[POINT(4 4)@2001-03-04, POINT(6 6)@2001-03-06)}
-- ...
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1 1)@2001-03-01,
  Point(10 10 10)@2001-03-10]', 2.0, geometry 'Point(1 1 1)') AS sp) t;
-- POINT Z(1 1 1) | {[POINT Z (1 1 1)@2001-03-01, POINT Z (3 3 3)@2001-03-03)}
-- POINT Z(3 3 3) | {[POINT Z (3 3 3)@2001-03-03, POINT Z (5 5 5)@2001-03-05)}
-- POINT Z(5 5 5) | {[POINT Z (5 5 5)@2001-03-05, POINT Z (7 7 7)@2001-03-07)}
-- ...
</pre></li><li class="listitem"><a name="spaceTimeSplit"></a><a class="indexterm" name="idm5639"></a><p>Fragment the temporal point with respect to the tiles in a spatiotemporal grid <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>
 <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">spaceTimeSplit(tgeompoint,xsize float,[ysize float,ysize float,]</code></p><p><code class="varname">  duration interval,sorigin geompoint='Point(0 0 0)',</code></p><p><code class="varname">  torigin timestamptz='2000-01-03',bitmatrix boolean=true,borderInc boolean=true) →</code></p><p><code class="varname">  {(point,time,tpoint)}</code></p><p>The result is a set of triples <code class="varname">(point,time,tpoint)</code>. If the origin of the space and time dimensions are not specified, they are set by default to <code class="varname">'Point(0 0 0)'</code> and Monday, January 3, 2000, respectively. The arguments <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. If the argument <code class="varname">bitmatrix</code> is not specified, then the computation will use a bit matrix to speed up the process. The optional argument <code class="varname">borderInc</code> states whether the upper border of the extent is included and thus extra tiles containing the border are generated.</p><pre class="programlisting">
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1)@2001-02-01, Point(10 10)@2001-02-10]',
  2.0, interval '2 days') AS sp) t;
-- POINT(0 0) | 2001-01-31 | {[POINT(1 1)@2001-02-01, POINT(2 2)@2001-02-02)}
-- POINT(2 2) | 2001-01-31 | {[POINT(2 2)@2001-02-02]}
-- POINT(2 2) | 2001-02-02 | {[POINT(2 2)@2001-02-02, POINT(4 4)@2001-02-04)}
-- ...
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1 1)@2001-02-01,
  Point(10 10 10)@2001-02-10]', 2.0, interval '2 days', 'Point(1 1 1)',
  '2001-03-01') AS sp) t;
-- POINT Z(1 1 1) | 2001-02-01 | {[POINT Z(1 1 1)@2001-02-01, POINT Z(3 3 3)@2001-02-03)}
-- POINT Z(3 3 3) | 2001-02-01 | {[POINT Z(3 3 3)@2001-02-03]}
-- POINT Z(3 3 3) | 2001-02-03 | {[POINT Z(3 3 3)@2001-02-03, POINT Z (5 5 5)@2001-02-05)}
-- ...
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch09s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch09.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch10.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Similarity </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 10. Temporal Types: Aggregation and Indexing</td></tr></table></div></body></html>
