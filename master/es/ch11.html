<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Capítulo 11. Puntos de red temporales</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.3 Manual de usuario"><link rel="up" href="index.html" title="MobilityDB 1.3 Manual de usuario"><link rel="prev" href="ch10s03.html" title="Estadísticas y selectividad"><link rel="next" href="ch11s02.html" title="Puntos de red temporales"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 11. Puntos de red temporales</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch10s03.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch11s02.html">Siguiente</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="temporal_network_points"></a>Capítulo 11. Puntos de red temporales</h1></div></div></div><div class="toc"><p><b>Tabla de contenidos</b></p><dl class="toc"><dt><span class="sect1"><a href="ch11.html#static_network_types">Tipos de red estáticos</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch11.html#constructor_functions">Constructores</a></span></dt><dt><span class="sect2"><a href="ch11.html#idm6421">Transformaciones</a></span></dt><dt><span class="sect2"><a href="ch11.html#accessor_functions">Accesores</a></span></dt><dt><span class="sect2"><a href="ch11.html#spatial_functions">Operaciones espaciales</a></span></dt><dt><span class="sect2"><a href="ch11.html#static_operators">Comparaciones</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch11s02.html">Puntos de red temporales</a></span></dt><dt><span class="sect1"><a href="ch11s03.html">Validez de los puntos de red temporal</a></span></dt><dt><span class="sect1"><a href="ch11s04.html">Constructores</a></span></dt><dt><span class="sect1"><a href="ch11s05.html">Conversión de tipos</a></span></dt><dt><span class="sect1"><a href="ch11s06.html">Operaciones para los tipos de puntos de red</a></span></dt><dt><span class="sect1"><a href="ch11s07.html">Agregacions</a></span></dt><dt><span class="sect1"><a href="ch11s08.html">Indexación</a></span></dt></dl></div><p>Los puntos temporales que hemos considerado hasta ahora representan el movimiento de objetos que pueden moverse libremente en el espacio ya que se supone que pueden cambiar su posición de un lugar a otro sin ninguna restricción de movimiento. Este es el caso de los animales y de los objetos voladores como aviones o drones. Sin embargo, en muchos casos, los objetos no se mueven libremente en el espacio sino dentro de redes integradas espacialmente, como rutas o ferrocarriles. En este caso, es necesario tener en cuenta de las redes integradas al describir los movimientos de estos objetos en movimiento. Los puntos de red temporales tienen en cuenta estos requisitos.</p><p>En comparación con los puntos temporales de espacio libre, los puntos basados en red tienen las siguientes ventajas:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Los puntos de red temporales proporcionan restricciones que reflejan los movimientos reales de los objetos en movimiento.</p></li><li class="listitem"><p>La información geométrica no se almacena con el punto móvil, sino de una vez por todas en las redes fijas. De esta forma, las representaciones e interpolaciones de la ubicación son más precisas.</p></li><li class="listitem"><p>Los puntos de red temporales son más eficientes en términos de almacenamiento de datos, actualización de ubicación, formulación de consultas e indexación. Estos aspectos se tratan más adelante en este documento.</p></li></ul></div><p>Los puntos de red temporales se basan en <a class="ulink" href="https://pgrouting.org/" target="_top">pgRouting</a>, una extensión de PostgreSQL para desarrollar aplicaciones de enrutamiento de red y realizar análisis de gráficos. Por lo tanto, los puntos de red temporal asumen que la red subyacente está definida en una tabla llamada <code class="varname">ways</code>, que tiene al menos tres columnas: <code class="varname">gid</code> que contiene el identificador de ruta único, <code class="varname">length</code> que contiene la longitud de la ruta y <code class="varname">the_geom</code> que contiene la geometría de la ruta.</p><p>Hay dos tipos de red estáticos, <code class="varname">npoint</code> (abreviatura de <span class="emphasis"><em>network point</em></span>) y <code class="varname">nsegment</code> (abreviatura de <span class="emphasis"><em>network segment</em></span>), que representan, respectivamente, un punto y un segmento de una ruta. Un valor <code class="varname">npoint</code> se compone de un identificador de ruta y un número flotante en el rango [0,1] que determina una posición relativa de la ruta, donde 0 corresponde al comienzo de la ruta y 1 al final de la ruta. Un valor de <code class="varname">nsegment</code> se compone de un identificador de ruta y dos números flotantes en el rango [0,1] que determinan las posiciones relativas de inicio y finalización. Un valor de <code class="varname">nsegment</code> cuyas posiciones inicial y final son iguales corresponde a un valor de <code class="varname">npoint</code>.</p><p>El tipo <code class="varname">npoint</code> sirve como tipo base para definir el tipo punto de red temporal <code class="varname">tnpoint</code>. El tipo <code class="varname">tnpoint</code> tiene una funcionalidad similar al tipo de punto temporal <code class="varname">tgeompoint</code> con la excepción de que solo considera dos dimensiones. Por lo tanto, todas las funciones y operadores descritos anteriormente para el tipo <code class="varname">tgeompoint</code> también son aplicables para el tipo <code class="varname">tnpoint</code>. Además, hay funciones específicas definidas para el tipo <code class="varname">tnpoint</code>.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static_network_types"></a>Tipos de red estáticos</h2></div></div></div><p>Un valor <code class="varname">npoint</code> es un par de la forma <code class="varname">(rid, position)</code> donde <code class="varname">rid</code> es un valor <code class="varname">bigint</code> que representa un identificador de ruta y <code class="varname">position</code> es un valor <code class="varname">float</code> en el rango [0,1] que indica su posición relativa. Los valores 0 y 1 de <code class="varname">position</code> denotan, respectivamente, la posición inicial y final de la ruta. La distancia de la ruta entre un valor de <code class="varname">npoint</code> y la posición inicial de la ruta con el identificador <code class="varname">rid</code> se calcula multiplicando <code class="varname">position</code> por <code class="varname">length</code>, donde este último es la longitud de la ruta. Ejemplos de entrada de valores de puntos de red son los siguientes:</p><pre class="programlisting">
SELECT npoint 'Npoint(76, 0.3)';
SELECT npoint 'Npoint(64, 1.0)';
</pre><p>La función de constructor para puntos de red tiene un argumento para el identificador de ruta y un argumento para la posición relativa. Un ejemplo de un valor de punto de red definido con la función constructora es el siguiente:</p><pre class="programlisting">
SELECT npoint(76, 0.3);
</pre><p>Un valor <code class="varname">nsegment</code> es un triple de la forma <code class="varname">(rid, startPosition, endPosition)</code> donde <code class="varname">rid</code> es un valor <code class="varname">bigint</code> que representa un identificador de ruta y <code class="varname">startPosition</code> y <code class="varname">endPosition</code> son valores de <code class="varname">float</code> en el rango [0,1] tal que <code class="varname">startPosition ≤ endPosition</code>. Semánticamente, un segmento de red representa un conjunto de puntos de red <code class="varname">(rid, position)</code> con <code class="varname">startPosition ≤ position ≤ endPosition</code>. Si <code class="varname">startPosition = 0</code> y <code class="varname">endPosition = 1</code>, el segmento de red es equivalente a la ruta completa. Si <code class="varname">startPosition = endPosition</code>, el segmento de red representa un único punto de red. Ejemplos de entrada de valores de puntos de red son los siguientes:</p><pre class="programlisting">
SELECT nsegment 'Nsegment(76, 0.3, 0.5)';
SELECT nsegment 'Nsegment(64, 0.5, 0.5)';
SELECT nsegment 'Nsegment(64, 0.0, 1.0)';
SELECT nsegment 'Nsegment(64, 1.0, 0.0)';
-- convertido a nsegment 'Nsegment(64, 0.0, 1.0)';
</pre><p>Como se puede ver en el último ejemplo, los valores <code class="varname">startPosition</code> y <code class="varname">endPosition</code> se invertirán para asegurar que la condición <code class="varname">startPosition ≤ endPosition</code> siempre se satisface. La función de constructor para segmentos de red tiene un argumento para el identificador de ruta y dos argumentos opcionales para las posiciones inicial y final. Los ejemplos de valores de segmento de red definidos con la función constructora son los siguientes:</p><pre class="programlisting">
SELECT nsegment(76, 0.3, 0.3);
SELECT nsegment(76); -- se asume que las posiciones inicial y final son 0 y 1
SELECT nsegment(76, 0.5); -- se asume que la posición final es 1
</pre><p>Los valores del tipo <code class="varname">npoint</code> se pueden convertir al tipo <code class="varname">nsegment</code> usando un <code class="varname">CAST</code> explícito o usando la notación <code class="varname">::</code> como se muestra a continuación.</p><pre class="programlisting">
SELECT npoint(76, 0.33)::nsegment;
</pre><p>Los valores de los tipos de red estáticos deben satisfacer varias restricciones para que estén bien definidos. Estas restricciones se dan a continuación.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>El identificador de ruta <code class="varname">rid</code> debe encontrarse en la columna <code class="varname">gid</code> de la tabla <code class="varname">ways</code>.</p></li><li class="listitem"><p>Los valores de <code class="varname">position</code>, <code class="varname">startPosition</code> y <code class="varname">endPosition</code> deben estar en el rango [0,1]. Se genera un error cuando no se cumple una de estas restricciones.</p></li></ul></div><p>Ejemplos de valores de tipo de red estática incorrectos son los siguientes.</p><pre class="programlisting">
-- Valor rid incorrecto
SELECT npoint 'Npoint(87.5, 1.0)';
-- Valor de posición incorrecto
SELECT npoint 'Npoint(87, 2.0)';
-- Valor rid inexistente en la table ways
SELECT npoint 'Npoint(99999999, 1.0)';
</pre><p>Damos a continuación las funciones y operadores para los tipos de redes estáticas.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="constructor_functions"></a>Constructores</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint"></a><a class="indexterm" name="idm6406"></a><p>Constructor de puntos de red</p><p><code class="varname">npoint(bigint,double precision) → npoint</code></p><pre class="programlisting">
SELECT npoint(76, 0.3);
</pre></li><li class="listitem"><a name="nsegment"></a><a class="indexterm" name="idm6414"></a><p>Constructor de segmentos de red</p><p><code class="varname">nsegment(bigint,double precision,double precision) → nsegment</code></p><pre class="programlisting">
SELECT nsegment(76, 0.3, 0.5);
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm6421"></a>Transformaciones</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_round"></a><a class="indexterm" name="idm6425"></a><p>Redondear la(s) posición(es) del punto de red or el segmento de red en el número de posiciones decimales</p><p><code class="varname">round({npoint,nsegment},integer=0) → {npoint,nsegment}</code></p><pre class="programlisting">
SELECT round(npoint(76, 0.123456789), 6);
--  NPoint(76,0.123457)
SELECT round(nsegment(76, 0.123456789, 0.223456789), 6);
--  NSegment(76,0.123457,0.223457)
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="accessor_functions"></a>Accesores</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="route"></a><a class="indexterm" name="idm6436"></a><p>Devuelve el identificador de ruta</p><p><code class="varname">route({npoint,nsegment}) → bigint</code></p><pre class="programlisting">
SELECT route(npoint 'Npoint(63, 0.3)');
-- 63
SELECT route(nsegment 'Nsegment(76, 0.3, 0.3)');
-- 76
</pre></li><li class="listitem"><a name="getPosition"></a><a class="indexterm" name="idm6444"></a><p>Devuelve la posición</p><p><code class="varname">getPosition(npoint) → float</code></p><pre class="programlisting">
SELECT getPosition(npoint 'Npoint(63, 0.3)');
-- 0.3
</pre></li><li class="listitem"><a name="startPosition"></a><a class="indexterm" name="idm6452"></a><a class="indexterm" name="idm6455"></a><p>Devuelve la posición inicial/final</p><p><code class="varname">startPosition(nsegment) → float</code></p><p><code class="varname">endPosition(nsegment) → float</code></p><pre class="programlisting">
SELECT startPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.3
SELECT endPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.5
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="spatial_functions"></a>Operaciones espaciales</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_srid"></a><a class="indexterm" name="idm6468"></a><p>Devuelve el identificador de referencia espacial</p><p><code class="varname">SRID({npoint,nsegment}) → integer</code></p><pre class="programlisting">
SELECT SRID(npoint 'Npoint(76, 0.3)');
-- 5676
SELECT SRID(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 5676
</pre></li></ul></div><p>Los valores de los tipos <code class="varname">npoint</code> y <code class="varname">nsegment</code> se pueden convertir al tipo <code class="varname">geometry</code> usando un <code class="varname">CAST</code> explícito o usando la notación <code class="varname">::</code> como se muestra a continuación.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_geometry"></a><a class="indexterm" name="idm6483"></a><p>Convertir un punto de red en una geometría</p><p><code class="varname">{npoint,nsegment}::geometry</code></p><pre class="programlisting">
SELECT ST_AsText(npoint(76, 0.33)::geometry);
-- POINT(21.6338731332283 50.0545869554067)
SELECT ST_AsText(nsegment(76, 0.33, 0.66)::geometry);
-- LINESTRING(21.6338731332283 50.0545869554067,30.7475989651999 53.9185062927473)
SELECT ST_AsText(nsegment(76, 0.33, 0.33)::geometry);
-- POINT(21.6338731332283 50.0545869554067)
</pre></li></ul></div><p>De manera similar, los valores de tipo <code class="varname">geometry</code> de subtipo <code class="varname">point</code> o <code class="varname">linestring</code> (restringidos a dos puntos) se pueden convertir, respectivamente, en valores <code class="varname">npoint</code> y <code class="varname">nsegment</code> usando un <code class="varname">CAST</code> explícito o usando la notación <code class="varname">::</code>. Para ello se debe encontrar la ruta que interseca los puntos dados, donde se asume una tolerancia de 0.00001 unidades (dependiendo del sistema de coordenadas) por lo que se considera que un punto y una ruta que están cerca se cruzan. Si no se encuentra dicha ruta, se devuelve un valor nulo.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="geometry_npoint"></a><a class="indexterm" name="idm6500"></a><p>Convertir una geometría en un punto de red</p><p><code class="varname">geometry::{npoint,nsegment}</code></p><pre class="programlisting">
SELECT geometry 'Point(279.269156511873 811.497076880187)'::npoint;
-- NPoint(3,0.781413)
SELECT geometry 'LINESTRING(406.729536784738 702.58583437902,
  383.570801314823 845.137059419277)'::nsegment;
-- NSegment(3,0.6,0.9)
SELECT geometry 'Point(279.3 811.5)'::npoint;
-- NULL
SELECT geometry 'LINESTRING(406.7 702.6,383.6 845.1)'::nsegment;
-- NULL
</pre></li></ul></div><p>Dos valores <code class="varname">npoint</code> pueden tener diferentes identificadores de ruta pero pueden representar el mismo punto espacial en la intersección de las dos rutas. La función <code class="varname">equals</code> se utiliza para verificar la igualdad espacial de los puntos de la red.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_same"></a><a class="indexterm" name="idm6512"></a><p>Igualdad espacial para puntos de red</p><p><code class="varname">equals(npoint, npoint)::Boolean</code></p><pre class="programlisting">
WITH inter(geom) AS (
  SELECT st_intersection(t1.the_geom, t2.the_geom)
  FROM ways t1, ways t2 WHERE t1.gid = 1 AND t2.gid = 2),
fractions(f1, f2) AS (
  SELECT ST_LineLocatePoint(t1.the_geom, i.geom), ST_LineLocatePoint(t2.the_geom, i.geom)
  FROM ways t1, ways t2, inter i WHERE t1.gid = 1 AND t2.gid = 2)
SELECT equals(npoint(1, f1), npoint(2, f2)) FROM fractions;
-- true
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="static_operators"></a>Comparaciones</h3></div></div></div><p>Los operadores de comparación (=, &lt; y así sucesivamente) para tipos de red estáticos requieren que los argumentos izquierdo y derecho sean del mismo tipo. Excepto la igualdad y la desigualdad, los otros operadores de comparación no son útiles en el mundo real pero permiten que los índices de árbol B se construyan en tipos de red estáticos.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="static_eq"></a><a class="indexterm" name="idm6524"></a><p>¿Son iguales los valores?</p><p><code class="varname">{npoint,nsegment} = {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(3, 0.5)' = npoint 'Npoint(3, 0.5)';
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' = nsegment 'Nsegment(3, 0.5, 0.6)';
-- false
</pre></li><li class="listitem"><a name="static_ne"></a><a class="indexterm" name="idm6532"></a><p>¿Son diferentes los valores?</p><p><code class="varname">{npoint,nsegment} &lt;&gt; {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(3, 0.5)' &lt;&gt; npoint 'Npoint(3, 0.6)';
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt;&gt; nsegment 'Nsegment(3, 0.5, 0.5)';
-- false
</pre></li><li class="listitem"><a name="static_lt"></a><a class="indexterm" name="idm6540"></a><p>¿El primer valor es menor que el segundo?</p><p><code class="varname">{npoint,nsegment} &lt; {npoint,nsegment}</code></p><pre class="programlisting">
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt; nsegment 'Nsegment(3, 0.5, 0.6)';
-- true
</pre></li><li class="listitem"><a name="static_gt"></a><a class="indexterm" name="idm6548"></a><p>¿El primer valor es mayor que el segundo?</p><p><code class="varname">{npoint,nsegment} &gt; {npoint,nsegment}</code></p><pre class="programlisting">
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &gt; nsegment 'Nsegment(2, 0.5, 0.5)';
-- true
</pre></li><li class="listitem"><a name="static_le"></a><a class="indexterm" name="idm6556"></a><p>¿El primer valor es menor o igual que el segundo?</p><p><code class="varname">{npoint,nsegment} &lt;= {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(1, 0.5)' &lt;= npoint 'Npoint(2, 0.5)';
-- true
</pre></li><li class="listitem"><a name="static_ge"></a><a class="indexterm" name="idm6564"></a><p>¿El primer valor es mayor o igual que el segundo?</p><p><code class="varname">{npoint,nsegment} &gt;= {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(1, 0.6)' &gt;= npoint 'Npoint(1, 0.5)';
-- true
</pre></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch10s03.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch11s02.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Estadísticas y selectividad </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Puntos de red temporales</td></tr></table></div></body></html>
