<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Accesores</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.1 Manual de usuario"><link rel="up" href="ch05.html" title="Capítulo 5. Tipos temporales: Operaciones genéricas (Parte 1)"><link rel="prev" href="ch05s04.html" title="Conversión de tipos"><link rel="next" href="ch05s06.html" title="Transformaciones"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Accesores</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s04.html">Anterior</a> </td><th width="60%" align="center">Capítulo 5. Tipos temporales: Operaciones genéricas (Parte 1)</th><td width="20%" align="right"> <a accesskey="n" href="ch05s06.html">Siguiente</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="temporal_types_accessors"></a>Accesores</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="ttype_memSize"></a><a class="indexterm" name="idm2798"></a><p>Obtener el tamaño de la memoria en bytes</p><p><code class="varname">memSize(ttype) → integer</code></p><pre class="programlisting">
SELECT memSize(tint '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- 176
</pre></li><li class="listitem"><a name="tempSubtype"></a><a class="indexterm" name="idm2806"></a><p>Obtener el subtipo temporal</p><p><code class="varname">tempSubtype(ttype) → {'Instant','Sequence','SequenceSet'}</code></p><pre class="programlisting">
SELECT tempSubtype(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Sequence
</pre></li><li class="listitem"><a name="interp"></a><a class="indexterm" name="idm2814"></a><p>Obtener la interpolación</p><p><code class="varname">interp(ttype) → {'Discrete','Step','Linear'}</code></p><pre class="programlisting">
SELECT interp(tfloat '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- Discrete
SELECT interp(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Step
SELECT interp(tfloat '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Linear
SELECT interp(tfloat 'Interp=Step;[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Step
SELECT interp(tgeompoint 'Interp=Step;[Point(1 1)@2001-01-01,
  Point(2 2)@2001-01-02, Point(3 3)@2001-01-03]');
-- Step
</pre></li><li class="listitem"><a name="getValue"></a><a class="indexterm" name="idm2822"></a><a class="indexterm" name="idm2825"></a><p>Obtener el valor o la marca de tiempo de un instantes</p><p><code class="varname">getValue(ttypeInst) → base</code></p><p><code class="varname">getTimestamp(ttypeInst) → timestamptz</code></p><pre class="programlisting">
SELECT getValue(tint '1@2001-01-01');
-- 1
SELECT getTimestamp(tfloat '1@2001-01-01');
-- 2001-01-01
</pre></li><li class="listitem"><a name="getValues"></a><a class="indexterm" name="idm2835"></a><p>Obtener los valores o el tiempo en el que se define el valor temporal</p><p><code class="varname">getValues(talpha) → {bool[],spanset,textset}</code></p><p><code class="varname">getTime(ttype) → tstzspanset</code></p><pre class="programlisting">
SELECT getValues(tbool '[false@2001-01-01, true@2001-01-02, false@2001-01-03]');
-- {f,t}
SELECT getValues(tint '[1@2001-01-01, 3@2001-01-02, 1@2001-01-03]');
-- {[1, 2), [3, 4)}
SELECT getValues(tint '{[1@2001-01-01, 2@2001-01-02, 1@2001-01-03],
  [4@2001-01-04, 4@2001-01-05]}');
-- {[1, 3), [4, 5)}
SELECT getValues(tfloat '{1@2001-01-01, 2@2001-01-02, 1@2001-01-03}');
-- {[1, 1], [2, 2]}
SELECT getValues(tfloat 'Interp=Step;{[1@2001-01-01, 2@2001-01-02, 1@2001-01-03],
  [3@2001-01-04, 3@2001-01-05]}');
-- {[1, 1], [2, 2], [3, 3]}
SELECT getValues(tfloat '[1@2001-01-01, 2@2001-01-02, 1@2001-01-03]');
-- {[1, 2]}
SELECT getValues(tfloat '{[1@2001-01-01, 2@2001-01-02, 1@2001-01-03],
  [3@2001-01-04, 3@2001-01-05]}');
-- {[1, 2], [3, 3]}
</pre><pre class="programlisting">
SELECT getTime(ttext 'walking@2001-01-01');
-- {[2001-01-01, 2001-01-01]}
SELECT getTime(tfloat '{1@2001-01-01, 2@2001-01-02, 1@2001-01-03}');
-- {[2001-01-01, 2001-01-01], [2001-01-02, 2001-01-02], [2001-01-03, 2001-01-03]}
SELECT getTime(tint '[1@2001-01-01, 1@2001-01-15)');
-- {[2001-01-01, 2001-01-15)}
SELECT getTime(tfloat '{[1@2001-01-01, 1@2001-01-10), [12@2001-01-12, 12@2001-01-15]}');
-- {[2001-01-01, 2001-01-10), [2001-01-12, 2001-01-15]}
</pre></li><li class="listitem"><a name="valueSpan"></a><a class="indexterm" name="idm2846"></a><a class="indexterm" name="idm2849"></a><p>Obtener el rango de valores o el rango de tiempo ignorando las posibles brechas</p><p><code class="varname">valueSpan(tnumber) → numspan</code></p><p><code class="varname">timeSpan(ttype) → tstzspan</code></p><pre class="programlisting">
SELECT valueSpan(tint '{[1@2001-01-01, 1@2001-01-03), [4@2001-01-03, 6@2001-01-05]}');
-- [1,7)
SELECT valueSpan(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [1,3])
</pre><pre class="programlisting">
SELECT timeSpan(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [2001-01-01, 2001-01-05]
SELECT timeSpan(tfloat '{[1@2001-01-01, 1@2001-01-02), [2@2001-01-03, 3@2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</pre></li><li class="listitem"><a name="valueSet"></a><a class="indexterm" name="idm2860"></a><p>Obtener los valores del número o punto temporal como un conjunto</p><p><code class="varname">valueSet(tnumber,tpoint) → {numset,geoset}</code></p><pre class="programlisting">
SELECT valueSet(tint '[1@2001-01-01, 2@2001-01-03]');
-- {1, 2}
SELECT valueSet(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 4@2001-01-05)}');
-- {1, 2, 3, 4}
SELECT asText(valueSet(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04)}'));
-- {"POINT(0 0)", "POINT(1 1)", "POINT(0 1)"}
</pre></li><li class="listitem"><a name="startValue"></a><a class="indexterm" name="idm2868"></a><a class="indexterm" name="idm2871"></a><p>Obtener el valor inicial o final</p><p><code class="varname">startValue(ttype) → base</code></p><p><code class="varname">endValue(ttype) → base</code></p><p>La función no tiene en cuenta si los límites son inclusivos o no.</p><pre class="programlisting">
SELECT startValue(tfloat '(1@2001-01-01, 2@2001-01-03)');
-- 1
SELECT endValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</pre></li><li class="listitem"><a name="minValue"></a><a class="indexterm" name="idm2882"></a><a class="indexterm" name="idm2885"></a><p>Obtener el valor mínimo o máximo</p><p><code class="varname">minValue(torder) → base</code></p><p><code class="varname">maxValue(torder) → base</code></p><p>La función no tiene en cuenta si los límites son inclusivos o no.</p><pre class="programlisting">
SELECT minValue(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1
SELECT maxValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</pre></li><li class="listitem"><a name="minInstant"></a><a class="indexterm" name="idm2896"></a><a class="indexterm" name="idm2899"></a><p>Obtener el instante con el valor mínimo o máximo</p><p><code class="varname">minInstant(torder) → base</code></p><p><code class="varname">maxInstant(torder) → base</code></p><p>La función no tiene en cuenta si los límites son inclusivos o no. Si varios instantes tienen el valor mínimo, se devuelve el primero.</p><pre class="programlisting">
SELECT minInstant(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1@2001-01-01
SELECT maxInstant(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5@2001-01-05
</pre></li><li class="listitem"><a name="valueAtTimestamp"></a><a class="indexterm" name="idm2910"></a><p>Obtener el valor en una marca de tiempo</p><p><code class="varname">valueAtTimestamp(ttype,timestamptz) → base</code></p><pre class="programlisting">
SELECT valueAtTimestamp(tfloat '[1@2001-01-01, 4@2001-01-04)', '2001-01-02');
-- 2
</pre></li><li class="listitem"><a name="ttype_duration"></a><a class="indexterm" name="idm2918"></a><p>Obtener el intervalo de tiempo</p><p><code class="varname">duration(ttype,boundspan=false) → interval</code></p><p>Se puede poner en verdadero un parámetro adicional para calcular la duración del período limitador, ignorando así los posibles intervalos de tiempo</p><pre class="programlisting">
SELECT duration(tfloat '{1@2001-01-01, 2@2001-01-03, 2@2001-01-05}');
-- 00:00:00
SELECT duration(tfloat '{1@2001-01-01, 2@2001-01-03, 2@2001-01-05}', true);
-- 4 days
SELECT duration(tfloat '[1@2001-01-01, 2@2001-01-03, 2@2001-01-05)');
-- 4 days
SELECT duration(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}');
-- 3 days
SELECT duration(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}',
  true);
-- 4 days
</pre></li><li class="listitem"><a name="lowerInc"></a><a class="indexterm" name="idm2927"></a><a class="indexterm" name="idm2930"></a><p>¿Es el instante inicial/final inclusivo?</p><p><code class="varname">lowerInc(ttype) → bool</code></p><p><code class="varname">upperInc(ttype) → bool</code></p><pre class="programlisting">
SELECT lowerInc(tint '[1@2001-01-01, 2@2001-01-02)');
-- true
SELECT upperInc(tfloat '{[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03)}');
-- false
</pre></li><li class="listitem"><a name="numInstants"></a><a class="indexterm" name="idm2940"></a><p>Obtener el número de instantes diferentes</p><p><code class="varname">numInstants(ttype) → integer</code></p><pre class="programlisting">
SELECT numInstants(tfloat '{[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03)}');
-- 3
</pre></li><li class="listitem"><a name="startInstant"></a><a class="indexterm" name="idm2948"></a><a class="indexterm" name="idm2951"></a><a class="indexterm" name="idm2954"></a><p>Obtener el instante inicial, final o enésimo</p><p><code class="varname">startInstant(ttype) → ttypeInst</code></p><p><code class="varname">endInstant(ttype) → ttypeInst</code></p><p><code class="varname">instantN(ttype,integer) → ttypeInst</code></p><p>La función no tiene en cuenta si los límites son inclusivos o no.</p><pre class="programlisting">
SELECT startInstant(tfloat '{[1@2001-01-01, 2@2001-01-02), 
  (2@2001-01-02, 3@2001-01-03)}');
-- 1@2001-01-01
SELECT endInstant(tfloat '{[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03)}');
-- 3@2001-01-03
SELECT instantN(tfloat '{[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03)}', 3);
-- 3@2001-01-03
</pre></li><li class="listitem"><a name="instants"></a><a class="indexterm" name="idm2967"></a><p>Obtener los instantes diferentes</p><p><code class="varname">instants(ttype) → ttypeInst[]</code></p><pre class="programlisting">
SELECT instants(tfloat '{[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03)}');
-- {"1@2001-01-01","2@2001-01-02","3@2001-01-03"}
</pre></li><li class="listitem"><a name="ttype_numTimestamps"></a><a class="indexterm" name="idm2975"></a><p>Obtener el número de marcas de tiempo diferentes</p><p><code class="varname">numTimestamps(ttype) → integer</code></p><pre class="programlisting">
SELECT numTimestamps(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 3
</pre></li><li class="listitem"><a name="ttype_startTimestamp"></a><a class="indexterm" name="idm2983"></a><a class="indexterm" name="idm2986"></a><a class="indexterm" name="idm2989"></a><p>Obtener la marca de tiempo inicial, final o enésima</p><p><code class="varname">startTimestamp(ttype) → timestamptz</code></p><p><code class="varname">endTimestamp(ttype) → timestamptz</code></p><p><code class="varname">timestampN(ttype,integer) → timestamptz</code></p><p>La función no tiene en cuenta si los límites son inclusivos o no.</p><pre class="programlisting">
SELECT startTimestamp(tfloat '[1@2001-01-01, 2@2001-01-03)');
-- 2001-01-01
SELECT endTimestamp(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2001-01-05
SELECT timestampN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 3);
-- 2001-01-05
</pre></li><li class="listitem"><a name="ttype_timestamps"></a><a class="indexterm" name="idm3002"></a><p>Obtener las marcas de tiempo diferentes</p><p><code class="varname">timestamps(ttype) → timestamptz[]</code></p><pre class="programlisting">
SELECT timestamps(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"2001-01-01", "2001-01-03", "2001-01-05"}
</pre></li><li class="listitem"><a name="numSequences"></a><a class="indexterm" name="idm3010"></a><p>Obtener el número de secuencias</p><p><code class="varname">numSequences({ttypeContSeq,ttypeSeqSet}) → integer</code></p><pre class="programlisting">
SELECT numSequences(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2
</pre></li><li class="listitem"><a name="startSequence"></a><a class="indexterm" name="idm3018"></a><a class="indexterm" name="idm3021"></a><a class="indexterm" name="idm3024"></a><p>Obtener la secuencia inicial, final, o enésima</p><p><code class="varname">startSequence({ttypeContSeq,ttypeSeqSet}) → ttypeContSeq</code></p><p><code class="varname">endSequence({ttypeContSeq,ttypeSeqSet}) → ttypeContSeq</code></p><p><code class="varname">sequenceN({ttypeContSeq,ttypeSeqSet},integer) → ttypeContSeq</code></p><pre class="programlisting">
SELECT startSequence(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- [1@2001-01-01, 2@2001-01-03)
SELECT endSequence(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- [3@2001-01-03, 5@2001-01-05)
SELECT sequenceN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 2);
-- [3@2001-01-03, 5@2001-01-05)
</pre></li><li class="listitem"><a name="sequences"></a><a class="indexterm" name="idm3036"></a><p>Obtener las secuencias</p><p><code class="varname">sequences({ttypeContSeq,ttypeSeqSet}) → ttypeContSeq[]</code></p><pre class="programlisting">
SELECT sequences(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"[1@2001-01-01, 2@2001-01-03)", "[3@2001-01-03, 5@2001-01-05)"}
</pre></li><li class="listitem"><a name="segments"></a><a class="indexterm" name="idm3044"></a><p>Obtener los segmentos</p><p><code class="varname">segments({ttypeContSeq,ttypeSeqSet}) → ttypeContSeq[]</code></p><pre class="programlisting">
SELECT segments(tint '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 1@2001-01-02)","[3@2001-01-02, 3@2001-01-03)","[2@2001-01-03]",
  "(3@2001-01-03, 3@2001-01-05)","[5@2001-01-05]"} */
SELECT segments(tfloat '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 3@2001-01-02)","[3@2001-01-02, 2@2001-01-03]",
   "(3@2001-01-03, 5@2001-01-05]"} */
</pre></li><li class="listitem"><a name="integral"></a><a class="indexterm" name="idm3052"></a><p>Obtener el área bajo la curva</p><p><code class="varname">integral(tnumber) → float</code></p><pre class="programlisting">
SELECT  integral(tint '[1@2001-01-01,2@2001-01-02]') / (24 * 3600 * 1e6);
-- 1
SELECT integral(tfloat '[1@2001-01-01,2@2001-01-02]') / (24 * 3600 * 1e6);
-- 1.5
</pre></li><li class="listitem"><a name="twAvg"></a><a class="indexterm" name="idm3060"></a><p>Obtener el promedio ponderado en el tiempo</p><p><code class="varname">twAvg(tnumber) → float</code></p><pre class="programlisting">
SELECT twAvg(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-06)}');
-- 1.75
</pre></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s04.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="ch05s06.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Conversión de tipos </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Transformaciones</td></tr></table></div></body></html>
