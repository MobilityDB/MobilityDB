<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Comparaciones</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.2 Manual de usuario"><link rel="up" href="ch06.html" title="Capítulo 6. Tipos temporales: Operaciones genéricas (Parte 2)"><link rel="prev" href="ch06s02.html" title="Restricciones"><link rel="next" href="ch06s04.html" title="Operadores de cuadro delimitador"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Comparaciones</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06s02.html">Anterior</a> </td><th width="60%" align="center">Capítulo 6. Tipos temporales: Operaciones genéricas (Parte 2)</th><td width="20%" align="right"> <a accesskey="n" href="ch06s04.html">Siguiente</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="temporal_types_comparisons"></a>Comparaciones</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3536"></a>Comparaciones tradicionales</h3></div></div></div><p>Los operadores de comparación tradicionales (<code class="varname">=</code>, <code class="varname">&lt;</code>, etc.) requieren que los operandos izquierdo y derecho sean del mismo tipo base. Excepto la igualdad y la no igualdad, los otros operadores de comparación no son útiles en el mundo real pero permiten que los índices de árbol B se construyan sobre tipos temporales. Estos operadores comparan los períodos delimitadores (ver la <a class="xref" href="ch02s10.html" title="Comparaciones">“Comparaciones”</a>), después los cuadros delimitadores (ver la <a class="xref" href="ch03s10.html" title="Comparaciones">“Comparaciones”</a>) y si son iguales, entonces la comparación depende del subtipo. Para los valores de instante, primero comparan las marcas de tiempo y, si son iguales, comparan los valores. Para los valores de secuencia, comparan los primeros N instantes, donde N es el mínimo del número de instantes que componen ambos valores. Finalmente, para los valores de conjuntos de secuencias, comparan los primeros N valores de secuencia, donde N es el mínimo del número de secuencias que componen ambos valores.</p><p>Los operadores de igualdad y no igualdad consideran la representación equivalente para diferentes subtipos como se muestra a continuación.
				</p><pre class="programlisting">
SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';
-- true
SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';
-- true
SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';
-- true
SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =
  tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';
-- true
SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =
  tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';
-- true
</pre><p>
			</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="ttype_eq"></a><a class="indexterm" name="idm3547"></a><p>¿Son iguales los valores temporales?</p><p><code class="varname">ttype = ttype → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' = tint '[2@2001-01-03, 2@2001-01-05)';
-- false
</pre></li><li class="listitem"><a name="ttype_ne"></a><a class="indexterm" name="idm3555"></a><p>¿Son diferentes los valores temporales?</p><p><code class="varname">ttype &lt;&gt; ttype → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;&gt; tint '[2@2001-01-03, 2@2001-01-05)';
-- true
</pre></li><li class="listitem"><a name="ttype_lt"></a><a class="indexterm" name="idm3563"></a><p>¿Es el primer valor temporal menor que el segundo?</p><p><code class="varname">ttype &lt; ttype → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt; tint '[2@2001-01-03, 2@2001-01-05)';
-- true
</pre></li><li class="listitem"><a name="ttype_gt"></a><a class="indexterm" name="idm3571"></a><p>¿Es el primer valor temporal mayor que el segundo?</p><p><code class="varname">ttype &gt; ttype → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt; tint '[2@2001-01-03, 2@2001-01-05)';
-- false
</pre></li><li class="listitem"><a name="ttype_le"></a><a class="indexterm" name="idm3579"></a><p>¿Es el primer valor temporal menor o igual que el segundo?</p><p><code class="varname">ttype &lt;= ttype → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;= tint '[2@2001-01-03, 2@2001-01-05)';
-- true
</pre></li><li class="listitem"><a name="ttype_ge"></a><a class="indexterm" name="idm3587"></a><p>¿Es el primer valor temporal mayor o igual que el segundo?</p><p><code class="varname">ttype &gt;= ttype → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt;= tint '[2@2001-01-03, 2@2001-01-05)';
-- false
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ever_always_comparison"></a>Comparaciones alguna vez y siempre</h3></div></div></div><p>Una posible generalización de los operadores de comparación tradicionales (<code class="varname">=</code>, <code class="varname">&lt;&gt;</code>, <code class="varname">&lt;</code>, <code class="varname">&lt;=</code>, etc.) a tipos temporales consiste en determinar si la comparación es alguna vez o siempre verdadera. En este caso, el resultado es un valor booleano. MobilityDB proporciona operadores para probar si la comparación de un valor temporal y un valor del tipo base or dos valores temporales es alguna vez o siempre verdadera. Estos operadores se indican anteponiendo los operadores de comparación tradicionales con, respectivamente, <code class="varname">?</code> (alguna vez) y <code class="varname">%</code> (siempre). Algunos ejemplos son <code class="varname">?=</code>, <code class="varname">%&lt;&gt;</code> o <code class="varname">?&lt;=</code>. La igualdad y la no igualdad alguna vez o siempre están disponibles para todos los tipos temporales, mientras que las desigualdades alguna vez o siempre sólo están disponibles para los tipos temporales cuyo tipo base tiene un orden total definido, es decir, <code class="varname">tint</code>, <code class="varname">tfloat</code> o <code class="varname">ttext</code>. Las comparaciones alguna vez y siempre son operadores inversos: por ejemplo, <code class="varname">?=</code> es el inverso de <code class="varname">%&lt;&gt;</code> y <code class="varname">?&gt;</code> es el inverso de <code class="varname">%&lt;=</code>.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="ttype_eveq"></a><a class="indexterm" name="idm3615"></a><a class="indexterm" name="idm3618"></a><p>¿Es el valor temporal alguna vez o siempre igual al valor?</p><p><code class="varname">{base,ttype} ?= {base,ttype} → boolean</code></p><p><code class="varname">{base,ttype} %= {base,ttype} → boolean</code></p><p>La función no tiene en cuenta si los límites son inclusivos o no.</p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 3@2001-01-04]' ?= 2;
-- false
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?= 2;
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04]' ?=
  geometry 'Point(2 2)';
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' ?=
  geometry 'Point(2 2)';
-- false
</pre><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 1@2001-01-04)' %= 1;
-- true
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %= 2;
-- false
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' %=
  geometry 'Point(1 1)';
-- false
</pre></li><li class="listitem"><a name="ttype_evne"></a><a class="indexterm" name="idm3630"></a><a class="indexterm" name="idm3633"></a><p>¿Es el valor temporal alguna/siempre vez diferente del valor?</p><p><code class="varname">{base,ttype} ?&lt;&gt; {base,ttype} → boolean</code></p><p><code class="varname">{base,ttype} %&lt;&gt; {base,ttype} → boolean</code></p><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?&lt;&gt; 2;
-- true
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' ?&lt;&gt; 2;
-- false
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' ?&lt;&gt;
  geometry 'Point(1 1)';
-- false
</pre><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %&lt;&gt; 2;
-- false
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' %&lt;&gt; 3;
-- true
SELECT tgeogpoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' %&lt;&gt;
  geography 'Point(2 2)';
-- true
</pre></li><li class="listitem"><a name="ttype_evlt"></a><a class="indexterm" name="idm3644"></a><a class="indexterm" name="idm3647"></a><p>¿Es el valor temporal alguna vez o siempre menor que el valor?</p><p><code class="varname">{base,torder} ?&lt; {base,torder} → boolean</code></p><p><code class="varname">{base,torder} %&lt; {base,torder} → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 4@2001-01-04]' ?&lt; 2;
-- true
</pre><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' %&lt; 2;
-- false
</pre></li><li class="listitem"><a name="ttype_evgt"></a><a class="indexterm" name="idm3658"></a><a class="indexterm" name="idm3661"></a><p>¿Es el valor temporal alguna vez mayor que el valor?</p><p><code class="varname">{base,torder} ?&gt; {base,torder} → boolean</code></p><p><code class="varname">{base,torder} %&gt; {base,torder} → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-03, 1@2001-01-05]' ?&gt; 0;
-- true
</pre><pre class="programlisting">
SELECT tfloat '[1@2001-01-03, 1@2001-01-05)' %&gt; 1;
-- false
</pre></li><li class="listitem"><a name="ttype_evle"></a><a class="indexterm" name="idm3672"></a><a class="indexterm" name="idm3675"></a><p>¿Es el valor temporal alguna vez o siempre menor o igual que el valor?</p><p><code class="varname">{base,torder} ?&lt;= {base,torder} → boolean</code></p><p><code class="varname">{base,torder} %&lt;= {base,torder} → boolean</code></p><pre class="programlisting">
SELECT tint '[1@2001-01-01, 1@2001-01-05]' ?&lt;= 2;
-- true
</pre><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 1@2001-01-05)' %&lt;= 4;
-- true
</pre></li><li class="listitem"><a name="ttype_evge"></a><a class="indexterm" name="idm3686"></a><a class="indexterm" name="idm3689"></a><p>¿Es el valor temporal alguna vez o siempre mayor o igual que el valor?</p><p><code class="varname">{base,torder} ?&gt;= {base,torder} → boolean</code></p><p><code class="varname">{base,torder} %&gt;= {base,torder} → boolean</code></p><pre class="programlisting">
SELECT ttext '{[AAA@2001-01-01, AAA@2001-01-03), [BBB@2001-01-04, BBB@2001-01-05)}'
   ?&gt; 'AAA'::text;
-- true
</pre><pre class="programlisting">
SELECT ttext '{[AAA@2001-01-01, AAA@2001-01-03), [BBB@2001-01-04, BBB@2001-01-05)}'
   %&gt; 'AAA'::text;
-- false
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3699"></a>Comparaciones temporal</h3></div></div></div><p>Otra posible generalización de los operadores de comparación tradicionales (<code class="varname">=</code>, <code class="varname">&lt;&gt;</code>, <code class="varname">&lt;</code>, <code class="varname">&lt;=</code>, etc.) a tipos temporales consiste en determinar si la comparación es verdadera o falsa en cada instante. En este caso, el resultado es un booleano temporal. Los operadores de comparación temporal se indican anteponiendo los operadores de comparación tradicionales con <code class="varname">#</code>. Algunos ejemplos son <code class="varname">#=</code> o <code class="varname">#&lt;=</code>. La igualdad y no igualdad temporal están disponibles para todos los tipos temporales, mientras que las desigualdades temporales sólo están disponibles para los tipos temporales cuyo tipo base tiene un orden total definido, es decir, <code class="varname">tint</code>, <code class="varname">tfloat</code> o <code class="varname">ttext</code>.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="ttype_teq"></a><a class="indexterm" name="idm3714"></a><p>Igual temporal</p><p><code class="varname">{base,ttype} #= {base,ttype} → tbool</code></p><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 2@2001-01-04)' #= 3;
-- {[f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tfloat '[1@2001-01-01, 1@2001-01-04)';
-- {[t@2001-01-01], (f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tfloat '[4@2001-01-02, 1@2001-01-05)';
-- {[f@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  geometry 'Point(1 1)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  tgeompoint '{[Point(0 2)@2001-01-01], (Point(0 0)@2001-01-01,
  Point(2 2)@2001-01-03)}';
-- {[f@2001-01-01], (t@2001-01-01, t@2001-01-03)}
</pre></li><li class="listitem"><a name="ttype_tne"></a><a class="indexterm" name="idm3722"></a><p>Diferente temporal</p><p><code class="varname">{base,ttype} #&lt;&gt; {base,ttype} → tbool</code></p><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; 2;
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, 2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; tfloat '[2@2001-01-02, 2@2001-01-05)';
-- {[f@2001-01-02], (t@2001-01-02, t@2001-01-04)}
</pre></li><li class="listitem"><a name="ttype_tlt"></a><a class="indexterm" name="idm3730"></a><p>Menor que temporal</p><p><code class="varname">{base,torder} #&lt; {base,torder} → tbool</code></p><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tfloat '[2@2001-01-01, 2@2001-01-05)' #&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</pre></li><li class="listitem"><a name="ttype_tgt"></a><a class="indexterm" name="idm3738"></a><p>Mayor que temporal</p><p><code class="varname">{base,torder} #&gt; {base,torder} → tbool</code></p><pre class="programlisting">
SELECT 1 #&gt; tint '[1@2001-01-03, 1@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
</pre></li><li class="listitem"><a name="ttype_tle"></a><a class="indexterm" name="idm3746"></a><p>Menor o igual que temporal</p><p><code class="varname">{base,torder} #&lt;= {base,torder} → tbool</code></p><pre class="programlisting">
SELECT tfloat '[1@2001-01-01, 1@2001-01-05)' #&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</pre></li><li class="listitem"><a name="ttype_tge"></a><a class="indexterm" name="idm3754"></a><p>Mayor o igual que temporal</p><p><code class="varname">{base,torder} #&gt;= {base,torder} → tbool</code></p><pre class="programlisting">
SELECT 'AAA'::text #&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06s02.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="ch06.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06s04.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Restricciones </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Operadores de cuadro delimitador</td></tr></table></div></body></html>
