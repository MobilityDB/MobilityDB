<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Capítulo 2. Tipos de conjunto y de rango</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.3 Manual de usuario"><link rel="up" href="index.html" title="MobilityDB 1.3 Manual de usuario"><link rel="prev" href="ch01s08.html" title="Migración de la versión 1.0 a la versión 1.1"><link rel="next" href="ch02s02.html" title="Constructores"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 2. Tipos de conjunto y de rango</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s08.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch02s02.html">Siguiente</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="set_span_types"></a>Capítulo 2. Tipos de conjunto y de rango</h1></div></div></div><div class="toc"><p><b>Tabla de contenidos</b></p><dl class="toc"><dt><span class="sect1"><a href="ch02.html#idm614">Entrada y salida</a></span></dt><dt><span class="sect1"><a href="ch02s02.html">Constructores</a></span></dt><dt><span class="sect1"><a href="ch02s03.html">Conversión de tipos</a></span></dt><dt><span class="sect1"><a href="ch02s04.html">Accesores</a></span></dt><dt><span class="sect1"><a href="ch02s05.html">Transformaciones</a></span></dt><dt><span class="sect1"><a href="ch02s06.html">Sistema de referencia espacial</a></span></dt><dt><span class="sect1"><a href="ch02s07.html">Operaciones de conjuntos</a></span></dt><dt><span class="sect1"><a href="ch02s08.html">Operaciones de cuadro delimitador</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02s08.html#idm1246">Operaciones topológicas</a></span></dt><dt><span class="sect2"><a href="ch02s08.html#idm1282">Operaciones de posición</a></span></dt><dt><span class="sect2"><a href="ch02s08.html#setspan_bbox_split">Operaciones de división</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s09.html">Operaciones de distancia</a></span></dt><dt><span class="sect1"><a href="ch02s10.html">Comparaciones</a></span></dt><dt><span class="sect1"><a href="ch02s11.html">Agregaciones</a></span></dt><dt><span class="sect1"><a href="ch02s12.html">Indexación</a></span></dt></dl></div><p>
		MobilityDB proporciona los tipos de <span class="emphasis"><em>conjunto</em></span>, <span class="emphasis"><em>rango</em></span> y <span class="emphasis"><em>conjunto de rangos</em></span> para representar conjuntos de valores de otro tipo, que se denomina <span class="emphasis"><em>tipo base</em></span>. Los tipos de conjunto son similares a los tipos de matrices de PostgreSQL restringidos a una dimensión, pero imponen la restricción de que los conjuntos no tienen duplicados. Los tipos de rango y conjunto de rangos en MobilityDB corresponden a los tipos de rango y multirango en PostgreSQL pero tienen restricciones adicionales. En particular, los tipos de rango en MobilityDB tienen una longitud fija y no permiten rangos vacíos ni límites infinitos. Si bien los tipos de rango en MobilityDB proporcionan una funcionalidad similar a los tipos de rango en PostgreSQL, los tipos de rango en MobilityDB permiten aumentar el rendimiento. En particular, se elimina la sobrecarga del procesamiento de tipos de longitud variable y, además, se pueden utilizar la aritmética de punteros y la búsqueda binaria.
	</p><p>
		Los tipos de base que se utilizan para construir tipos de conjunto, de rango y de conjunto de rangos son los tipos <code class="varname">integer</code>, <code class="varname">bigint</code>, <code class="varname">float</code>, <code class="varname">text</code>, <code class="varname">date</code>, and <code class="varname">timestamptz</code> (marca de tiempo con zona horaria) proporcionados por PostgreSQL, los tipos <code class="varname">geometry</code> y <code class="varname">geography</code> proporcionados por PostGIS, y el tipo <code class="varname">npoint</code> (<span class="emphasis"><em>network point</em></span> o punto de red) proporcionado por MobilityDB (ver <a class="xref" href="ch11.html" title="Capítulo 11. Puntos de red temporales">Capítulo 11, <i>Puntos de red temporales</i></a>). MobilityDB proporciona los siguientes tipos de conjunto y de rango:
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">set</code>: <code class="varname">intset</code>, <code class="varname">bigintset</code>, <code class="varname">floatset</code>, <code class="varname">textset</code>, <code class="varname">dateset</code>, <code class="varname">tstzset</code>, <code class="varname">geomset</code>, <code class="varname">geogset</code>, <code class="varname">npointset</code>.</p></li><li class="listitem"><p><code class="varname">span</code>: <code class="varname">intspan</code>, <code class="varname">bigintspan</code>, <code class="varname">floatspan</code>, <code class="varname">datespan</code>, <code class="varname">tstzspan</code>.</p></li><li class="listitem"><p><code class="varname">spanset</code>: <code class="varname">intspanset</code>, <code class="varname">bigintspanset</code>, <code class="varname">floatspanset</code>, <code class="varname">datespanset</code>, <code class="varname">tstzspanset</code>.</p></li></ul></div><p>
	</p><p>
			A continuación presentamos las funciones y operadores para tipos de conjunto y de rango. Estas funciones y operadores son polimórficos, es decir, sus argumentos pueden ser de varios tipos y el tipo de resultado puede depender del tipo de los argumentos. Para expresar esto en la firma de las funciones y los operadores, utilizamos la siguiente notación:
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">set</code> representa cualquier tipo de conjunto, como <code class="varname">intset</code> o <code class="varname">tstzset</code>.</p></li><li class="listitem"><p><code class="varname">span</code> representa cualquier tipo de rango, como <code class="varname">intspan</code> o <code class="varname">tstzspan</code>.</p></li><li class="listitem"><p><code class="varname">spanset</code> representa cualquier tipo de conjunto de rangos, como <code class="varname">intspanset</code> o <code class="varname">tstzspanset</code>.</p></li><li class="listitem"><p><code class="varname">spans</code> representa cualquier tipo de rango o conjunto de rangos, como <code class="varname">intspan</code> o <code class="varname">tstzspanset</code>.</p></li><li class="listitem"><p><code class="varname">base</code> representa cualquier tipo de base de un tipo de conjunto o de rango, como <code class="varname">integer</code> o <code class="varname">timestamptz</code>.</p></li><li class="listitem"><p><code class="varname">number</code> representa cualquier tipo de base de un tipo de rango numérico, como <code class="varname">integer</code> o <code class="varname">float</code>,</p></li><li class="listitem"><p><code class="varname">numset</code> representa cualquier tipo de conjunto numérico, como <code class="varname">intset</code> o <code class="varname">floatset</code>.</p></li><li class="listitem"><p><code class="varname">numspans</code> representa cualquier tipo de rango o conjunto de rangos numérico, como <code class="varname">intspan</code> o <code class="varname">floatspanset</code>.</p></li><li class="listitem"><p><code class="varname">numbers</code> representa cualquier tipo de conjunto o de rango numérico, como <code class="varname">integer</code>, <code class="varname">intset</code>, <code class="varname">intspan</code> o <code class="varname">intspanset</code>,</p></li><li class="listitem"><p><code class="varname">dates</code> representa cualquier tipo de tiempo con granularidad <code class="varname">date</code>, a saber <code class="varname">date</code>, <code class="varname">dateset</code>, <code class="varname">datespan</code> o <code class="varname">datespanset</code>,</p></li><li class="listitem"><p><code class="varname">numset</code> representa cualquier tipo de conjunto numérico, como <code class="varname">intset</code> o <code class="varname">floatset</code>.</p></li><li class="listitem"><p><code class="varname">numspans</code> representa cualquier tipo de rango o conjunto de rangos numérico, como <code class="varname">intspan</code> o <code class="varname">floatspanset</code>.</p></li><li class="listitem"><p><code class="varname">numbers</code> representa cualquier tipo de conjunto o de rango numérico, como <code class="varname">integer</code>, <code class="varname">intset</code>, <code class="varname">intspan</code> o <code class="varname">intspanset</code>,</p></li><li class="listitem"><p><code class="varname">dates</code> representa cualquier tipo de tiempo con granularidad <code class="varname">date</code>, a saber <code class="varname">date</code>, <code class="varname">dateset</code>, <code class="varname">datespan</code> o <code class="varname">datespanset</code>,</p></li><li class="listitem"><p><code class="varname">times</code> representa cualquier tipo de tiempo con granularidad <code class="varname">timestamptz</code>, a saber <code class="varname">timestamptz</code>, <code class="varname">tstzset</code>, <code class="varname">tstzspan</code> o <code class="varname">tstzspanset</code>,</p></li><li class="listitem"><p>Un conjunto de tipos como <code class="varname">{set,base}</code> representa cualquiera de los tipos enumerados,</p></li><li class="listitem"><p><code class="varname">type[]</code> representa una matriz de <code class="varname">type</code>.</p></li></ul></div><p>
		Como ejemplo, la firma del operador contiene (<code class="varname">@&gt;</code>) es como sigue:
	</p><pre class="programlisting">
{set,spans} @&gt; {base,set,spans} → boolean
</pre><p>
		Nótese que la firma anterior es una versión abreviada de la firma más precisa a continuación
	</p><pre class="programlisting">
set @&gt; {base,set} → boolean
spans @&gt; {base,spans} → boolean
</pre><p>
			ya que los conjuntos y los rangos no se pueden mezclar en las operaciones y, por lo tanto, por ejemplo, no se puede preguntar si un rango contiene un conjunto. A continuación, por concisión, utilizamos el estilo abreviado de las firmas anteriores. Además, la parte de tiempo de las marcas de tiempo se omite en la mayoría de los ejemplos. Recuerde que en ese caso PostgreSQL asume el tiempo <code class="varname">00:00:00</code>.
	</p><p>
		A continuación, dado que los tipos de rango y conjunto de rangos tienen funciones y operadores similares, cuando hablamos de tipos rango nos referimos a los tipos de rango y conjuntos de rangos, a menos que nos refiramos explícitamente a los tipos de rango <span class="emphasis"><em>unitarios</em></span> y a los tipos de <span class="emphasis"><em>conjunto</em></span> de rangos para distinguirlos. Además, cuando nos referimos a tipos de tiempo, nos referimos a uno de los siguientes tipos: <code class="varname">timestamptz</code>, <code class="varname">tstzset</code>, <code class="varname">tstzspan</code> o <code class="varname">tstzspanset</code>.
	</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm614"></a>Entrada y salida</h2></div></div></div><p>
				MobilityDB generaliza los formatos de entrada y salida Well-Known Text (<a class="ulink" href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry" target="_top">WKT</a>) y Well-Known Binary (<a class="ulink" href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary" target="_top">WKB</a>) del Open Geospatial Consortium (<a class="ulink" href="https://www.ogc.org/" target="_top">OGC</a>) a para todos sus tipos. De esta forma, las aplicaciones pueden intercambiar datos entre ellas utilizando un formato de intercambio estandarizado. El formato WKT es legible por humanos, mientras que el formato WKB es más compacto y más eficiente que el formato WKT. El formato WKB se puede generar como una cadena binaria o como una cadena de caracteres codificada en ASCII hexadecimal.
		</p><p>
			Los tipos de conjunto representan un conjunto <span class="emphasis"><em>ordenado</em></span> de valores <span class="emphasis"><em>diferentes</em></span>. Un conjunto debe contener al menos un elemento. Ejemplos de valores de tipos de conjunto son como sigue:
		</p><pre class="programlisting">
SELECT tstzset '{2001-01-01 08:00:00, 2001-01-03 09:30:00}';
-- Conjunto unitario
SELECT textset '{"highway"}';
-- Conjunto erróneo: elementos desordenados
SELECT floatset '{3.5, 1.2}';
-- Conjunto erróneo: elementos duplicados
SELECT geomset '{"Point(1 1)", "Point(1 1)"}';
</pre><p>
			Nótese que los elementos de los conjuntos <code class="varname">textset</code>, <code class="varname">geomset</code>, <code class="varname">geogset</code> y <code class="varname">npointset</code> deben estar delimitados entre commillas dobles. Nótese también que las geometrías y las geografías utilizan el orden definido por PostGIS.
		</p><p>
			Un valor de un tipo de rango unitario tiene dos límites, el <span class="emphasis"><em>límite inferior</em></span> y el <span class="emphasis"><em>límite superior</em></span>, que son valores del <span class="emphasis"><em>tipo de base</em></span> subyacente. Por ejemplo, un valor del tipo <code class="varname">tstzspan</code> tiene dos límites, que son valores de <code class="varname">timestamptz</code>. Los límites pueden ser inclusivos o exclusivos. Un límite inclusivo significa que el instante límite está incluido en el rango, mientras que un límite exclusivo significa que el instante límite no está incluido en el rango. En el formato textual de un valor de un rango, los límites inferiores inclusivos y exclusivos están representados, respectivamente, por “<code class="varname">[</code>” y “<code class="varname">(</code>”. Asimismo, los límites superiores inclusivos y exclusivos se representan, respectivamente, por “<code class="varname">]</code>” y “<code class="varname">)</code>”. En un valor de un rango, el límite inferior debe ser menor o igual que el límite superior. Un valor de rango con límites iguales e inclusivos se llama <span class="emphasis"><em>rango instantáneo</em></span> y corresponde a un valor del tipo de base. Ejemplos de valores de rango son como sigue:
		</p><pre class="programlisting">
SELECT intspan '[1, 3)';
SELECT floatspan '[1.5, 3.5]';
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-03 09:30:00)';
-- Rangos instantáneos
SELECT intspan '[1, 1]';
SELECT floatspan '[1.5, 1.5]';
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:00:00]';
-- Rango erróneo: límites inválidos
SELECT tstzspan '[2001-01-01 08:10:00, 2001-01-01 08:00:00]';
-- Rango erróneo: rango vacío
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:00:00)';
	</pre><p>
			Los valores de <code class="varname">intspan</code>, <code class="varname">bigintspan</code> y <code class="varname">datespan</code> son convertidos en <span class="emphasis"><em>forma normal</em></span> para que los valores equivalentes tengan representaciones idénticas. En la representación canónica de estos tipos, el límite inferior es inclusivo y el límite superior es exclusivo, como se muestra en los siguientes ejemplos:
		</p><pre class="programlisting">
SELECT intspan '[1, 1]';
-- [1, 2)
SELECT bigintspan '(1, 3]';
--[2, 4)
SELECT datespan '[2001-01-01, 2001-01-03]';
-- [2001-01-01, 2001-01-04)
</pre><p>
			Un valor de un tipo de conjunto de rangos representa un conjunto <span class="emphasis"><em>ordenado</em></span> de valores de rango <span class="emphasis"><em>disjuntos</em></span>. Un valor de conjunto de rangos debe contener al menos un elemento, en cuyo caso corresponde a un único valor de rango. Ejemplos de valores conjunto de rangos son los siguientes:
		</p><pre class="programlisting">
SELECT floatspanset '{[8.1, 8.5],[9.2, 9.4]}';
-- Singleton spanset
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Erroneous spanset: unordered elements
SELECT intspanset '{[3,4],[1,2]}';
-- Erroneous spanset: overlapping elements
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:05:00, 2001-01-01 08:15:00]}';
</pre><p>
			Los valores de los tipos conjunto de rangos son convertidos en <span class="emphasis"><em>forma normal</em></span> de modo que los valores equivalentes tengan representaciones idénticas. Para ello, los valores de rango consecutivos que son adyacentes se fusionan cuando es posible. Ejemplos de transformación a forma normal son los siguientes:
		</p><pre class="programlisting">
SELECT intspanset '{[1,2],[3,4]}';
-- {[1, 5)}
SELECT floatspanset '{[1.5,2.5],(2.5,4.5]}';
-- {[1.5, 4.5]}
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00),
  [2001-01-01 08:10:00, 2001-01-01 08:10:00], (2001-01-01 08:10:00, 2001-01-01 08:20:00]}';
-- {[2001-01-01 08:00:00+00,2001-01-01 08:20:00+00]}
</pre><p>
			Damos a continuación las funciones de entrada y salida de tipos de conjunto y de rango en formato textual (Well-Known Text o WKT) y binario (Well-Known Binary o WKB). El formato de salida predeterminado de todos los tipos de conjuntos y de rango es el formato de texto conocido. La función <code class="varname">asText</code> que se da a continuación permite determinar la salida de valores de punto flotante.
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="setspan_asText"></a><a class="indexterm" name="idm658"></a><p>Devuelve la representación textual conocida (Well-Known Text o WKT)</p><p><code class="varname">asText({floatset,floatspans},maxdecdigits=15) → text</code></p><p>El argumento <code class="varname">maxdecdigits</code> se puede utilizar para definir el número máximo de decimales para la salida de los valores de coma flotante (por defecto 15).</p><pre class="programlisting">
SELECT asText(floatset '{1.123456789,2.123456789}', 3);
-- {1.123, 2.123}
SELECT asText(floatspanset '{[1.55,2.55],[4,5]}',0);
-- {[2, 3], [4, 5]}
</pre></li><li class="listitem"><a name="setspan_asBinary"></a><a class="indexterm" name="idm668"></a><p>Devuelve la representación binaria conocida (Well-Known Binary o WKB)</p><p><code class="varname">asBinary({set,spans},endian text='') → bytea</code></p><p>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</p><pre class="programlisting">
SELECT asBinary(dateset '{2001-01-01, 2001-01-03}');
-- \x01050001020000006e01000070010000
SELECT asBinary(intspan '[1, 3)');
-- \x011300010100000003000000
SELECT asBinary(floatspanset '{[1, 2], [4, 5]}', 'XDR');
-- \x00000e00000002033ff000000000000040000000000000000340100000000000004014000000000000
</pre></li><li class="listitem"><a name="setspan_asHexWKB"></a><a class="indexterm" name="idm677"></a><p>Devuelve la representación hexadecimal binaria conocida (HexWKB) en formato texto</p><p><code class="varname">asHexWKB({set,spans},endian text='') → text</code></p><p>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</p><pre class="programlisting">
SELECT asHexWKB(dateset '{2001-01-01, 2001-01-03}');
-- 01050001020000006E01000070010000
SELECT asHexWKB(intspan '[1, 3)');
-- 011300010100000003000000
SELECT asHexWKB(floatspanset '{[1, 2], [4, 5]}', 'XDR');
-- 00000E00000002033FF000000000000040000000000000000340100000000000004014000000000000
</pre></li><li class="listitem"><a name="setspan_FromBinary"></a><a class="indexterm" name="idm686"></a><a class="indexterm" name="idm689"></a><a class="indexterm" name="idm692"></a><p>Devuelve a partir de la representación binaria conocida (WKB)</p><p><code class="varname">settypeFromBinary(bytea) → set</code></p><p><code class="varname">spantypeFromBinary(bytea) → span</code></p><p><code class="varname">spansettypeFromBinary(bytea) → spanset</code></p><p>Hay una función por tipo de conjunto o de rango, el nombre de la función tiene como prefijo el nombre del tipo.</p><pre class="programlisting">
SELECT datesetFromBinary('\x01050001020000006e01000070010000');
-- {2001-01-01, 2001-01-03}
SELECT intspanFromBinary('\x011300010100000003000000');
-- [1, 3)
SELECT floatspansetFromBinary(
  '\x00000e00000002033ff000000000000040000000000000000340100000000000004014000000000000');
-- {[1, 2], [4, 5]}
</pre></li><li class="listitem"><a name="setspan_FromHexWKB"></a><a class="indexterm" name="idm705"></a><a class="indexterm" name="idm708"></a><a class="indexterm" name="idm711"></a><p>Devuelve a partir de la representación hexadecimal binaria conocida (HexWKB)</p><p><code class="varname">settypeFromHexWKB(text) → set</code></p><p><code class="varname">spantypeFromHexWKB(text) → span</code></p><p><code class="varname">spansettypeFromHexWKB(text) → spanset</code></p><p>Hay una función por tipo de conjunto o de rango, el nombre de la función tiene como prefijo el nombre del tipo.</p><pre class="programlisting">
SELECT datesetFromHexWKB('01050001020000006E01000070010000');
-- {2001-01-01, 2001-01-03}
SELECT intspanFromHexWKB('011300010100000003000000');
-- [1, 3)
SELECT floatspansetFromHexWKB(
  '00000E00000002033FF000000000000040000000000000000340100000000000004014000000000000');
-- {[1, 2], [4, 5]}
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s08.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch02s02.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Migración de la versión 1.0 a la versión 1.1 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Constructores</td></tr></table></div></body></html>
