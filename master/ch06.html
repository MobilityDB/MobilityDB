<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 6. Temporal Types: Generic Operations (Part 2)</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.3 User's Manual"><link rel="up" href="index.html" title="MobilityDB 1.3 User's Manual"><link rel="prev" href="ch05s06.html" title="Transformations"><link rel="next" href="ch06s02.html" title="Restrictions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 6. Temporal Types: Generic Operations (Part 2)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s06.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch06s02.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="temporal_types_ops_p2"></a>Chapter 6. Temporal Types: Generic Operations (Part 2)</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch06.html#temporal_types_modifications">Modifications</a></span></dt><dt><span class="sect1"><a href="ch06s02.html">Restrictions</a></span></dt><dt><span class="sect1"><a href="ch06s03.html">Comparisons</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch06s03.html#id1343">Traditional Comparisons</a></span></dt><dt><span class="sect2"><a href="ch06s03.html#ever_always_comparison">Ever and Always Comparisons</a></span></dt><dt><span class="sect2"><a href="ch06s03.html#id1344">Temporal Comparisons</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch06s04.html">Bounding Box Operators</a></span></dt><dt><span class="sect1"><a href="ch06s05.html">Miscellaneous</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="temporal_types_modifications"></a>Modifications</h2></div></div></div><p>We explain next the semantics of the modification operations (that is, <code class="varname">insert</code>, <code class="varname">update</code>, and <code class="varname">delete</code>) for temporal types. These operations have similar semantics as the corresponding operations for application-time temporal tables introduced in the <a class="ulink" href="https://en.wikipedia.org/wiki/SQL:2011" target="_top">SQL:2011</a> standard. The main difference is that SQL uses <span class="emphasis"><em>tuple timestamping</em></span> (where timestamps are attached to tuples), while temporal values in MobilityDB use <span class="emphasis"><em>attribute timestamping</em></span> (where timestamps are attached to attribute values).</p><p>The <code class="varname">insert</code> operation adds to a temporal value the instants of another one without modifying the existing instants, as illustrated in <a class="xref" href="ch06.html#insert_fig" title="Figure 6.1. Insert operation for temporal values.">Figure 6.1, “Insert operation for temporal values.”</a>.</p><div class="figure-float"><div class="figure"><a name="insert_fig"></a><p class="title"><b>Figure 6.1. Insert operation for temporal values.</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="images/insert.svg"></object></div></div></div><br class="figure-break"></div><p>As shown in the figure, the temporal values may only intersect at their boundary, and in that case, they must have the same base value at their common timestamps, otherwise an error is raised. The result of the operation is the union of the instants for both temporal values, as shown in the first result of the figure. This is equivalent to a <code class="varname">merge</code> operation explained below. Alternatively, as shown in the second result of the figure, the inserted fragments that are disjoint with the original value are connected to the last instant before and the first instant after the fragment. A Boolean parameter <code class="varname">connect</code> is used to choose between the two results, and the parameter is set to true by default. Notice that this only applies to continuous temporal values.</p><p>The <code class="varname">update</code> operation replaces the instants in the first temporal value with those of the second one as illustrated in <a class="xref" href="ch06.html#update_delete_fig" title="Figure 6.2. Update and delete operation for temporal values.">Figure 6.2, “Update and delete operation for temporal values.”</a>.</p><div class="figure-float"><div class="figure"><a name="update_delete_fig"></a><p class="title"><b>Figure 6.2. Update and delete operation for temporal values.</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="images/update_delete.svg"></object></div></div></div><br class="figure-break"></div><p>As in the case of an <code class="varname">insert</code> operation, an additional Boolean parameter determines whether the replaced disconnected fragments are connected in the resulting value, as shown in the two possible results in the figure. When the two temporal values are either disjoint or only overlap at their boundary, this corresponds to an <code class="varname">insert</code> operation as explained above. In this case, the <code class="varname">update</code> operation behaves as an <code class="varname">upsert</code> operation in SQL.</p><p>The <code class="varname">deleteTime</code> operation removes the instants of a temporal value that intersect a time value. This operation can be used in two different situations, illustrated in <a class="xref" href="ch06.html#update_delete_fig" title="Figure 6.2. Update and delete operation for temporal values.">Figure 6.2, “Update and delete operation for temporal values.”</a>.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In the first case, shown as the top result in the figure, the meaning of operation is to introduce time gaps after removing the instants of the temporal value intersecting the time value. This is equivalent to the restriction operations (<a class="xref" href="ch06s02.html" title="Restrictions">the section called “Restrictions”</a>), which restrict a temporal value to the complement of the time value.</p></li><li class="listitem"><p>The second case, shown as the bottom result in the figure, is used for removing erroneous values (e.g., detected as outliers) without introducing a time gap, or for removing time gaps. In this case, the instants of the temporal value are deleted and the last instant before and the first instant after a removed fragment are connected. This behaviour is specified by setting an additional Boolean parameter of the operation. Notice that this only applies to continuous temporal values.</p></li></ol></div><div class="figure-float"><div class="figure"><a name="modif_sql_fig"></a><p class="title"><b>Figure 6.3. Modification operations for temporal tables in SQL</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="images/modif_sql.svg"></object></div></div></div><br class="figure-break"></div><p>
			<a class="xref" href="ch06.html#modif_sql_fig" title="Figure 6.3. Modification operations for temporal tables in SQL">Figure 6.3, “Modification operations for temporal tables in SQL”</a> shows the equivalent modification operations for temporal tables in the SQL standard. Intuitively, these figures are obtained by rotating 90 degrees clockwise the corresponding figures for temporal values (<a class="xref" href="ch06.html#insert_fig" title="Figure 6.1. Insert operation for temporal values.">Figure 6.1, “Insert operation for temporal values.”</a> and <a class="xref" href="ch06.html#update_delete_fig" title="Figure 6.2. Update and delete operation for temporal values.">Figure 6.2, “Update and delete operation for temporal values.”</a>). This follows from the fact that in SQL consecutive tuples ordered by time are typically connected through the <code class="varname">LEAD</code> and <code class="varname">LAG</code> window functions.
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="insert"></a>Insert a temporal value into another one</p><p><code class="varname">insert(ttype,ttype,connect=true) → ttype</code></p><pre class="programlisting">
SELECT insert(tint '{1@2001-01-01, 3@2001-01-03, 5@2001-01-05}',
  tint '{3@2001-01-03, 7@2001-01-07}');
-- {1@2001-01-01, 3@2001-01-03, 5@2001-01-05, 7@2001-01-07}
SELECT insert(tint '{1@2001-01-01, 3@2001-01-03, 5@2001-01-05}',
  tint '{5@2001-01-03, 7@2001-01-07}');
-- ERROR: The temporal values have different value at their overlapping instant 2001-01-03
SELECT insert(tfloat '[1@2001-01-01, 2@2001-01-02]',
  tfloat '[1@2001-01-03, 1@2001-01-05]');
-- [1@2001-01-01, 2@2001-01-02, 1@2001-01-03, 1@2001-01-05]
SELECT insert(tfloat '[1@2001-01-01, 2@2001-01-02]',
  tfloat '[1@2001-01-03, 1@2001-01-05]', false);
-- {[1@2001-01-01, 2@2001-01-02], [1@2001-01-03, 1@2001-01-05]}
SELECT asText(insert(tgeompoint '{[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02],
  [Point(3 3 3)@2001-01-04],[Point(1 1 1)@2001-01-05]}',
  tgeompoint 'Point(1 1 1)@2001-01-03'));
/* {[POINT Z (1 1 1)@2001-01-01, POINT Z (2 2 2)@2001-01-02, POINT Z (1 1 1)@2001-01-03,
 POINT Z (3 3 3)@2001-01-04], [POINT Z (1 1 1)@2001-01-05]} */
</pre></li><li class="listitem"><p><a name="update"></a>Update a temporal value with another one</p><p><code class="varname">update(ttype,ttype,connect=true) → ttype</code></p><pre class="programlisting">
SELECT update(tint '{1@2001-01-01, 3@2001-01-03, 5@2001-01-05}',
  tint '{5@2001-01-03, 7@2001-01-07}');
-- {1@2001-01-01, 5@2001-01-03, 5@2001-01-05, 7@2001-01-07}
SELECT update(tfloat '[1@2001-01-01, 1@2001-01-05]',
  tfloat '[1@2001-01-02, 3@2001-01-03, 1@2001-01-04]');
-- {[1@2001-01-01, 1@2001-01-02, 3@2001-01-03, 1@2001-01-04, 1@2001-01-05]}
SELECT asText(update(tgeompoint '{[Point(1 1 1)@2001-01-01, Point(3 3 3)@2001-01-03,
  Point(1 1 1)@2001-01-05], [Point(1 1 1)@2001-01-07]}',
  tgeompoint '[Point(2 2 2)@2001-01-02, Point(2 2 2)@2001-01-04]'));
/*  {[POINT Z (1 1 1)@2001-01-01, POINT Z (2 2 2)@2001-01-02, POINT Z (2 2 2)@2001-01-04,
  POINT Z (1 1 1)@2001-01-05], [POINT Z (1 1 1)@2001-01-07]} */
</pre></li><li class="listitem"><p><a name="deleteTime"></a>Delete the instants of a temporal value that intersect a time value</p><p><code class="varname">deleteTime(ttype,time,connect=true) → ttype</code></p><pre class="programlisting">
SELECT deleteTime(tint '[1@2001-01-01, 1@2001-01-03]', timestamptz '2001-01-02', false);
-- {[1@2001-01-01, 1@2001-01-02), (1@2001-01-02, 1@2001-01-03]}
SELECT deleteTime(tint '[1@2001-01-01, 1@2001-01-03]', timestamptz '2001-01-02');
-- [1@2001-01-01, 1@2001-01-03]
SELECT deleteTime(tfloat '[1@2001-01-01, 4@2001-01-02, 2@2001-01-04, 5@2001-01-05]',
  tstzspan '[2001-01-02, 2001-01-04]');
-- [1@2001-01-01, 5@2001-01-05]
SELECT asText(deleteTime(tgeompoint '{[Point(1 1 1)@2001-01-01,
  Point(2 2 2)@2001-01-02], [Point(3 3 3)@2001-01-04, Point(3 3 3)@2001-01-05]}',
  tstzspan '[2001-01-02, 2001-01-04]'));
/* {[POINT Z (1 1 1)@2001-01-01, POINT Z (2 2 2)@2001-01-02, POINT Z (3 3 3)@2001-01-04,
  POINT Z (3 3 3)@2001-01-05]} */
</pre></li><li class="listitem"><a name="appendInstant"></a><a class="indexterm" name="id4733"></a><p>Append a temporal instant to a temporal value</p><p><code class="varname">appendInstant(ttype,ttypeInst,interp=NULL) → ttype</code></p><p><code class="varname">appendInstant(ttypeInst,interp=NULL,maxdist=NULL,maxt=NULL) → ttypeSeq</code></p><p>The first version of the function returns the result of appending the second argument to the first one. If either input is NULL, then NULL is returned.</p><p>The second version of the function above is an <span class="emphasis"><em>aggregate</em></span> function that returns the result of successively appending a set of rows of temporal values. This means that it operates in the same way the <code class="varname">SUM()</code> and <code class="varname">AVG()</code> functions do and like most aggregates, it also ignores NULL values. Two optional arguments state a maximum distance and a maximum time interval such that a gap is introduced whenever two consecutive instants have a distance or a time gap greater than these values. For temporal points the distance is specified in units of the coordinate system. If one of the arguments are not given, it is not taken into account for determining the gaps.</p><pre class="programlisting">
SELECT appendInstant(tint '1@2001-01-01', tint '1@2001-01-02');
-- [1@2001-01-01, 1@2001-01-02]
SELECT appendInstant(tint '1@2001-01-01', tint '1@2001-01-02', 'discrete');
-- {1@2001-01-01, 1@2001-01-02}
SELECT appendInstant(tint '[1@2001-01-01]', tint '1@2001-01-02');
-- [1@2001-01-01, 1@2001-01-02]
SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2001-01-01,
  Point(2 2 2)@2001-01-02], [Point(3 3 3)@2001-01-04, Point(3 3 3)@2001-01-05]}',
  tgeompoint 'Point(1 1 1)@2001-01-06'));
/* {[POINT Z (1 1 1)@2001-01-01, POINT Z (2 2 2)@2001-01-02],
   [POINT Z (3 3 3)@2001-01-04, POINT Z (3 3 3)@2001-01-05,
   POINT Z (1 1 1)@2001-01-06]} */
</pre><pre class="programlisting">
WITH temp(inst) AS (
  SELECT tfloat '1@2001-01-01' UNION SELECT tfloat '2@2001-01-02' UNION
  SELECT tfloat '3@2001-01-03' UNION SELECT tfloat '4@2001-01-04' UNION
  SELECT tfloat '5@2001-01-05' )
SELECT appendInstant(inst ORDER BY inst) FROM temp;
-- [1@2001-01-01, 5@2001-01-05]
WITH temp(inst) AS (
  SELECT tfloat '1@2001-01-01' UNION SELECT tfloat '2@2001-01-02' UNION
  SELECT tfloat '3@2001-01-03' UNION SELECT tfloat '4@2001-01-04' UNION
  SELECT tfloat '5@2001-01-05' )
SELECT appendInstant(inst, 'discrete' ORDER BY inst) FROM temp;
-- {1@2001-01-01, 2@2001-01-02, 3@2001-01-03, 4@2001-01-04, 5@2001-01-05}
WITH temp(inst) AS (
  SELECT tgeogpoint 'Point(1 1)@2001-01-01' UNION
  SELECT tgeogpoint 'Point(2 2)@2001-01-02' UNION
  SELECT tgeogpoint 'Point(3 3)@2001-01-03' UNION
  SELECT tgeogpoint 'Point(4 4)@2001-01-04' UNION
  SELECT tgeogpoint 'Point(5 5)@2001-01-05' )
SELECT asText(appendInstant(inst ORDER BY inst)) FROM temp;
/* [POINT(1 1)@2001-01-01, POINT(2 2)@2001-01-02, POINT(3 3)@2001-01-03,
   POINT(4 4)@2001-01-04, POINT(5 5)@2001-01-05] */
</pre><p>Notice that in the first query above with <code class="varname">tfloat</code>, the intermediate observations were removed by the normalization process since they were redundant due to linear interpolation. This is not the case for the second query with discrete interpolation or the third query with <code class="varname">tgeogpoint</code>, where geodetic coordinates are used.</p><pre class="programlisting">
WITH temp(inst) AS (
  SELECT tfloat '1@2001-01-01' UNION SELECT tfloat '2@2001-01-02' UNION
  SELECT tfloat '4@2001-01-04' UNION SELECT tfloat '5@2001-01-05' UNION
  SELECT tfloat '7@2001-01-07' )
SELECT appendInstant(inst, NULL, 0.0, '1 day' ORDER BY inst) FROM temp;
-- {[1@2001-01-01, 2@2001-01-02], [4@2001-01-04, 5@2001-01-05], [7@2001-01-07]}
WITH temp(inst) AS (
  SELECT tgeompoint 'Point(1 1)@2001-01-01' UNION
  SELECT tgeompoint 'Point(2 2)@2001-01-02' UNION
  SELECT tgeompoint 'Point(4 4)@2001-01-04' UNION
  SELECT tgeompoint 'Point(5 5)@2001-01-05' UNION
  SELECT tgeompoint 'Point(7 7)@2001-01-07' )
SELECT asText(appendInstant(inst, NULL, sqrt(2), '1 day' ORDER BY inst)) FROM temp;
/* {[POINT(1 1)@2001-01-01, POINT(2 2)@2001-01-02],
   [POINT(4 4)@2001-01-04, POINT(5 5)@2001-01-05], [POINT(7 7)@2001-01-07]} */
</pre></li><li class="listitem"><a name="appendSequence"></a><a class="indexterm" name="id4753"></a><p>Append a temporal sequence to a temporal value</p><p><code class="varname">appendSequence(ttype,ttypeSeq) → {ttypeSeq,ttypeSeqSet}</code></p><p><code class="varname">appendSequence(ttypeSeq) → {ttypeSeq,ttypeSeqSet}</code></p><p>The first version of the function returns the result of appending the second argument to the first one. If either input is NULL, then NULL is returned.</p><p>The second version of the function above is an <span class="emphasis"><em>aggregate</em></span> function that returns the result of successively appending a set of rows of temporal values. This means that it operates in the same way the <code class="varname">SUM()</code> and <code class="varname">AVG()</code> functions do and like most aggregates, it also ignores NULL values.</p><pre class="programlisting">
SELECT appendSequence(tint '1@2001-01-01', tint '{2@2001-01-02, 3@2001-01-03}');
-- {1@2001-01-01, 2@2001-01-02, 3@2001-01-03}
SELECT appendSequence(tint '[1@2001-01-01, 2@2001-01-02]',
  tint '[2@2001-01-02, 3@2001-01-03]');
-- [1@2001-01-01, 2@2001-01-02, 3@2001-01-03]
SELECT asText(appendSequence(tgeompoint '{[Point(1 1 1)@2001-01-01,
  Point(2 2 2)@2001-01-02], [Point(3 3 3)@2001-01-04, Point(3 3 3)@2001-01-05]}',
  tgeompoint '[Point(3 3 3)@2001-01-05, Point(1 1 1)@2001-01-06]'));
/* {[POINT Z (1 1 1)@2001-01-01, POINT Z (2 2 2)@2001-01-02],
   [POINT Z (3 3 3)@2001-01-04, POINT Z (3 3 3)@2001-01-05,
   POINT Z (1 1 1)@2001-01-06]} */
</pre></li><li class="listitem"><a name="merge"></a><a class="indexterm" name="id4768"></a><p>Merge the temporal values</p><p><code class="varname">merge(ttype,ttype) → ttype</code></p><p><code class="varname">merge(ttype[]) → ttype</code></p><p><code class="varname">merge(ttype) → ttype</code></p><p>The temporal values may only intersect at their boundary and in that case, their base values at the common timestamps must be the same, otherwise an error is raised.</p><p>The third version of the function above is an <span class="emphasis"><em>aggregate</em></span> function that returns the result of successively appending a set of rows of temporal values. This means that it operates in the same way the <code class="varname">SUM()</code> and <code class="varname">AVG()</code> functions do and like most aggregates, it also ignores NULL values.</p><pre class="programlisting">
SELECT merge(tint '1@2001-01-01', tint '1@2001-01-02');
-- {1@2001-01-01, 1@2001-01-02}
SELECT merge(tint '[1@2001-01-01, 2@2001-01-02]', tint '[2@2001-01-02, 1@2001-01-03]');
-- [1@2001-01-01, 2@2001-01-02, 1@2001-01-03]
SELECT merge(tint '[1@2001-01-01, 2@2001-01-02]', tint '[3@2001-01-03, 1@2001-01-04]');
-- {[1@2001-01-01, 2@2001-01-02], [3@2001-01-03, 1@2001-01-04]}
SELECT merge(tint '[1@2001-01-01, 2@2001-01-02]', tint '[1@2001-01-02, 2@2001-01-03]');
-- ERROR:  The temporal values have different value at their common timestamp 2001-01-02
SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2001-01-01,
  Point(2 2 2)@2001-01-02], [Point(3 3 3)@2001-01-04, Point(3 3 3)@2001-01-05]}',
  tgeompoint '{[Point(3 3 3)@2001-01-05, Point(1 1 1)@2001-01-06]}'));
/* {[POINT Z (1 1 1)@2001-01-01, POINT Z (2 2 2)@2001-01-02],
   [POINT Z (3 3 3)@2001-01-04, POINT Z (3 3 3)@2001-01-05,
   POINT Z (1 1 1)@2001-01-06]} */
</pre><pre class="programlisting">
SELECT merge(ARRAY[tint '1@2001-01-01', '1@2001-01-02']);
-- {1@2001-01-01, 1@2001-01-02}
SELECT merge(ARRAY[tint '{1@2001-01-01, 2@2001-01-02}', '{2@2001-01-02, 3@2001-01-03}']);
-- {1@2001-01-01, 2@2001-01-02, 3@2001-01-03}
SELECT merge(ARRAY[tint '{1@2001-01-01, 2@2001-01-02}', '{3@2001-01-03, 4@2001-01-04}']);
-- {1@2001-01-01, 2@2001-01-02, 3@2001-01-03, 4@2001-01-04}
SELECT merge(ARRAY[tint '[1@2001-01-01, 2@2001-01-02]', '[2@2001-01-02, 1@2001-01-03]']);
-- [1@2001-01-01, 2@2001-01-02, 1@2001-01-03]
SELECT merge(ARRAY[tint '[1@2001-01-01, 2@2001-01-02]', '[3@2001-01-03, 4@2001-01-04]']);
-- {[1@2001-01-01, 2@2001-01-02], [3@2001-01-03, 4@2001-01-04]}
SELECT asText(merge(ARRAY[tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02],
  [Point(3 3)@2001-01-03, Point(4 4)@2001-01-04]}', '{[Point(4 4)@2001-01-04,
  Point(3 3)@2001-01-05], [Point(6 6)@2001-01-06, Point(7 7)@2001-01-07]}']));
/* {[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02], [Point(3 3)@2001-01-03,
   Point(4 4)@2001-01-04, Point(3 3)@2001-01-05],
   [Point(6 6)@2001-01-06, Point(7 7)@2001-01-07]} */
SELECT asText(merge(ARRAY[tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02]}',
  '{[Point(2 2)@2001-01-02, Point(1 1)@2001-01-03]}']));
-- [Point(1 1)@2001-01-01, Point(2 2)@2001-01-02, Point(1 1)@2001-01-03]
</pre><pre class="programlisting">
WITH temp(inst) AS (
SELECT tfloat '1@2001-01-01' UNION SELECT tfloat '2@2001-01-02' UNION
SELECT tfloat '3@2001-01-03' UNION SELECT tfloat '4@2001-01-04' UNION
SELECT tfloat '5@2001-01-05' )
SELECT merge(inst) FROM temp;
-- {1@2001-01-01, 2@2001-01-02, 3@2001-01-03, 4@2001-01-04, 5@2001-01-05}
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s06.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch06s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Transformations </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Restrictions</td></tr></table></div></body></html>
