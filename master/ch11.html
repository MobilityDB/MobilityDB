<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 11. Temporal Network Points</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.3 User's Manual"><link rel="up" href="index.html" title="MobilityDB 1.3 User's Manual"><link rel="prev" href="ch10s03.html" title="Statistics and Selectivity"><link rel="next" href="ch11s02.html" title="Temporal Network Points"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 11. Temporal Network Points</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch10s03.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch11s02.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="temporal_network_points"></a>Chapter 11. Temporal Network Points</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch11.html#static_network_types">Static Network Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch11.html#constructor_functions">Constructors</a></span></dt><dt><span class="sect2"><a href="ch11.html#idm6436">Transformations</a></span></dt><dt><span class="sect2"><a href="ch11.html#accessor_functions">Accessors</a></span></dt><dt><span class="sect2"><a href="ch11.html#spatial_functions">Spatial Operations</a></span></dt><dt><span class="sect2"><a href="ch11.html#static_operators">Comparisons</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch11s02.html">Temporal Network Points</a></span></dt><dt><span class="sect1"><a href="ch11s03.html">Validity of Temporal Network Points</a></span></dt><dt><span class="sect1"><a href="ch11s04.html">Constructors</a></span></dt><dt><span class="sect1"><a href="ch11s05.html">Conversions</a></span></dt><dt><span class="sect1"><a href="ch11s06.html">Operations</a></span></dt><dt><span class="sect1"><a href="ch11s07.html">Aggregations</a></span></dt><dt><span class="sect1"><a href="ch11s08.html">Indexing</a></span></dt></dl></div><p>The temporal points that we have considered so far represent the movement of objects that can move freely on space since it is assumed that they can change their position from one location to the next one without any motion restriction. This is the case for animals and for flying objects such as planes or drones. However, in many cases, objects do not move freely in space but rather within spatially embedded networks such as routes or railways. In this case, it is necessary to take the embedded networks into account while describing the movements of these moving objects. Temporal network points account for these requirements.</p><p>Compared with the free-space temporal points, network-based points have the following advantages:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Network points provide road constraints that reflect the real movements of moving objects.</p></li><li class="listitem"><p>The geometric information is not stored with the moving point, but once and for all in the fixed networks. In this way, the location representations and interpolations are more precise.</p></li><li class="listitem"><p>Network points are more efficient in terms of data storage, location update, formulation of query, as well as indexing. These are discussed later in this document.</p></li></ul></div><p>Temporal network points are based on <a class="ulink" href="https://pgrouting.org/" target="_top">pgRouting</a>, a PostgreSQL extension for developing network routing applications and doing graph analysis. Therefore, temporal network points asume that the underlying network is defined in a table named <code class="varname">ways</code>, which has at least three columns: <code class="varname">gid</code> containing the unique route identifier, <code class="varname">length</code> containing the route length, and <code class="varname">the_geom</code> containing the route geometry.</p><p>There are two static network types, <code class="varname">npoint</code> (short for network point) and <code class="varname">nsegment</code> (short for network segment), which represent, respectively, a point and a segment of a route. An <code class="varname">npoint</code> value is composed of a route identifier and a float number in the range [0,1] determining a relative position of the route, where 0 corresponds to the begining of the route and 1 to the end of the route. An <code class="varname">nsegment</code> value is composed of a route identifier and two float numbers in the range [0,1] determining the start and end relative positions. A <code class="varname">nsegment</code> value whose start and end positions are equal corresponds to an <code class="varname">npoint</code> value.</p><p>The <code class="varname">npoint</code> type serves as base type for defining the temporal network point type <code class="varname">tnpoint</code>. The <code class="varname">tnpoint</code> type has similar functionality as the temporal point type <code class="varname">tgeompoint</code> with the exception that it only considers two dimensions. Thus, all functions and operators described before for the <code class="varname">tgeompoint</code> type are also applicable for the <code class="varname">tnpoint</code> type. In addition, there are specific functions defined for the <code class="varname">tnpoint</code> type.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static_network_types"></a>Static Network Types</h2></div></div></div><p>An <code class="varname">npoint</code> value is a couple of the form <code class="varname">(rid,position)</code> where <code class="varname">rid</code> is a <code class="varname">bigint</code> value representing a route identifier and <code class="varname">position</code> is a <code class="varname">float</code> value in the range [0,1] indicating its relative position. The values 0 and 1 of <code class="varname">position</code> denote, respectively, the starting and the ending position of the route. The road distance between an <code class="varname">npoint</code> value and the starting position of route with identifier <code class="varname">rid</code> is computed by multiplying <code class="varname">position</code> by length, where <code class="varname">length</code> is the route length. Examples of input of network point values are as follows:</p><pre class="programlisting">
SELECT npoint 'Npoint(76, 0.3)';
SELECT npoint 'Npoint(64, 1.0)';
</pre><p>The constructor function for network points has one argument for the route identifier and one argument for the relative position. An example of a network point value defined with the constructor function is as follows:</p><pre class="programlisting">
SELECT npoint(76, 0.3);
</pre><p>An <code class="varname">nsegment</code> value is a triple of the form <code class="varname">(rid,startPosition,endPosition)</code> where <code class="varname">rid</code> is a <code class="varname">bigint</code> value representing a route identifier and <code class="varname">startPosition</code> and <code class="varname">endPosition</code> are <code class="varname">float</code> values in the range [0,1] such that <code class="varname">startPosition ≤ endPosition</code>. Semantically, a network segment represents a set of network points <code class="varname">(rid,position)</code> with <code class="varname">startPosition ≤ position ≤ endPosition</code>. If <code class="varname">startPosition=0</code> and <code class="varname">endPosition=1</code>, the network segment is equivalent to the entire route. If <code class="varname">startPosition=endPosition</code>, the network segment represents into a single network point. Examples of input of network point values are as follows:</p><pre class="programlisting">
SELECT nsegment 'Nsegment(76, 0.3, 0.5)';
SELECT nsegment 'Nsegment(64, 0.5, 0.5)';
SELECT nsegment 'Nsegment(64, 0.0, 1.0)';
SELECT nsegment 'Nsegment(64, 1.0, 0.0)';
-- converted to nsegment 'Nsegment(64, 0.0, 1.0)';
</pre><p>As can be seen in the last example, the <code class="varname">startPosition</code> and <code class="varname">endPosition</code> values will be inverted to ensure that the condition <code class="varname">startPosition ≤ endPosition</code> is always satisfied. The constructor function for network segments has one argument for the route identifier and two optional arguments for the start and end positions. Examples of network segment values defined with the constructor function are as follows:</p><pre class="programlisting">
SELECT nsegment(76, 0.3, 0.3);
SELECT nsegment(76); -- start and end position assumed to be 0 and 1 respectively
SELECT nsegment(76, 0.5); -- end position assumed to be 1
</pre><p>Values of the <code class="varname">npoint</code> type can be converted to the <code class="varname">nsegment</code> type using an explicit <code class="varname">CAST</code> or using the <code class="varname">::</code> notation as shown next.</p><pre class="programlisting">
SELECT npoint(76, 0.33)::nsegment;
</pre><p>Values of static network types must satisfy several constraints so that they are well defined. These constraints are given next.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The route identifier <code class="varname">rid</code> must be found in column <code class="varname">gid</code> of table <code class="varname">ways</code>.</p></li><li class="listitem"><p>The <code class="varname">position</code>, <code class="varname">startPosition</code>, and <code class="varname">endPosition</code> values must be in the range [0,1]. An error is raised whenever one of these constraints are not satisfied.</p></li></ul></div><p>Examples of incorrect static network type values are as follows.</p><pre class="programlisting">
-- incorrect rid value
SELECT npoint 'Npoint(87.5, 1.0)';
-- incorrect position value
SELECT npoint 'Npoint(87, 2.0)';
-- rid value not found in the ways table
SELECT npoint 'Npoint(99999999, 1.0)';
</pre><p>We give next the functions and operators for the static network types.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="constructor_functions"></a>Constructors</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint"></a><a class="indexterm" name="idm6421"></a><p>Constructor for network points</p><p><code class="varname">npoint(bigint,double precision) → npoint</code></p><pre class="programlisting">
SELECT npoint(76, 0.3);
</pre></li><li class="listitem"><a name="nsegment"></a><a class="indexterm" name="idm6429"></a><p>Constructor for network segments</p><p><code class="varname">nsegment(bigint,double precision,double precision) → nsegment</code></p><pre class="programlisting">
SELECT nsegment(76, 0.3, 0.5);
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm6436"></a>Transformations</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_round"></a><a class="indexterm" name="idm6440"></a><p>Round the position(s) of the network point or the network segment to the number of decimal places</p><p><code class="varname">round({npoint,nsegment},integer=0) → {npoint,nsegment}</code></p><pre class="programlisting">
SELECT round(npoint(76, 0.123456789), 6);
--  NPoint(76,0.123457)
SELECT round(nsegment(76, 0.123456789, 0.223456789), 6);
--  NSegment(76,0.123457,0.223457)
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="accessor_functions"></a>Accessors</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="route"></a><a class="indexterm" name="idm6451"></a><p>Return the route identifier</p><p><code class="varname">route({npoint,nsegment}) → bigint</code></p><pre class="programlisting">
SELECT route(npoint 'Npoint(63, 0.3)');
-- 63
SELECT route(nsegment 'Nsegment(76, 0.3, 0.3)');
-- 76
</pre></li><li class="listitem"><a name="getPosition"></a><a class="indexterm" name="idm6459"></a><p>Return the position</p><p><code class="varname">getPosition(npoint) → float</code></p><pre class="programlisting">
SELECT getPosition(npoint 'Npoint(63, 0.3)');
-- 0.3
</pre></li><li class="listitem"><a name="startPosition"></a><a class="indexterm" name="idm6467"></a><a class="indexterm" name="idm6470"></a><p>Return the start/end position</p><p><code class="varname">startPosition(nsegment) → float</code></p><p><code class="varname">endPosition(nsegment) → float</code></p><pre class="programlisting">
SELECT startPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.3
SELECT endPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.5
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="spatial_functions"></a>Spatial Operations</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_srid"></a><a class="indexterm" name="idm6483"></a><p>Return the spatial reference identifier</p><p><code class="varname">srid({npoint,nsegment}) → integer</code></p><pre class="programlisting">
SELECT SRID(npoint 'Npoint(76, 0.3)');
-- 5676
SELECT SRID(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 5676
</pre></li></ul></div><p>Values of the <code class="varname">npoint</code> and <code class="varname">nsegment</code> types can be converted to the <code class="varname">geometry</code> type using an explicit <code class="varname">CAST</code> or using the <code class="varname">::</code> notation as shown next.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_geometry"></a><a class="indexterm" name="idm6498"></a><p>Convert a network point to a geometry</p><p><code class="varname">{npoint,nsegment}::geometry</code></p><pre class="programlisting">
SELECT ST_AsText(npoint(76, 0.33)::geometry);
-- POINT(21.6338731332283 50.0545869554067)
SELECT ST_AsText(nsegment(76, 0.33, 0.66)::geometry);
-- LINESTRING(21.6338731332283 50.0545869554067,30.7475989651999 53.9185062927473)
SELECT ST_AsText(nsegment(76, 0.33, 0.33)::geometry);
-- POINT(21.6338731332283 50.0545869554067)
</pre></li></ul></div><p>Similarly, <code class="varname">geometry</code> values of subtype <code class="varname">point</code> or <code class="varname">linestring</code> (restricted to two points) can be converted, respectively, to <code class="varname">npoint</code> and <code class="varname">nsegment</code> values using an explicit <code class="varname">CAST</code> or using the <code class="varname">::</code> notation. For this, the route that intersects the given points must be found, where a tolerance of 0.00001 units (depending on the coordinate system) is assumed so a point and a route that are close are considered to intersect. If no such route is found, a null value is returned.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="geometry_npoint"></a><a class="indexterm" name="idm6515"></a><p>Convert a geometry to a network point</p><p><code class="varname">geometry::{npoint,nsegment}</code></p><pre class="programlisting">
SELECT geometry 'SRID=5676;Point(279.269156511873 811.497076880187)'::npoint;
-- NPoint(3,0.781413)
SELECT geometry 'SRID=5676;LINESTRING(406.729536784738 702.58583437902,
  383.570801314823 845.137059419277)'::nsegment;
-- NSegment(3,0.6,0.9)
SELECT geometry 'SRID=5676;Point(279.3 811.5)'::npoint;
-- NULL
SELECT geometry 'SRID=5676;LINESTRING(406.7 702.6,383.6 845.1)'::nsegment;
-- NULL
</pre></li></ul></div><p>Two <code class="varname">npoint</code> values may be have different route identifiers but may represent the same spatial point at the intersection of the two routes. Function <code class="varname">equals</code> is used for testing spatial equality of network points.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="npoint_same"></a><a class="indexterm" name="idm6527"></a><p>Spatial equality for network points</p><p><code class="varname">equals(npoint, npoint)::Boolean</code></p><pre class="programlisting">
WITH inter(geom) AS (
  SELECT st_intersection(t1.the_geom, t2.the_geom)
  FROM ways t1, ways t2 WHERE t1.gid = 1 AND t2.gid = 2),
fractions(f1, f2) AS (
  SELECT ST_LineLocatePoint(t1.the_geom, i.geom), ST_LineLocatePoint(t2.the_geom, i.geom)
  FROM ways t1, ways t2, inter i WHERE t1.gid = 1 AND t2.gid = 2)
SELECT equals(npoint(1, f1), npoint(2, f2)) FROM fractions;
-- true
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="static_operators"></a>Comparisons</h3></div></div></div><p>The comparison operators (=, &lt;, and so on) for static network types require that the left and right arguments be of the same type. Excepted the equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on static network types.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="static_eq"></a><a class="indexterm" name="idm6539"></a><p>Are the values equal?</p><p><code class="varname">{npoint,nsegment} = {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(3, 0.5)' = npoint 'Npoint(3, 0.5)';
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' = nsegment 'Nsegment(3, 0.5, 0.6)';
-- false
</pre></li><li class="listitem"><a name="static_ne"></a><a class="indexterm" name="idm6547"></a><p>Are the values different?</p><p><code class="varname">{npoint,nsegment} &lt;&gt; {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(3, 0.5)' &lt;&gt; npoint 'Npoint(3, 0.6)';
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt;&gt; nsegment 'Nsegment(3, 0.5, 0.5)';
-- false
</pre></li><li class="listitem"><a name="static_lt"></a><a class="indexterm" name="idm6555"></a><p>Is the first value less than the second one?</p><p><code class="varname">{npoint,nsegment} &lt; {npoint,nsegment}</code></p><pre class="programlisting">
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt; nsegment 'Nsegment(3, 0.5, 0.6)';
-- true
</pre></li><li class="listitem"><a name="static_gt"></a><a class="indexterm" name="idm6563"></a><p>Is the first value greater than the second one?</p><p><code class="varname">{npoint,nsegment} &gt; {npoint,nsegment}</code></p><pre class="programlisting">
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &gt; nsegment 'Nsegment(2, 0.5, 0.5)';
-- true
</pre></li><li class="listitem"><a name="static_le"></a><a class="indexterm" name="idm6571"></a><p>Is the first value less than or equal to the second one?</p><p><code class="varname">{npoint,nsegment} &lt;= {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(1, 0.5)' &lt;= npoint 'Npoint(2, 0.5)';
-- true
</pre></li><li class="listitem"><a name="static_ge"></a><a class="indexterm" name="idm6579"></a><p>Is the first value greater than or equal to the second one?</p><p><code class="varname">{npoint,nsegment} &gt;= {npoint,nsegment}</code></p><pre class="programlisting">
SELECT npoint 'Npoint(1, 0.6)' &gt;= npoint 'Npoint(1, 0.5)';
-- true
</pre></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch10s03.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch11s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Statistics and Selectivity </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Temporal Network Points</td></tr></table></div></body></html>
