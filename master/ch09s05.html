<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Multidimensional Tiling</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.3 User's Manual"><link rel="up" href="ch09.html" title="Chapter 9. Temporal Types: Analytics Operations"><link rel="prev" href="ch09s04.html" title="Splitting Operations"><link rel="next" href="ch10.html" title="Chapter 10. Temporal Types: Aggregation and Indexing"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Multidimensional Tiling</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch09s04.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Temporal Types: Analytics Operations</th><td width="20%" align="right"> <a accesskey="n" href="ch10.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ttype_tiling"></a>Multidimensional Tiling</h2></div></div></div><p>
			Multidimensional tiling is the mechanism used to partition the domain of temporal values in bins or tiles of varying number of dimensions. In the case of a single dimension, the domain can be partitioned by value or by time using bins of the same size or duration, respectively. For temporal numbers, the domain can be partitioned in two-dimensional tiles of the same size for the value dimension and the same duration for the time dimension. For temporal points, the domain can be partitioned in space in two- or three-dimensional tiles, depending on the number of dimensions of the spatial coordinates. Finally, for temporal points, the domain can be partitioned in space and time using three- or four-dimensional tiles.
		</p><p>
			Multidimensional tiling can be used for various purposes. It can be used for computing multidimensional histograms, where the temporal values are aggregated according to the underlying partition of the domain. On the other hand, multidimensional tiling can also be used for indexing purposes, where the bounding box of a temporal value can be fragmented into multiple boxes in order to improve the efficiency of the index. Finally, multidimensional tiling can be used for fragmenting temporal values according to a multidimensional grid defined over the underlying domain. This enables the distribution of a dataset across a cluster of servers, where each server contains a partition of the dataset. The advantage of this partition mechanism is that it preserves proximitity in value/space and time, unlike the traditional hash-based partition mechanisms.
		</p><div class="figure-float"><div class="figure"><a name="tiling"></a><p class="title"><b>Figure 9.4. Multidimensional tiling for temporal floats.</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="images/tiling.svg" width="405"></object></div></div></div><br class="figure-break"></div><p>
			<a class="xref" href="ch09s05.html#tiling" title="Figure 9.4. Multidimensional tiling for temporal floats.">Figure 9.4, “Multidimensional tiling for temporal floats.”</a> illustrates multidimensional tiling for temporal floats. The two-dimensional domain is split into tiles having the same size for the value dimension and the same duration for the time dimension. Suppose that this tiling scheme is used for distribute a dataset across a cluster of six servers, as suggested by the gray pattern in the figure. In this case, the values are fragmented so each server will receive the data of contiguous tiles. This implies in particular that four nodes will receive one fragment of the temporal float depicted in the figure. One advantage of this distribution of data based on multidimensional tiling is that it reduces the data that needs to be exchanged between nodes when processing queries, a process typically referred to as <span class="emphasis"><em>reshuffling</em></span>.
		</p><p>Many of the functions in this section are <span class="emphasis"><em>set-returning functions</em></span> (also known as a <span class="emphasis"><em>table functions</em></span>) since they typically return more than one value. In this case, the functions are marked with the <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>

 symbol.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="bin_functions"></a>Bin Operations</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="bins"></a><a class="indexterm" name="id6870"></a><p>Return an array of bins that cover a value or time span with bins of the same size or duration
</p><p><code class="varname">bins(numspans,size number,origin number=0) → span[]</code></p><p><code class="varname">bins(datespans,duration interval,origin date='2000-01-03') → span[]</code></p><p><code class="varname">bins(tstzspans,duration interval,origin timestamptz='2000-01-03') → span[]</code></p><p>If the origin is not specified, it is set by default to 0 for value spans and Monday, January 3, 2000 for time spans.</p><pre class="programlisting">
SELECT bins(floatspan '[-10, -1]', 2.5, -7);
-- {"[-12, -9.5)","[-9.5, -7)","[-7, -4.5)","[-4.5, -2)","[-2, 0.5)"}
SELECT bins(intspan '[15, 25]', 2);
-- {"[14, 16)","[16, 18)","[18, 20)","[20, 22)","[22, 24)","[24, 26)","[26, 28)"}
SELECT index, span
FROM unnest(bins(datespan '[2001-01-15, 2001-01-25]', '2 days'))
  WITH ORDINALITY t(span, index);
-- 1 | [2001-01-15, 2001-01-17)
-- 2 | [2001-01-17, 2001-01-19)
-- 3 | [2001-01-19, 2001-01-21)
-- ...
SELECT index, span
FROM unnest(bins(tstzspanset '{[2001-01-15, 2001-01-17],[2001-01-22, 2001-01-25]}',
  '2 days', '2001-01-02')) WITH ORDINALITY t(span, index);
-- 1 | [2001-01-15, 2001-01-16)
-- 2 | [2001-01-16, 2001-01-17]
-- 3 | [2001-01-22, 2001-01-24)
-- 4 | [2001-01-24, 2001-01-25]
</pre></li><li class="listitem"><a name="getBin"></a><a class="indexterm" name="id6883"></a><p>Return the bin that contains a number or a timestamp</p><p><code class="varname">getBin(number,size number,origin number=0) → span</code></p><p><code class="varname">getBin(date,duration interval,origin date='2000-01-03') → </code></p><p><code class="varname">getBin(timestamptz,duration interval,origin timestamptz='2000-01-03') → </code></p><p><code class="varname">  timestamptz</code></p><p>If the origin is not specified, it is set by default to 0 for value bins and to Monday, January 3, 2000 for time bins.</p><pre class="programlisting">
SELECT getBin(2, 2);
-- [2, 4)
SELECT getBin(2, 2.5, 1.5);
-- [1.5, 4)
SELECT getBin('2001-01-04', interval '1 week');
-- [2001-01-03, 2001-01-10)
SELECT getBin('2001-01-04', interval '1 week', '2001-01-07');
-- [2000-12-31, 2001-01-07)
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tile_functions"></a>Tile Operations</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="valueTimeTiles"></a><a class="indexterm" name="id6901"></a><a class="indexterm" name="id6904"></a><a class="indexterm" name="id6907"></a><p>Return the set of tiles that covers a temporal box with tiles of the same size and/or duration <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>

</p><p><code class="varname">valueTiles(tbox,vsize float,vorigin float=0) → {(index,tile)}</code></p><p><code class="varname">timeTiles(tbox,duration interval,torigin timestamptz='2000-01-03')  →</code></p><p><code class="varname"> {(index,tile)}</code></p><p><code class="varname">valueTimeTiles(tbox,vsize float,duration interval,vorigin float=0,</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → {(index,tile)}</code></p><p>The result is a set of pairs <code class="varname">(index,tile)</code>. If the origin of the value and/or time dimension is not specified, it is set by default to 0 and to Monday, January 3, 2000, respectively.</p><pre class="programlisting">
SELECT (gr).index, (gr).tile
FROM (SELECT valueTiles(tfloat '[15@2001-01-15, 25@2001-01-25]'::tbox, 2.0) AS gr) t;
-- 1 | TBOXFLOAT X([14, 16))
-- 2 | TBOXFLOAT X([16, 18))
-- 3 | TBOXFLOAT X([18, 20))
-- ...
SELECT (gr).index, (gr).tile
FROM (SELECT timeTiles(tfloat '[15@2001-01-15, 25@2001-01-25]'::tbox, '2 days') AS gr) t;
-- 1 | TBOX T([2001-01-15, 2001-01-17))
-- 2 | TBOX T([2001-01-17, 2001-01-19))
-- 3 | TBOX T([2001-01-19, 2001-01-21))
-- ...
SELECT (gr).index, (gr).tile
FROM (SELECT valueTimeTiles(tfloat '[15@2001-01-15, 25@2001-01-25]'::tbox, 2.0, '2 days')
  AS gr) t;
-- 1 | TBOX XT([14,16),[2001-01-15,2001-01-17))
-- 2 | TBOX XT([16,18),[2001-01-15,2001-01-17))
-- 3 | TBOX XT([18,20),[2001-01-15,2001-01-17))
-- ...
SELECT valueTimeTiles(tfloat '[15@2001-01-15,25@2001-01-25]'::tbox, 2.0, '2 days', 11.5);
-- (1,"TBOX XT([13.5,15.5),[2001-01-15,2001-01-17))")
-- (2,"TBOX XT([15.5,17.5),[2001-01-15,2001-01-17))")
-- (3,"TBOX XT([17.5,19.5),[2001-01-15,2001-01-17))")
-- ...
</pre></li><li class="listitem"><a name="spaceTimeTiles"></a><a class="indexterm" name="id6932"></a><a class="indexterm" name="id6935"></a><a class="indexterm" name="id6938"></a><p>Return the set of tiles that covers a spatiotemporal box with tiles of the same size and/or duration <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>

 <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>

</p><p><code class="varname">spaceTiles(stbox,xsize float,[ysize float,zsize float,] </code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)',borderInc bool=true) → {(index,tile)}</code></p><p><code class="varname">timeTiles(stbox,duration interval,torigin timestamptz='2000-01-03',</code></p><p><code class="varname">  borderInc bool=true) → {(index,tile)}</code></p><p><code class="varname">spaceTimeTiles(stbox,xsize float,[ysize float,zsize float,]duration interval,</code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)',torigin timestamptz='2000-01-03',</code></p><p><code class="varname">  borderInc bool=true) → {(index,tile)}</code></p><p>The result is a set of pairs <code class="varname">(index,tile)</code>. If the origin of the space and/or time dimension is not specified, it is set by default to <code class="varname">'Point(0 0 0)'</code> and to Monday, January 3, 2000, respectively. The optional argument <code class="varname">borderInc</code> states whether the upper border of the extent is included and thus, extra tiles containing the border are generated.</p><p>In the case of a spatiotemporal grid, <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. The SRID of the tile coordinates is determined by the input box and the sizes are given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</p><pre class="programlisting">
SELECT spaceTiles(tgeompoint '[Point(3 3)@2001-01-15,
  Point(15 15)@2001-01-25]'::stbox, 2.0);
-- (1,"STBOX X((2,2),(4,4))")
-- (2,"STBOX X((4,2),(6,4))")
-- (3,"STBOX X((6,2),(8,4))")
-- ...
SELECT timeTiles(tgeompoint '[Point(3 3)@2001-01-15,
  Point(15 15)@2001-01-25]'::stbox, '2 days');
-- (1,"STBOX T([2001-01-15, 2001-01-17))")
-- (2,"STBOX T([2001-01-17, 2001-01-19))")
-- (3,"STBOX T([2001-01-19, 2001-01-21))")
-- ...
SELECT spaceTiles(tgeompoint 'SRID=3812;[Point(3 3)@2001-01-15,
  Point(15 15)@2001-01-25]'::stbox, 2.0, geometry 'Point(3 3)');
-- (1,"SRID=3812;STBOX X((3,3),(5,5))")
-- (2,"SRID=3812;STBOX X((5,3),(7,5))")
-- (3,"SRID=3812;STBOX X((7,3),(9,5))")
-- ...
SELECT spaceTiles(tgeompoint '[Point(3 3 3)@2001-01-15,
  Point(15 15 15)@2001-01-25]'::stbox, 2.0, geometry 'Point(3 3 3)');
-- (1,"STBOX Z((3,3,3),(5,5,5))")
-- (2,"STBOX Z((5,3,3),(7,5,5))")
-- (3,"STBOX Z((7,3,3),(9,5,5))")
-- ...
SELECT spaceTimeTiles(tgeompoint '[Point(3 3)@2001-01-15,
  Point(15 15)@2001-01-25]'::stbox, 2.0, interval '2 days');
-- (1,"STBOX XT(((2,2),(4,4)),[2001-01-15,2001-01-17))")
-- (2,"STBOX XT(((4,2),(6,4)),[2001-01-15,2001-01-17))")
-- (3,"STBOX XT(((6,2),(8,4)),[2001-01-15,2001-01-17))")
-- ...
SELECT spaceTimeTiles(tgeompoint '[Point(3 3 3)@2001-01-15,
  Point(15 15 15)@2001-01-25]'::stbox, 2.0, interval '2 days',
  'Point(3 3 3)', '2001-01-15');
-- (1,"STBOX ZT(((3,3,3),(5,5,5)),[2001-01-15,2001-01-17))")
-- (2,"STBOX ZT(((5,3,3),(7,5,5))),[2001-01-15,2001-01-17)")
-- (3,"STBOX ZT(((7,3,3),(9,5,5))),[2001-01-15,2001-01-17)")
-- ...
</pre></li><li class="listitem"><a name="getValueTimeTile"></a><a class="indexterm" name="id6980"></a><a class="indexterm" name="id6983"></a><a class="indexterm" name="id6986"></a><p>Return the temporal tile that covers a value and/or a timestamp <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>

</p><p><code class="varname">getValueTile(value float,vsize float,vorigin float=0.0,) → tbox</code></p><p><code class="varname">getTboxTimeTile(time timestamptz,duration interval,</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → tbox</code></p><p><code class="varname">getValueTimeTile(value float,time timestamptz,size float,duration interval,</code></p><p><code class="varname">  vorigin float=0.0,torigin timestamptz='2000-01-03') → tbox</code></p><p>If the origin of the value and/or time dimension is not specified, it is set by default to 0 and to Monday, January 3, 2000, respectively.</p><pre class="programlisting">
SELECT getValueTile(15, 2);
-- TBOX ([14,16))
SELECT getTboxTimeTile('2001-01-15', interval '2 days');
-- TBOX ([2001-01-15,2001-01-17))
SELECT getValueTimeTile(15, '2001-01-15', 2, interval '2 days');
-- TBOX XT([14,16),[2001-01-15,2001-01-17))
SELECT getValueTimeTile(15, '2001-01-15', 2, interval '2 days', 1, '2001-01-02');
-- TBOX XT([15,17),[2001-01-14,2001-01-16))
</pre></li><li class="listitem"><a name="getSpaceTimeTile"></a><a class="indexterm" name="id7010"></a><a class="indexterm" name="id7013"></a><a class="indexterm" name="id7016"></a><p>Return the spatiotemporal tile that covers a point and/or a timestamp <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>

</p><p><code class="varname">getSpaceTile(point geometry,xsize float,[ysize float,zsize float],</code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)') → stbox</code></p><p><code class="varname">getStboxTimeTile(time timestamptz,duration interval,</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → stbox</code></p><p><code class="varname">getSpaceTimeTile(point geometry,time timestamptz,xsize float,</code></p><p><code class="varname">  [ysize float,zsize float,]duration,interval,sorigin geompoint='Point(0 0 0)',</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → stbox</code></p><p>If the origin of the space and/or time dimension is not specified, it is set by default to <code class="varname">Point(0 0 0)</code> and to Monday, January 3, 2000, respectively.</p><p>In the case of a spatiotemporal grid, <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. The SRID of the tile coordinates is determined by the input point and the sizes are given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</p><pre class="programlisting">
SELECT getSpaceTile(geometry 'Point(1 1 1)', 2.0);
-- STBOX Z((0,0,0),(2,2,2))
SELECT getStboxTimeTile(timestamptz '2001-01-01', interval '2 days');
-- STBOX T([2001-01-01,2001-01-03))
SELECT getSpaceTimeTile(geometry 'Point(1 1)', '2001-01-01', 2.0, interval '2 days');
-- STBOX XT(((0,0),(2,2)),[2001-01-01, 2001-01-03))
SELECT getSpaceTimeTile(geometry 'Point(1 1)', '2001-01-01', 2.0, interval '2 days',
  'Point(1 1)', '2001-01-02');
-- STBOX XT(((1,1),(3,3)),[2000-12-31, 2001-01-02))
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="boxes_functions"></a>Bounding Box Operations</h3></div></div></div><p>These functions fragment the bounding box of a temporal value with respect to a multidimensional grid. They provide an alternative to the functions in <a class="xref" href="ch09s04.html" title="Splitting Operations">the section called “Splitting Operations”</a> to split the bounding boxes by specifying the maximum size of the boxes in the various dimensions.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="valueTimeBins"></a><a class="indexterm" name="id7054"></a><a class="indexterm" name="id7057"></a><p>Return an array of value or time spans obtained from the instants or segments of a temporal number with respect to a value or time grid</p><p><code class="varname">valueBins(tnumber,vsize number,vorigin number=0) → numspan[]</code></p><p><code class="varname">timeBins(temp,duration interval,torigin timestamptz='2000-01-03') → tstzspan[]</code></p><p>The choice between instants or segments depends on whether the interpolation is discrete or continuous. If the origin of values or time is not specified, it is set by default to 0 for value spans or to Monday, January 3, 2000 for time spans.</p><pre class="programlisting">
SELECT valueBins(tint '{1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05}', 3);
-- {"[1, 3)","[4, 5)"}
SELECT valueBins(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05]', 3, 1);
-- {"[1, 4)","[4, 4]"}
</pre><pre class="programlisting">
SELECT timeBins(ttext '{AAA@2000-01-01, BBB@2000-01-02, AAA@2000-01-03, CCC@2000-01-04,
  AAA@2000-01-05}', '3 days');
-- {"[2000-01-01, 2000-01-02]","[2000-01-03, 2000-01-05]"}
SELECT timeBins(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05]', '3 days', '2000-01-01');
-- {"[2000-01-01, 2000-01-04)","[2000-01-04, 2000-01-05)"}
</pre></li><li class="listitem"><a name="valueTimeBoxes"></a><a class="indexterm" name="id7069"></a><a class="indexterm" name="id7072"></a><a class="indexterm" name="id7075"></a><p>Return an array of temporal boxes obtained from the instants or segments of a temporal number with respect to a value and/or time grid</p><p><code class="varname">valueBoxes(tnumber,size number,vorigin number=0) → tbox[]</code></p><p><code class="varname">timeBoxes(tnumber,duration interval,torigin timestamptz='2000-01-03') → tbox[]</code></p><p><code class="varname">valueTimeBoxes(tnumber,size number,duration interval,vorigin number=0,</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → tbox[]</code></p><p>The choice between instants or segments depends on whether the interpolation is discrete or continuous. If the origin of value and/or time dimension is not specified, it is set by default to 0 and to Monday, January 3, 2000, respectively.</p><pre class="programlisting">
SELECT valueBoxes(tint '{1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
1@2000-01-05}', 3);
/* {"TBOXINT XT([1, 3),[2000-01-01, 2000-01-05])",
    "TBOXINT XT([4, 5),[2000-01-04, 2000-01-04])"} */
SELECT timeBoxes(tint '{1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
1@2000-01-05}', '3 days');
/* {"TBOXINT XT([1, 3),[2000-01-01, 2000-01-02])",
    "TBOXINT XT([1, 5),[2000-01-03, 2000-01-05])"} */
SELECT valueTimeBoxes(tint '{1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05}', 3, '3 days');
/* {"TBOXINT XT([1, 3),[2000-01-01, 2000-01-02])",
    "TBOXINT XT([1, 2),[2000-01-03, 2000-01-05])",
    "TBOXINT XT([4, 5),[2000-01-04, 2000-01-04])"} */
SELECT valueTimeBoxes(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 4@2000-01-04,
  1@2000-01-05]', 3, '3 days', 1, '2000-01-01');
/* {"TBOXFLOAT XT([1, 4),[2000-01-01, 2000-01-04))",
    "TBOXFLOAT XT([1, 4),(2000-01-04, 2000-01-05])",
    "TBOXFLOAT XT([4, 4],[2000-01-04, 2000-01-04])"} */
</pre></li><li class="listitem"><a name="spaceTimeBoxes"></a><a class="indexterm" name="id7090"></a><a class="indexterm" name="id7093"></a><a class="indexterm" name="id7096"></a><p>Return an array of spatiotemporal boxes obtained from the instants or segments of a temporal point with respect to a space and/or time grid <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>

</p><p><code class="varname">spaceBoxes(tgeompoint,xsize float,[ysize float,zsize float,] </code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)',borderInc bool=true) → stbox[]</code></p><p><code class="varname">timeBoxes(tgeompoint,duration interval,torigin timestamptz='2000-01-03',</code></p><p><code class="varname">  borderInc bool=true) → stbox[]</code></p><p><code class="varname">spaceTimeBoxes(tgeompoint,xsize float,[ysize float,zsize float,]duration interval,</code></p><p><code class="varname">  sorigin geompoint='Point(0 0 0)',torigin timestamptz='2000-01-03',</code></p><p><code class="varname">  borderInc bool=true) → stbox[]</code></p><p>The choice between instants or segments depends on whether the interpolation is discrete or continuous. The arguments <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. The SRID of the tile coordinates is determined by the temporal point and the sizes are given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of temporal point, otherwise an error is raised. If the origin of space and/or time dimension is not specified, it is set by default to <code class="varname">'Point(0 0 0)'</code> and to Monday, January 3, 2000, respectively. The optional argument <code class="varname">borderInc</code> states whether the upper border of the extent is included and thus, extra tiles containing the border are generated.</p><pre class="programlisting">
SELECT spaceBoxes(tgeompoint '{Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(1 1)@2000-01-03, Point(4 4)@2000-01-04, Point(1 1)@2000-01-05}', 3);
/* {"STBOX XT(((1,1),(2,2)),[2000-01-01, 2000-01-05])",
   "STBOX XT(((4,4),(4,4)),[2000-01-04, 2000-01-04])"} */
SELECT timeBoxes(tgeompoint '{Point(1 1 1)@2000-01-01, Point(2 2 2)@2000-01-02,
  Point(1 1 1)@2000-01-03, Point(4 4 4)@2000-01-04, Point(1 1 1)@2000-01-05}',
  interval '2 days', '2000-01-01');
/* {"STBOX ZT(((1,1,1),(2,2,2)),[2000-01-01, 2000-01-02])",
    "STBOX ZT(((1,1,1),(4,4,4)),[2000-01-03, 2000-01-04])",
    "STBOX ZT(((1,1,1),(1,1,1)),[2000-01-05, 2000-01-05])"} */
SELECT spaceTimeBoxes(tgeompoint '{Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(1 1)@2000-01-03, Point(4 4)@2000-01-04, Point(1 1)@2000-01-05}', 3, '3 days');
/* {"STBOX XT(((1,1),(2,2)),[2000-01-01, 2000-01-02])",
    "STBOX XT(((1,1),(1,1)),[2000-01-03, 2000-01-05])",
    "STBOX XT(((4,4),(4,4)),[2000-01-04, 2000-01-04])"} */
SELECT spaceTimeBoxes(tgeompoint '[Point(1 1 1)@2000-01-01, Point(2 2 2)@2000-01-02,
  Point(1 1 1)@2000-01-03, Point(4 4 4)@2000-01-04, Point(1 1 1)@2000-01-05]',
  3, interval '3 days', 'Point(1 1 1)', '2000-01-01');
/* {"STBOX ZT(((1,1,1),(4,4,4)),[2000-01-01, 2000-01-04))",
    "STBOX ZT(((1,1,1),(4,4,4)),(2000-01-04, 2000-01-05])",
    "STBOX ZT(((4,4,4),(4,4,4)),[2000-01-04, 2000-01-04])"} */
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="split_functions"></a>Splitting Operations</h3></div></div></div><p>These functions split a temporal value with respect to a sequence of bins (see <a class="xref" href="ch09s05.html#bin_functions" title="Bin Operations">the section called “Bin Operations”</a>) or tiles (see <a class="xref" href="ch09s05.html#tile_functions" title="Tile Operations">the section called “Tile Operations”</a>).</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="valueSplit"></a><a class="indexterm" name="id7135"></a><a class="indexterm" name="id7138"></a><a class="indexterm" name="id7141"></a><p>Split a temporal number with respect to value and/or time bins <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>
</p><p><code class="varname">valueSplit(tnumber,size number,origin number=0) → {(number,tnumber)}</code></p><p><code class="varname">timeSplit(ttype,duration interval,origin timestamptz='2000-01-03') → </code></p><p><code class="varname">  {(time,temp)}</code></p><p><code class="varname">valueTimeSplit(tnumber,size number,duration interval,vorigin number=0,</code></p><p><code class="varname">  torigin timestamptz='2000-01-03') → {(number,time,tnumber}</code></p><p>The result is a set of pairs or a set of triples. If the origin of the value and/or the time dimension is not specified, they are set by default to 0 and to Monday, January 3, 2000, respectively.</p><pre class="programlisting">
SELECT (sp).number, (sp).tnumber
FROM (SELECT valueSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05, 10@2001-01-10]',
  2) AS sp) t;
--  0 | {[1@2001-01-01, 1@2001-01-02)}
--  2 | {[2@2001-01-02, 2@2001-01-05)}
--  4 | {[5@2001-01-05, 5@2001-01-10)}
-- 10 | {[10@2001-01-10]}
SELECT valueSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 2.0, 1.0);
-- (1,"{[1@2001-01-01, 3@2001-01-03)}")
-- (3,"{[3@2001-01-03, 5@2001-01-05)}")
-- (5,"{[5@2001-01-05, 7@2001-01-07)}")
-- (7,"{[7@2001-01-07, 9@2001-01-09)}")
-- (9,"{[9@2001-01-09, 10@2001-01-10 00:00:00+01)}")
</pre><pre class="programlisting">
SELECT (ts).time, (ts).temp
FROM (SELECT timeSplit(tfloat '[1@2001-02-01, 10@2001-02-10)', '2 days') AS ts) t;
-- 2001-01-31 | [1@2001-02-01, 2@2001-02-02)
-- 2001-02-02 | [2@2001-02-02, 4@2001-02-04)
-- 2001-02-04 | [4@2001-02-04, 6@2001-02-06)
-- ...
SELECT (ts).time, astext((ts).temp) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-02-01, Point(10 10)@2001-02-10]',
  '2 days', '2001-02-01') AS ts) AS t;
-- 2001-02-01 | [POINT(1 1)@2001-02-01, POINT(3 3)@2001-02-03)
-- 2001-02-03 | [POINT(3 3)@2001-02-03, POINT(5 5)@2001-02-05)
-- 2001-02-05 | [POINT(5 5)@2001-02-05, POINT(7 7)@2001-02-07)
-- ...
</pre><p>Notice that we can split a temporal value in cyclic (instead of linear) time bins. The following two examples show how to split a temporal value by hour and by day of the week.</p><pre class="programlisting">
SELECT (ts).time::time AS hour, merge((ts).temp) AS temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-03]', '1 hour') AS ts) t
GROUP BY hour ORDER BY hour;
/* 00:00:00 | {[1@2001-01-01 00:00:00+01, 1.1875@2001-01-01 01:00:00+01),
               [5.5@2001-01-02 00:00:00+01, 5.6875@2001-01-02 01:00:00+01)} */
/* 01:00:00 | {[1.1875@2001-01-01 01:00:00+01, 1.375@2001-01-01 02:00:00+01),
               [5.6875@2001-01-02 01:00:00+01, 5.875@2001-01-02 02:00:00+01)} */
/* 02:00:00 | {[1.375@2001-01-01 02:00:00+01, 1.5625@2001-01-01 03:00:00+01),
               [5.875@2001-01-02 02:00:00+01, 6.0625@2001-01-02 03:00:00+01)} */
/* 03:00:00 | {[1.5625@2001-01-01 03:00:00+01, 1.75@2001-01-01 04:00:00+01),
               [6.0625@2001-01-02 03:00:00+01, 6.25@2001-01-02 04:00:00+01)} */
/* ... */
SELECT EXTRACT(DOW FROM (ts).time) AS dow_no, TO_CHAR((ts).time, 'Dy') AS dow,
  asText(round(merge((ts).temp), 2)) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-14)',
  '1 hour') AS ts) t
GROUP BY dow, dow_no ORDER BY dow_no;
/* 0 | Sun | {[POINT(1 1)@2001-01-01, POINT(1.69 1.69)@2001-01-02),
             [POINT(5.85 5.85)@2001-01-08, POINT(6.54 6.54)@2001-01-09)} */
/* 1 | Mon | {[POINT(1.69 1.69)@2001-01-02, POINT(2.38 2.38)@2001-01-03),
             [POINT(6.54 6.54)@2001-01-09, POINT(7.23 7.23)@2001-01-10)} */
/* 2 | Tue | {[POINT(2.38 2.38)@2001-01-03, POINT(3.08 3.08)@2001-01-04),
             [POINT(7.23 7.23)@2001-01-10, POINT(7.92 7.92)@2001-01-11)} */
/* ... */
</pre><pre class="programlisting">
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tint '[1@2001-02-01, 2@2001-02-02, 5@2001-02-05,
  10@2001-02-10]', 5, '5 days') AS sp) t;
--  0 | 2001-02-01 | {[1@2001-02-01, 2@2001-02-02, 2@2001-02-05)}
--  5 | 2001-02-01 | {[5@2001-02-05, 5@2001-02-06)}
--  5 | 2001-02-06 | {[5@2001-02-06, 5@2001-02-10)}
-- 10 | 2001-02-06 | {[10@2001-02-10]}
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tfloat '[1@2001-02-01, 10@2001-02-10)', 5.0, '5 days', 1.0,
  '2001-02-01') AS sp) t;
-- 1 | 2001-01-01 | [1@2001-01-01, 6@2001-01-06)
-- 6 | 2001-01-06 | [6@2001-01-06, 10@2001-01-10)
</pre></li><li class="listitem"><a name="spaceSplit"></a><a class="indexterm" name="id7169"></a><p>Split a temporal point with respect to a spatial grid <span class="inlinemediaobject"><img src="images/cube.svg" width="13"></span>

 <span class="inlinemediaobject"><img src="images/srf.svg" width="13"></span>

</p><p><code class="varname">spaceSplit(tgeompoint,xsize float,[ysize float,zsize float,]</code></p><p><code class="varname">  origin geompoint='Point(0 0 0)',bitmatrix boolean=true,borderInc bool=true) →</code></p><p><code class="varname">  {(point,tpoint)}</code></p><p><code class="varname">timeSplit(tpoint,duration interval,torigin timestamptz='2000-01-03') → {(time,tpoint)}</code></p><p><code class="varname">spaceTimeSplit(tgeompoint,xsize float,[ysize float,zsize float,]</code></p><p><code class="varname">  duration interval,sorigin geompoint='Point(0 0 0)',</code></p><p><code class="varname">  torigin timestamptz='2000-01-03',bitmatrix boolean=true,borderInc boolean=true) →</code></p><p><code class="varname">  {(point,time,tpoint)}</code></p><p>The result is a set of pairs or a set of triples. If the origin of the space and/or time dimension is not specified, it is set by default to <code class="varname">'Point(0 0 0)'</code> and to Monday, January 3, 2000, respectively. The arguments <code class="varname">ysize</code> and <code class="varname">zsize</code> are optional, the size for the missing dimensions is assumed to be equal to <code class="varname">xsize</code>. If the argument <code class="varname">bitmatrix</code> is not specified, then the computation will use a bit matrix to speed up the process. The optional argument <code class="varname">borderInc</code> states whether the upper border of the extent is included and thus extra tiles containing the border are generated.</p><pre class="programlisting">
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1)@2001-03-01, Point(10 10)@2001-03-10]',
  2.0) AS sp) t;
-- POINT(0 0) | {[POINT(1 1)@2001-03-01, POINT(2 2)@2001-03-02)}
-- POINT(2 2) | {[POINT(2 2)@2001-03-02, POINT(4 4)@2001-03-04)}
-- POINT(4 4) | {[POINT(4 4)@2001-03-04, POINT(6 6)@2001-03-06)}
-- ...
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1 1)@2001-03-01,
  Point(10 10 10)@2001-03-10]', 2.0, geometry 'Point(1 1 1)') AS sp) t;
-- POINT Z(1 1 1) | {[POINT Z (1 1 1)@2001-03-01, POINT Z (3 3 3)@2001-03-03)}
-- POINT Z(3 3 3) | {[POINT Z (3 3 3)@2001-03-03, POINT Z (5 5 5)@2001-03-05)}
-- POINT Z(5 5 5) | {[POINT Z (5 5 5)@2001-03-05, POINT Z (7 7 7)@2001-03-07)}
-- ...
</pre><pre class="programlisting">
SELECT (sp).time, astext((sp).temp) AS tpoint
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-02-01, Point(10 10)@2001-02-10]',
  interval '2 days') AS sp) t;
-- 2001-01-31 | [POINT(1 1)@2001-02-01, POINT(2 2)@2001-02-02)
-- 2001-02-02 | [POINT(2 2)@2001-02-02, POINT(4 4)@2001-02-04)
-- 2001-02-04 | [POINT(4 4)@2001-02-04, POINT(6 6)@2001-02-06)
-- ... 
</pre><pre class="programlisting">
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1)@2001-02-01, Point(10 10)@2001-02-10]',
  2.0, interval '2 days') AS sp) t;
-- POINT(0 0) | 2001-01-31 | {[POINT(1 1)@2001-02-01, POINT(2 2)@2001-02-02)}
-- POINT(2 2) | 2001-01-31 | {[POINT(2 2)@2001-02-02]}
-- POINT(2 2) | 2001-02-02 | {[POINT(2 2)@2001-02-02, POINT(4 4)@2001-02-04)}
-- ...
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1 1)@2001-02-01,
  Point(10 10 10)@2001-02-10]', 2.0, interval '2 days', 'Point(1 1 1)',
  '2001-03-01') AS sp) t;
-- POINT Z(1 1 1) | 2001-02-01 | {[POINT Z(1 1 1)@2001-02-01, POINT Z(3 3 3)@2001-02-03)}
-- POINT Z(3 3 3) | 2001-02-01 | {[POINT Z(3 3 3)@2001-02-03]}
-- POINT Z(3 3 3) | 2001-02-03 | {[POINT Z(3 3 3)@2001-02-03, POINT Z (5 5 5)@2001-02-05)}
-- ...
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch09s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch09.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch10.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Splitting Operations </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 10. Temporal Types: Aggregation and Indexing</td></tr></table></div></body></html>
