<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Bounding Box Operations</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.1 User's Manual"><link rel="up" href="ch02.html" title="Chapter 2. Set and Span Types"><link rel="prev" href="ch02s07.html" title="Set Operations"><link rel="next" href="ch02s09.html" title="Distance Operations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Bounding Box Operations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s07.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Set and Span Types</th><td width="20%" align="right"> <a accesskey="n" href="ch02s09.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="setspan_topo_pos"></a>Bounding Box Operations</h2></div></div></div><p>When creating indexes for set or span set types, what is stored in the index is not the actual value but instead, a bounding box representing the value. In this case, the index will provide a list of candidate values that <span class="emphasis"><em>may</em></span> satisfy the query predicate, and a second step is needed to filter out candidate values by computing the query predicate on the actual values.</p><p>However, when the bounding boxes have a large empty space not covered by the actual values, the index will generate many candidate values that do not satisfy the query predicate, which reduces the efficiency of the index. In these situations, it may be better to represent a value not with a <span class="emphasis"><em>single</em></span> bounding box, but instead with <span class="emphasis"><em>multiple</em></span> bounding boxes. This increases considerably the efficiency of the index, provided that the index is able to manage multiple bounding boxes per value. The following functions are used for generating multiple spans from a single set or span set value.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="spans_merge"></a><a class="indexterm" name="idm1223"></a><p>Return an array of spans from the elements of a set or from the spans of a spanset</p><p><code class="varname">spansMerge(set, max_count = 0) → span[]</code></p><p><code class="varname">spansMerge(spanset, max_count = 0) → span[]</code></p><p>If the last argument is not specified or if the number of elements is less than the maximum number of values specified, the resulting array will have one span per element. Otherwise, the specified number of spans will be obtained from several consecutive elements.</p><pre class="programlisting">
SELECT spansMerge(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}');
/* {"[1, 2)","[2, 3)","[3, 4)","[4, 5)","[5, 6)","[6, 7)","[7, 8)","[8, 9)",
    "[9, 10)","[10, 11)"} */
SELECT spansMerge(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 3);
-- {"[1, 5)","[5, 8)","[8, 11)"}
SELECT spansMerge(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 6);
-- {"[1, 3)","[3, 5)","[5, 7)","[7, 9)","[9, 10)","[10, 11)"}
</pre><pre class="programlisting">
SELECT spansMerge(intspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}');
-- {"[1, 2)","[3, 4)","[5, 6)","[7, 8)","[9, 10)"}
SELECT spansMerge(floatspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}', 3);
-- {"[1, 4)","[5, 8)","[9, 10)"}
SELECT spansMerge(datespanset '{[2000-01-01, 2000-01-04), [2000-01-05, 2000-01-10)}', 3);
-- {"[2000-01-01, 2000-01-04)","[2000-01-05, 2000-01-10)"}
</pre></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1234"></a>Topological Operations</h3></div></div></div><p>The topological operations available for the set and span types are given next.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="setspan_overlaps"></a><a class="indexterm" name="idm1239"></a><p>Do the values overlap (have values in common)?</p><p><code class="varname">{set,spans} &amp;&amp; {set,spans} → boolean</code></p><pre class="programlisting">
SELECT intset '{1, 3}' &amp;&amp; intset '{2, 3, 4}';
-- true
SELECT floatspan '[1, 3)' &amp;&amp; floatspan '[3, 4)';
-- false
SELECT tstzspan '[2001-01-01, 2001-01-05)' &amp;&amp; tstzspan '[2001-01-02, 2001-01-07)';
-- true
SELECT floatspanset '{[1, 5),[6, 8)}' &amp;&amp; floatspan '[1, 6)';
-- true
</pre></li><li class="listitem"><a name="setspan_contains"></a><a class="indexterm" name="idm1247"></a><p>Does the first value contain the second one?</p><p><code class="varname">{set,spans} @&gt; {base,set,spans} → boolean</code></p><pre class="programlisting">
SELECT floatset '{1.5, 2.5}' @&gt; 2.5;
-- true
SELECT tstzspan '[2001-01-01, 2001-05-01)' @&gt; timestamptz '2001-02-01';
-- true
SELECT floatspanset '{[1, 2),(2, 3)}' @&gt; 2.0;
-- false
</pre></li><li class="listitem"><a name="setspan_containedby"></a><a class="indexterm" name="idm1255"></a><p>Is the first value contained by the second one?</p><p><code class="varname">{base,set,spans} &lt;@ {set,spans} → boolean</code></p><pre class="programlisting">
SELECT timestamptz '2001-01-10' &lt;@ tstzspan '[2001-01-01, 2001-05-01)';
-- true
SELECT floatspan '[2, 5]' &lt;@ floatspan '[1, 5)';
-- false
SELECT tstzspan '[2001-02-01, 2001-03-01)' &lt;@ tstzspan '[2001-01-01, 2001-05-01)';
-- true
SELECT floatspanset '{[1,2],[3,4]}' &lt;@ floatspan '[1, 6]';
-- true
</pre></li><li class="listitem"><a name="setspan_adjacent"></a><a class="indexterm" name="idm1263"></a><p>Is the first value adjacent to the second one?</p><p><code class="varname">spans -|- spans → boolean</code></p><pre class="programlisting">
SELECT intspan '[2, 6)' -|- intspan '[6, 7)';
-- true
SELECT floatspan '[2, 5)' -|- floatspan '(5, 6)';
-- false
SELECT floatspanset '{[2, 3],[4, 5)}' -|- floatspan '(5, 6)';
-- true
SELECT tstzspanset '{[2001-01-01, 2001-01-02]}' -|- tstzspan '[2001-01-02, 2001-01-03)';
-- false
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1270"></a>Position Operations</h3></div></div></div><p>The position operations available for set and span types are given next. Notice that the operators for time types have an additional <code class="varname">#</code> to distinguish them from the operators for number types.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="setspan_left"></a><a class="indexterm" name="idm1276"></a><a class="indexterm" name="idm1279"></a><p>Is the first value strictly left of the second one?</p><p><code class="varname">numbers &lt;&lt; numbers → boolean</code></p><p><code class="varname">times &lt;&lt;# times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &lt;&lt; 20;
-- true
SELECT intspanset '{[15, 17],[18, 20)}' &lt;&lt; 20;
-- true
SELECT floatspan '[15, 20)' &lt;&lt; floatspan '(15, 20)';
-- false
SELECT dateset '{2001-01-01, 2001-01-02}' &lt;&lt;# dateset '{2001-01-03, 2001-01-05}';
-- true
</pre></li><li class="listitem"><a name="setspan_right"></a><a class="indexterm" name="idm1289"></a><a class="indexterm" name="idm1292"></a><p>Is the first value strictly to the right of the second one?</p><p><code class="varname">numbers &gt;&gt; numbers → boolean</code></p><p><code class="varname">times #&gt;&gt; times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &gt;&gt; 10;
-- true
SELECT floatspan '[15, 20)' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT floatspanset '{[15, 17], [18, 20)}' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT tstzspan '[2001-01-04, 2001-01-05)' #&gt;&gt;
  tstzspanset '{[2001-01-01, 2001-01-04), [2001-01-05, 2001-01-06)}';
-- true
</pre></li><li class="listitem"><a name="setspan_overleft"></a><a class="indexterm" name="idm1302"></a><a class="indexterm" name="idm1305"></a><p>Is the first value not to the right of the second one?</p><p><code class="varname">numbers &amp;&lt; numbers → boolean</code></p><p><code class="varname">times &amp;&lt;# times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &amp;&lt; 18;
-- false
SELECT intspanset '{[15, 16],[17, 18)}' &amp;&lt; 18;
-- true
SELECT floatspan '[15, 20)' &amp;&lt; floatspan '[10, 20]';
-- true
SELECT dateset '{2001-01-02, 2001-01-05}' &amp;&lt;# dateset '{2001-01-01, 2001-01-04}';
-- false
</pre></li><li class="listitem"><a name="setspan_overright"></a><a class="indexterm" name="idm1315"></a><a class="indexterm" name="idm1318"></a><p>Is the first value not to the left of the second one?</p><p><code class="varname">numbers &amp;&gt; numbers → boolean</code></p><p><code class="varname">times #&amp;&gt; times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &amp;&gt; 30;
-- true
SELECT floatspan '[1, 6]' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT floatspanset '{[1, 2],[3, 4]}' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT timestamp '2001-01-01' #&amp;&gt; tstzspan '[2001-01-01, 2001-01-05)';
-- true
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s07.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch02s09.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Set Operations </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Distance Operations</td></tr></table></div></body></html>
