<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Bounding Box Operations</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.3 User's Manual"><link rel="up" href="ch02.html" title="Chapter 2. Set and Span Types"><link rel="prev" href="ch02s07.html" title="Set Operations"><link rel="next" href="ch02s09.html" title="Distance Operations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Bounding Box Operations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s07.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Set and Span Types</th><td width="20%" align="right"> <a accesskey="n" href="ch02s09.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="setspan_topo_pos"></a>Bounding Box Operations</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1216"></a>Topological Operations</h3></div></div></div><p>The topological operations available for the set and span types are given next.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="setspan_overlaps"></a><a class="indexterm" name="idm1221"></a><p>Do the values overlap (have values in common)?</p><p><code class="varname">{set,spans} &amp;&amp; {set,spans} → boolean</code></p><pre class="programlisting">
SELECT intset '{1, 3}' &amp;&amp; intset '{2, 3, 4}';
-- true
SELECT floatspan '[1, 3)' &amp;&amp; floatspan '[3, 4)';
-- false
SELECT tstzspan '[2001-01-01, 2001-01-05)' &amp;&amp; tstzspan '[2001-01-02, 2001-01-07)';
-- true
SELECT floatspanset '{[1, 5),[6, 8)}' &amp;&amp; floatspan '[1, 6)';
-- true
</pre></li><li class="listitem"><a name="setspan_contains"></a><a class="indexterm" name="idm1229"></a><p>Does the first value contain the second one?</p><p><code class="varname">{set,spans} @&gt; {base,set,spans} → boolean</code></p><pre class="programlisting">
SELECT floatset '{1.5, 2.5}' @&gt; 2.5;
-- true
SELECT tstzspan '[2001-01-01, 2001-05-01)' @&gt; timestamptz '2001-02-01';
-- true
SELECT floatspanset '{[1, 2),(2, 3)}' @&gt; 2.0;
-- false
</pre></li><li class="listitem"><a name="setspan_containedby"></a><a class="indexterm" name="idm1237"></a><p>Is the first value contained by the second one?</p><p><code class="varname">{base,set,spans} &lt;@ {set,spans} → boolean</code></p><pre class="programlisting">
SELECT timestamptz '2001-01-10' &lt;@ tstzspan '[2001-01-01, 2001-05-01)';
-- true
SELECT floatspan '[2, 5]' &lt;@ floatspan '[1, 5)';
-- false
SELECT tstzspan '[2001-02-01, 2001-03-01)' &lt;@ tstzspan '[2001-01-01, 2001-05-01)';
-- true
SELECT floatspanset '{[1,2],[3,4]}' &lt;@ floatspan '[1, 6]';
-- true
</pre></li><li class="listitem"><a name="setspan_adjacent"></a><a class="indexterm" name="idm1245"></a><p>Is the first value adjacent to the second one?</p><p><code class="varname">spans -|- spans → boolean</code></p><pre class="programlisting">
SELECT intspan '[2, 6)' -|- intspan '[6, 7)';
-- true
SELECT floatspan '[2, 5)' -|- floatspan '(5, 6)';
-- false
SELECT floatspanset '{[2, 3],[4, 5)}' -|- floatspan '(5, 6)';
-- true
SELECT tstzspanset '{[2001-01-01, 2001-01-02]}' -|- tstzspan '[2001-01-02, 2001-01-03)';
-- false
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1252"></a>Position Operations</h3></div></div></div><p>The position operations available for set and span types are given next. Notice that the operators for time types have an additional <code class="varname">#</code> to distinguish them from the operators for number types.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="setspan_left"></a><a class="indexterm" name="idm1258"></a><a class="indexterm" name="idm1261"></a><p>Is the first value strictly left of the second one?</p><p><code class="varname">numbers &lt;&lt; numbers → boolean</code></p><p><code class="varname">times &lt;&lt;# times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &lt;&lt; 20;
-- true
SELECT intspanset '{[15, 17],[18, 20)}' &lt;&lt; 20;
-- true
SELECT floatspan '[15, 20)' &lt;&lt; floatspan '(15, 20)';
-- false
SELECT dateset '{2001-01-01, 2001-01-02}' &lt;&lt;# dateset '{2001-01-03, 2001-01-05}';
-- true
</pre></li><li class="listitem"><a name="setspan_right"></a><a class="indexterm" name="idm1271"></a><a class="indexterm" name="idm1274"></a><p>Is the first value strictly to the right of the second one?</p><p><code class="varname">numbers &gt;&gt; numbers → boolean</code></p><p><code class="varname">times #&gt;&gt; times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &gt;&gt; 10;
-- true
SELECT floatspan '[15, 20)' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT floatspanset '{[15, 17], [18, 20)}' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT tstzspan '[2001-01-04, 2001-01-05)' #&gt;&gt;
  tstzspanset '{[2001-01-01, 2001-01-04), [2001-01-05, 2001-01-06)}';
-- true
</pre></li><li class="listitem"><a name="setspan_overleft"></a><a class="indexterm" name="idm1284"></a><a class="indexterm" name="idm1287"></a><p>Is the first value not to the right of the second one?</p><p><code class="varname">numbers &amp;&lt; numbers → boolean</code></p><p><code class="varname">times &amp;&lt;# times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &amp;&lt; 18;
-- false
SELECT intspanset '{[15, 16],[17, 18)}' &amp;&lt; 18;
-- true
SELECT floatspan '[15, 20)' &amp;&lt; floatspan '[10, 20]';
-- true
SELECT dateset '{2001-01-02, 2001-01-05}' &amp;&lt;# dateset '{2001-01-01, 2001-01-04}';
-- false
</pre></li><li class="listitem"><a name="setspan_overright"></a><a class="indexterm" name="idm1297"></a><a class="indexterm" name="idm1300"></a><p>Is the first value not to the left of the second one?</p><p><code class="varname">numbers &amp;&gt; numbers → boolean</code></p><p><code class="varname">times #&amp;&gt; times → boolean</code></p><pre class="programlisting">
SELECT intspan '[15, 20)' &amp;&gt; 30;
-- true
SELECT floatspan '[1, 6]' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT floatspanset '{[1, 2],[3, 4]}' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT timestamp '2001-01-01' #&amp;&gt; tstzspan '[2001-01-01, 2001-01-05)';
-- true
</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="setspan_bbox_split"></a>Bounding Box Splitting</h3></div></div></div><p>When creating indexes for set or span set types, what is stored in the index is not the actual value but instead, a bounding box that <span class="emphasis"><em>represents</em></span> the value. In this case, the index will provide a list of candidate values that <span class="emphasis"><em>may</em></span> satisfy the query predicate, and a second step is needed to filter out candidate values by computing the query predicate on the actual values.</p><p>However, when the bounding boxes have a large empty space not covered by the actual values, the index will generate many candidate values that do not satisfy the query predicate, which reduces the efficiency of the index. In these situations, it may be better to represent a value not with a <span class="emphasis"><em>single</em></span> bounding box, but instead with <span class="emphasis"><em>multiple</em></span> bounding boxes. This increases considerably the efficiency of the index, provided that the index is able to manage multiple bounding boxes per value. The following functions are used for generating multiple spans from a single set or span set value.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="splitNSpans"></a><a class="indexterm" name="idm1319"></a><p>Return an array of N spans obtained by merging the elements of a set or the spans of a spanset</p><p><code class="varname">splitNSpans(set, integer) → span[]</code></p><p><code class="varname">splitNSpans(spanset, integer) → span[]</code></p><p>The last argument specifies the number of output spans. If the number of input elements or spans is less than the given number, the resulting array will have one span per input element or span. Otherwise, the given number of output spans will be obtained by merging several consecutive input elements or spans.</p><pre class="programlisting">
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 1);
/* {"[1, 11)"} */
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 3);
-- {"[1, 5)","[5, 8)","[8, 11)"}
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 6);
-- {"[1, 3)","[3, 5)","[5, 7)","[7, 9)","[9, 10)","[10, 11)"}
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 12);
/* {"[1, 2)","[2, 3)","[3, 4)","[4, 5)","[5, 6)","[6, 7)","[7, 8)","[8, 9)",
    "[9, 10)","[10, 11)"} */
</pre><pre class="programlisting">
SELECT splitNSpans(intspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}');
-- {"[1, 2)","[3, 4)","[5, 6)","[7, 8)","[9, 10)"}
SELECT splitNSpans(floatspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}', 3);
-- {"[1, 4)","[5, 8)","[9, 10)"}
SELECT splitNSpans(datespanset '{[2000-01-01, 2000-01-04), [2000-01-05, 2000-01-10)}', 3);
-- {"[2000-01-01, 2000-01-04)","[2000-01-05, 2000-01-10)"}
</pre></li><li class="listitem"><a name="splitEachNSpans"></a><a class="indexterm" name="idm1331"></a><p>Return an array of spans obtained by merging N consecutive elements of a set or N consecutive spans of a spanset</p><p><code class="varname">splitEachNSpans(set, integer) → span[]</code></p><p><code class="varname">splitEachNSpans(spanset, integer) → span[]</code></p><p>The last argument specifies the number of input elements that are merged to produce an output span. If the number of input elements is less than the given number, the resulting array will have one output span per element. Otherwise, the given number of consecutive input elements will be merged into a single output span in the answer. Notice that, contrary to the <a class="link" href="ch02s08.html#splitNSpans"><code class="varname">splitNSpans</code></a> function, the number of spans in the result depends on the number of input elements or spans.</p><pre class="programlisting">
SELECT splitEachNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 1);
/* {"[1, 2)","[2, 3)","[3, 4)","[4, 5)","[5, 6)","[6, 7)","[7, 8)","[8, 9)",
    "[9, 10)","[10, 11)"} */
SELECT splitEachNSpans(intspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}', 3);
-- {"[1, 6)","[7, 10)"}
SELECT splitEachNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 6);
-- {"[1, 7)","[7, 11)"}
SELECT splitEachNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 12);
-- {"[1, 11)"}
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s07.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch02s09.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Set Operations </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Distance Operations</td></tr></table></div></body></html>
