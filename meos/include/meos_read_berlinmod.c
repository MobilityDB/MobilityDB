/*****************************************************************************
 *
 * This MobilityDB code is provided under The PostgreSQL License.
 * Copyright (c) 2016-2022, Université libre de Bruxelles and MobilityDB
 * contributors
 *
 * MobilityDB includes portions of PostGIS version 3 source code released
 * under the GNU General Public License (GPLv2 or later).
 * Copyright (c) 2001-2022, PostGIS contributors
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written
 * agreement is hereby granted, provided that the above copyright notice and
 * this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
 * EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
 * AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
 *
 *****************************************************************************/

/**
 * @brief A simple program that reads from a CSV file synthetic trip data in
 * Brussels generated by the MobilityDB-BerlinMOD generator 
 * https://github.com/MobilityDB/MobilityDB-BerlinMOD
 * and generate statics about the Brussels communes (or municipalities)
 * traversed the trips.
 *
 * The input files are
 * - `communes.csv`: data from the 19 communes composing Brussels obtained from
 *   OSM and publicly available statistical data
 * - `brussels_region.csv`: geometry of the Brussels region obtained from OSM.
 *   It is the spatial union of the 19 communes
 * - `trips.csv`: 64 trips from 5 cars during 4 days obtained from the
 *   generator at scale factor 0.005
 * In the above files, the coordinates are given in the 3857 coordinate system,
 * https://epsg.io/3857
 * and the timestamps are given in the Europe/Brussels time zone.
 * This simple program does not cope with erroneous inputs, such as missing
 * fields or invalid timestamp values.
 *
 * The program can be build as follows
 * @code
 * gcc -Wall -g -I. -o meos_read_berlinmod meos_read_berlinmod.c -L/usr/local/lib -lmeos
 * @endcode
 */

#include <stdio.h>
#include "meos.h"

typedef struct
{
  int id;
  text name;
  int population;
  double percpop;
  int popdensitykm2;
  int noenterp;
  double percenterp;
  GSERIALIZED geom;
} commune_record;

typedef struct
{
  text name;
  GSERIALIZED *geom;
} region_record;

typedef struct
{
  int vehicle;
  DateADT day;
  int seq;
  Temporal *trip;
  GSERIALIZED *trajectory;
} trip_record;

extern GSERIALIZED *PGIS_LWGEOM_in(char *input, int32 geom_typmod);
extern char *PGIS_LWGEOM_out(GSERIALIZED *geom);

/* Main program */
int main(void)
{
  /* Initialize MEOS */
  meos_initialize();

  /* You may substitute the full file path in the first argument of fopen */
  FILE *file = fopen("trips.csv", "r");

  if (! file)
  {
    printf("Error opening file\n");
    return 1;
  }

  trip_record trip_rec;
  int read = 0;
  int records = 0;
  int nulls = 0;
  /* Maximum length in characters of a trip in the input data */
  char trip_buffer[160000]; 
  /* Maximum length in characters of a geometry in the input data */
  char geo_buffer[100000]; 
  /* Maximum length in characters of a date in the input data */
  char date_buffer[12]; 

  /* Read the first line of the file with the headers */
  fscanf(file, "%1024s\n", geo_buffer);

  /* Continue reading the file */
  do
  {
    // vehicle,day,seq,trip,trajectory
    read = fscanf(file, "%d,%10[^,],%d,%160000[^,],%100000[^\n]\n",
      &trip_rec.vehicle, date_buffer, &trip_rec.seq, trip_buffer, geo_buffer);
    /* Transform the string representing the date into a date value */
    trip_rec.day = pg_date_in(date_buffer);
    /* Transform the string representing the trip into a temporal value */
    trip_rec.trip = temporal_from_hexwkb(trip_buffer);
    /* Transform the string representing the trajectory into a geometry value */
    trip_rec.trajectory = PGIS_LWGEOM_in(geo_buffer, -1);

    if (read == 5)
      records++;

    if (read != 5 && !feof(file))
    {
      printf("Record with missing values ignored\n");
      nulls++;
    }

    if (ferror(file))
    {
      printf("Error reading file\n");
      return 1;
    }

    // /* Print only 1 out of 1000 records */
    // if (records % 1000 == 0)
    // {
      // char *t_out = pg_timestamp_out(rec.T);
      // /* See above the assumptions made wrt the input data in the file */
      // sprintf(buffer, "SRID=4326;Point(%lf %lf)@%s+00", rec.Longitude,
        // rec.Latitude, t_out);
      // Temporal *inst1 = tgeogpoint_in(buffer);
      // char *inst1_out = tpoint_as_text(inst1, 2);

      // TInstant *inst2 = tfloatinst_make(rec.SOG, rec.T);
      // char *inst2_out = tfloat_out((Temporal *) inst2, 2);
      // printf("MMSI: %ld, Location: %s SOG : %s\n",
        // rec.MMSI, inst1_out, inst2_out);

      // free(inst1); free(t_out); free(inst1_out);
      // free(inst2); free(inst2_out);
    // }

  } while (!feof(file));

  printf("\n%d records read.\n%d incomplete records ignored.\n",
    records, nulls);

  /* Close the file */
  fclose(file);

  /* Finalize MEOS */
  meos_finish();

  return 0;
}
