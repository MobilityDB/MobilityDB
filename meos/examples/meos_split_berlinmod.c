/*****************************************************************************
 *
 * This MobilityDB code is provided under The PostgreSQL License.
 * Copyright (c) 2016-2022, Université libre de Bruxelles and MobilityDB
 * contributors
 *
 * MobilityDB includes portions of PostGIS version 3 source code released
 * under the GNU General Public License (GPLv2 or later).
 * Copyright (c) 2001-2022, PostGIS contributors
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written
 * agreement is hereby granted, provided that the above copyright notice and
 * this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
 * EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
 * AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
 *
 *****************************************************************************/

/**
 * @brief A simple program that reads from a CSV file synthetic trip data in
 * Brussels generated by the MobilityDB-BerlinMOD generator
 * https://github.com/MobilityDB/MobilityDB-BerlinMOD
 * simplifies the trips using both Douglas-Peucker (DP) and Synchronized
 * Euclidean Distance (SED, also known as Top-Down Time Ratio simplification),
 * and outputs for each trip the initial number of instants and the number of
 * instants of the two simplified trips.
 *
 * Please read the assumptions made about the input file `trips.csv` in the
 * file `meos_disassemble_berlinmod.c` in the same directory.
 *
 * The program can be build as follows
 * @code
 * gcc -Wall -g -I/usr/local/include -o meos_split_berlinmod meos_split_berlinmod.c -L/usr/local/lib -lmeos
 * @endcode
 */

#include <stdio.h>
#include "meos.h"

/* Maximum length in characters of a trip in the input data */
#define MAX_LENGTH_TRIP 160000
/* Maximum length in characters of a geometry in the input data */
#define MAX_LENGTH_GEOM 100000
/* Maximum length in characters of a date in the input data */
#define MAX_LENGTH_DATE 12
/* Maximun number of buckets per dimension */
#define MAX_NO_BUCKETS 10
/* Maximum number of trips */
#define MAX_NO_TRIPS 64

typedef struct
{
  int tripId;
  int vehId;
  DateADT day;
  int seq;
  Temporal *trip;
  Temporal *speed;
} trip_record;

/* Variables to read the input CSV file */
char trip_buffer[MAX_LENGTH_TRIP];
char geo_buffer[MAX_LENGTH_GEOM];
char date_buffer[MAX_LENGTH_DATE];

/* Main program */
int main(void)
{
  /* Allocate space for the trips and their speed */
  trip_record trips[MAX_NO_TRIPS];
  Temporal *value_splits[MAX_NO_BUCKETS][MAX_NO_TRIPS] = {0};
  Temporal *time_splits[MAX_NO_BUCKETS][MAX_NO_TRIPS] = {0};
  int count_value_splits[MAX_NO_BUCKETS] = {0};
  int count_time_splits[MAX_NO_BUCKETS] = {0};
  // Temporal *value_time_buckets[MAX_NO_BUCKETS][MAX_NO_BUCKETS];

  /* Number of records */
  int records = 0;
  int nulls = 0;
  /* Iterator variables */
  int i = 0, j = 0;
  /* Variable keeping the current aggregate extent */
  TBOX *extent = NULL;

  /* Initialize MEOS */
  meos_initialize(NULL);

  /* Substitute the full file path in the first argument of fopen */
  FILE *file = fopen("trips.csv", "r");

  if (! file)
  {
    printf("Error opening file\n");
    return 1;
  }

  /* Read the first line of the file with the headers */
  fscanf(file, "%1024s\n", geo_buffer);

  /* Continue reading the file */
  i = 0;
  do
  {
    int read = fscanf(file, "%d,%d,%10[^,],%d,%160000[^\n]\n",
      &trips[i].tripId, &trips[i].vehId, date_buffer, &trips[i].seq,
        trip_buffer);
    /* Transform the string representing the date into a date value */
    trips[i].day = pg_date_in(date_buffer);
    /* Transform the string representing the trip into a temporal value */
    trips[i].trip = temporal_from_hexwkb(trip_buffer);
    trips[i].speed = tpoint_speed(trips[i].trip);

    /* Add the current speed value to the running aggregate state */
    extent = tnumber_extent_transfn(extent, trips[i].speed);

    if (read == 5)
      i++;

    if (read != 5 && !feof(file))
    {
      printf("Record with missing values ignored\n");
      nulls++;
    }

    if (ferror(file))
    {
      printf("Error reading file\n");
      fclose(file);
      return 1;
    }
  } while (!feof(file));

  records = i;
  printf("\n%d records read.\n%d incomplete records ignored.\n",
    records, nulls);

  /* Computing the buckets for values and timestamps with size, respectively,
   * 5.0 and 6 hours */
  printf("Extent\n");
  printf("------\n\n");
  printf("\%s\n\n", tbox_out(extent, 6));

  int no_value_buckets, no_time_buckets;
  Span **value_buckets = floatspan_bucket_list(&extent->span, 5.0, 0.0,
    &no_value_buckets);
  Interval *duration = pg_interval_in("12 hours", -1);
  TimestampTz origin = pg_timestamptz_in("2020-06-01", -1);
  Span **time_buckets = period_bucket_list(&extent->period, duration, origin,
    &no_time_buckets);

  /* Split the speeds by value spans */
  for (i = 0; i < records; i++)
  {
    for (j = 0; j < no_value_buckets; j++)
    {
      Temporal *split = tnumber_at_span(trips[i].speed, value_buckets[j]);
      if (split != NULL)
        value_splits[j][count_value_splits[j]++] = split;
    }
  }

  /* Split the speeds by time spans */
  for (i = 0; i < records; i++)
  {
    for (j = 0; j < no_time_buckets; j++)
    {
      Temporal *split = tnumber_at_span(trips[i].speed, time_buckets[j]);
      if (split != NULL)
        time_splits[j][count_time_splits[j]++] = split;
    }
  }

  /* Free memory */
  for (i = 0; i < records; i++)
  {
    free(trips[i].trip);
    free(trips[i].speed);
  }
  for (i = 0; i < no_value_buckets; i++)
    free(value_buckets[i]);
  free(value_buckets);
  for (i = 0; i < no_time_buckets; i++)
    free(time_buckets[i]);
  free(time_buckets);

  /* Close the file */
  fclose(file);

  /* Finalize MEOS */
  meos_finish();

  return 0;
}
