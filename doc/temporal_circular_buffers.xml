<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="temporal_circular_buffers">
	<title>Temporal Circular Buffers</title>

	<para>A static circular buffer <varname>cbuffer</varname> represents a 2D point and a radius greater than or equal to 0 around the point. The radius represent the &ldquo;impact&rdquo; of the point on its surroundings. This impact could be interpreted as noise, pollution, or similar aspects depending on application requirements.</para>

	<para>The <varname>cbuffer</varname> type serves as base type for defining the temporal circular buffer type <varname>tcbuffer</varname>. The <varname>tcbuffer</varname> type has similar functionality as the temporal point type <varname>tgeompoint</varname> with the exception that it only considers two dimensions. Thus, most functions and operators described before for the <varname>tgeompoint</varname> type are also applicable for the <varname>tcbuffer</varname> type. In addition, there are specific functions defined for the <varname>tcbuffer</varname> type.</para>

	<sect1 id="static_circular_buffers">
		<title>Static Circular Buffers</title>

		<para>A <varname>cbuffer</varname> value is a couple of the form <varname>(point,radius)</varname> where <varname>point</varname> is a geometric point and <varname>radius</varname> is a <varname>float</varname> value greater than or equal to zero representing a radius around the point expressed using the units of the SRID of the point. Examples of input of circular buffer values are as follows:</para>
		<programlisting language="sql" xml:space="preserve">
SELECT cbuffer 'Cbuffer(Point(1 1), 0.3)';
SELECT cbuffer 'Cbuffer(Point(1 1), 10.0)';
</programlisting>

		<para>The constructor function for circular buffers has one argument for the point and one argument for the radius. An example of a circular buffer value defined with the constructor function is as follows:</para>
		<programlisting language="sql" xml:space="preserve">
SELECT cbuffer(ST_Point(1,1), 0.3);
</programlisting>

		<para>Values of the circular buffer type must satisfy several constraints so that they are well defined. Examples of incorrect circular buffer type values are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
-- incorrect point value
SELECT cbuffer 'Cbuffer(Linestring(1 1,2 2), 1.0)';
-- incorrect radius value
SELECT cbuffer 'Cbuffer(Point(1 1), -2.0)';
</programlisting>
		<para>We give next the functions and operators for the circular buffer type.</para>

		<sect2 id="cbuffer_constructors">
			<title>Constructors</title>

			<itemizedlist>
				<listitem id="cbuffer">
					<indexterm><primary><varname>cbuffer</varname></primary></indexterm>
					<para>Constructor for circular buffers</para>
					<para><varname>cbuffer(geompoint,float) → cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT cbuffer(ST_Point(1,1), 0.3);
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Transformations</title>
			<itemizedlist>
				<listitem id="cbuffer_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Round the point or the radius of the circular buffer to the number of decimal places</para>
					<para><varname>round(cbuffer,integer=0) → cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(round(cbuffer(ST_Point(1.123456789,1.123456789), 0.123456789), 6));
-- Cbuffer(POINT(1.123457 1.123457),0.123457)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_accessors">
			<title>Accessors</title>

			<itemizedlist>
				<listitem id="point">
					<indexterm><primary><varname>point</varname></primary></indexterm>
					<para>Return the point</para>
					<para><varname>point(cbuffer) → geompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(point(cbuffer 'Cbuffer(Point(1 1), 0.3)'));
-- Point(1 1)
</programlisting>
				</listitem>

				<listitem id="radius">
					<indexterm><primary><varname>radius</varname></primary></indexterm>
					<para>Return the radius</para>
					<para><varname>radius(cbuffer) → float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT radius(cbuffer 'Cbuffer(Point(1 1), 0.3)');
-- 0.3
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_spatial_functions">
			<title>Spatial Operations</title>

			<itemizedlist>
				<listitem id="cbuffer_srid">
					<indexterm><primary><varname>SRID</varname></primary></indexterm>
					<para>Return the spatial reference identifier</para>
					<para><varname>srid(cbuffer) → integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT SRID(cbuffer 'Cbuffer(SRID=5676;Point(1 1), 0.3)');
-- 5676
</programlisting>
				</listitem>

				<listitem id="cbuffer_setSRID">
					<indexterm><primary><varname>setSRID</varname></primary></indexterm>
					<para>TODO Set the spatial reference identifier</para>
				<para><varname>setSRID(cbuffer) → cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(setSRID(cbuffer 'CBuffer(Point(0 0),1)', 4326));
-- SRID=4326;CBuffer(POINT(0 0),1)
</programlisting>
				</listitem>

				<listitem id="cbuffer_transform">
					<indexterm><primary><varname>transform</varname></primary></indexterm>
					<indexterm><primary><varname>transformPipeline</varname></primary></indexterm>
					<para>TODO Transform to a different spatial reference</para>
					<para><varname>transform(cbuffer,integer) → cbuffer</varname></para>
					<para><varname>transform(cbuffer,pipeline text,to_srid integer,is_forward bool=true) → cbuffer</varname></para>
					<para>The <varname>transform</varname> function specifies the transformation with a target SRID. An error is raised when the input circular buffer has an unknown SRID (represented by 0).</para>
					<para>The <varname>transformPipeline</varname> function specifies the transformation with a defined coordinate transformation pipeline represented with the following string format: <varname>urn:ogc:def:coordinateOperation:AUTHORITY::CODE</varname>. The SRID of the input circular buffer is ignored, and the SRID of the output circular buffer will be set to zero unless a value is provided via the optional <varname>to_srid</varname> parameter. As stated by the last parameter, the pipeline is executed by default in a forward direction; by setting the parameter to false, the pipeline is executed in the inverse direction.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(transform(cbuffer 'SRID=4326;CBuffer(Point(4.35 50.85)', 3812));
-- SRID=3812;CBuffer(POINT(648679.018035303 671067.055638114),2)
</programlisting>
					<programlisting language="sql" xml:space="preserve">
WITH test(cbuffer, pipeline) AS (
  SELECT cbuffer 'CBuffer(SRID=4326;Point(4.3525 50.846667),1)',
    text 'urn:ogc:def:coordinateOperation:EPSG::16031' )
SELECT asEWKT(transformPipeline(transformPipeline(cbuffer, pipeline, 4326),
  pipeline, 4326, false), 6)
FROM test;
-- SRID=4326;CBuffer(POINT(4.3525 50.846667),1)
</programlisting>
				</listitem>
			</itemizedlist>

			<para>Values of the <varname>cbuffer</varname> type can be converted to the <varname>geometry</varname> type using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation as shown next.</para>
			<itemizedlist>
				<listitem id="cbuffer_geometry">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convert a circular buffer to a geometry</para>
					<para><varname>cbuffer::geometry</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(cbuffer(ST_Point(1,1), 1)::geometry);
--  CURVEPOLYGON(CIRCULARSTRING(0 0,2 2,0 0))
</programlisting>
				</listitem>
			</itemizedlist>

			<para>Similarly, a <varname>geometry</varname> that define a circle can be converted to a <varname>cbuffer</varname> values using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation. For this, the geometry must be a curve polygon with three points. If this is not the case, an error is returned.</para>
			<itemizedlist>
				<listitem id="geometry_cbufarr">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convert a geometry to a circular buffer</para>
					<para><varname>geometry::cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(geometry 'SRID=5676;CURVEPOLYGON(CIRCULARSTRING(0 0,2 2,0 0))'::cbuffer);
-- Cbuffer(POINT(1 1),1)
SELECT asText(geometry 'SRID=5676;CIRCULARSTRING(0 0,2 2,0 0)'::cbuffer);
-- Only circle geometries accepted
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_static_operators">
			<title>Comparisons</title>

			<para>The comparison operators (=, &lt;, and so on) are available for circular buffers. They compare first the points and then the radius of the arguments. Excepted the equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on circular buffers.</para>

			<itemizedlist>
				<listitem id="cbuffer_comparisons">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para><varname>cbuffer = cbuffer</varname></para>
					<para><varname>cbuffer &lt;&gt; cbuffer</varname></para>
					<para><varname>cbuffer &lt; cbuffer</varname></para>
					<para><varname>cbuffer &gt; cbuffer</varname></para>
					<para><varname>cbuffer &lt;= cbuffer</varname></para>
					<para><varname>cbuffer &gt;= cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT cbuffer 'Cbuffer(Point(3 3), 0.5)' = cbuffer 'Cbuffer(Point(3 3), 0.5)';
-- true
SELECT cbuffer 'Cbuffer(Point(3 3), 0.5)' &lt;&gt; cbuffer 'Cbuffer(Point(3 3), 0.6)';
-- true
SELECT cbuffer 'Cbuffer(Point(3 3), 0.5)' &lt; cbuffer 'Cbuffer(Point(3 3), 0.6)';
-- true
SELECT cbuffer 'Cbuffer(Point(3 3), 0.6)' > cbuffer 'Cbuffer(Point(2 2), 0.6)';
-- true
SELECT cbuffer 'Cbuffer(Point(1 1), 0.5)' &lt;= cbuffer 'Cbuffer(Point(2 2), 0.5)';
-- true
SELECT cbuffer 'Cbuffer(Point(1 1), 0.6)' &gt;= cbuffer 'Cbuffer(Point(1 1), 0.5)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id="temp_circular_buffers">
		<title>Temporal Circular Buffers</title>

		<para>The temporal circular buffer type <varname>tcbuffer</varname> allows to represent the movement of objects together with a circular radius around them. It corresponds to the temporal point type <varname>tgeompoint</varname> restricted to two-dimensional coordinates. As all the other temporal types it comes in trhee subtypes, namely, instant, sequence, and sequence set. Examples of <varname>tcbuffer</varname> values in these subtypes are given next.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01';
SELECT tcbuffer '{Cbuffer(Point(1 1), 0.3)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-02,
  Cbuffer(Point(1 1), 0.5)@2001-01-03}';
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, Cbuffer(Point(1 1), 0.4)@2001-01-02,
  Cbuffer(Point(1 1), 0.5)@2001-01-03]';
SELECT tcbuffer '{[Cbuffer(Point(1 1), 1)@2001-01-01, Cbuffer(Point(2 2), 1)@2001-01-02],
  [Cbuffer(Point(2 2), 2)@2001-01-04, Cbuffer(Point(2 2), 3)@2001-01-05]}';
</programlisting>
		<para>The temporal circular buffer type accepts type modifiers (or <varname>typmod</varname> in PostgreSQL terminology). The possible values for the type modifier are <varname>Instant</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. If no type modifier is specified for a column, values of any subtype are allowed.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer(Sequence) '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.4)@2001-01-02, Cbuffer(Point(1 1), 0.5)@2001-01-03]';
SELECT tcbuffer(Sequence) 'Cbuffer(Point(1 1), 0.2)@2001-01-01';
-- ERROR: Temporal type (Instant) does not match column type (Sequence)
</programlisting>

		<para>Temporal circular buffer values of sequence or sequence set subtype are converted into a normal form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. Three consecutive instant values can be merged into two if the linear functions defining the evolution of values are the same. Examples of transformation into a normal form are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01,
  Cbuffer(Point(2 2), 0.4)@2001-01-02, Cbuffer(Point(3 3), 0.6)@2001-01-03)');
-- [Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(3 3),0.6)@2001-01-03)
SELECT asText(tcbuffer '{[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(2 2), 0.3)@2001-01-02, Cbuffer(Point(2 2), 0.5)@2001-01-03), 
  [Cbuffer(Point(2 2), 0.5)@2001-01-03, Cbuffer(Point(2 2), 0.7)@2001-01-04)}');
/* {[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(2 2),0.3)@2001-01-02, 
   Cbuffer(Point(2 2),0.7)@2001-01-04)} */
</programlisting>
	</sect1>

	<sect1 id="temporal_circular_buffers_validity">
		<title>Validity of Temporal Circular Buffers</title>

		<para>Temporal circular buffer values must satisfy the constraints specified in <xref linkend="temporal_types_validity" /> so that they are well defined. An error is raised whenever one of these constraints are not satisfied. Examples of incorrect values are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
-- Null values are not allowed
SELECT tcbuffer 'NULL@2001-01-01 08:05:00';
SELECT tcbuffer 'Point(0 0)@NULL';
-- Base type is not a circular buffer
SELECT tcbuffer 'Point(0 0)@2001-01-01 08:05:00';
</programlisting>
	</sect1>

	<sect1 id="tcbuffer_inout">
		<title>Input and Output</title>

		<itemizedlist>
			<listitem id="tcbuffer_asText">
				<indexterm><primary><varname>asText</varname></primary></indexterm>
				<para>Return the Well-Known Text (WKT) representation</para>
				<para><varname>asText({tcbuffer,tcbuffer[],cbuffer[]}) → {text,text[]}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbuffer 'SRID=4326;[CBuffer(Point(0 0),1)@2001-01-01, 
  CBuffer(Point(1 1),2)@2001-01-02)');
-- [CBuffer(Point(0 0),1)@2001-01-01, CBuffer(Point(1 1),2)@2001-01-02)
SELECT asText(ARRAY[cbuffer 'CBuffer(Point(0 0),1)', 'CBuffer(Point(1 1),2)']);
-- {"CBuffer(POINT(0 0),1)","CBuffer(POINT(1 1),2)"}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_asEWKT">
				<indexterm><primary><varname>asEWKT</varname></primary></indexterm>
				<para>Return the Extended Well-Known Text (EWKT) representation</para>
				<para><varname>asEWKT({tcbuffer,tcbuffer[],cbuffer[]}) → {text,text[]}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbuffer 'SRID=4326;[CBuffer(Point(0 0),1)@2001-01-01, 
  CBuffer(Point(1 1),2)@2001-01-02)');
-- SRID=4326;[CBuffer(Point(0 0),1)@2001-01-01, CBuffer(Point(1 1),2)@2001-01-02)
SELECT asEWKT(ARRAY[cbuffer 'CBuffer(SRID=5676;Point(0 0),1)', 
  'CBuffer(SRID=5676;Point(1 1),2)']);
-- {"CBuffer(SRID=5676;POINT(0 0),1)","CBuffer(SRID=5676;POINT(1 1),2))"}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_asMFJSON">
				<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>TODO Return the Moving Features JSON representation</para>
				<para><varname>asMFJSON(tcbuffer,options=0,flags=0,maxdecdigits=15) → bytea</varname></para>
				<para>The <varname>options</varname> argument can be used to add BBOX and/or CRS in MFJSON output:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: MFJSON BBOX</para></listitem>
					<listitem><para>2: MFJSON Short CRS (e.g., EPSG:4326)</para></listitem>
					<listitem><para>4: MFJSON Long CRS (e.g., urn:ogc:def:crs:EPSG::4326)</para></listitem>
				</itemizedlist>
				<para>The <varname>flags</varname> argument can be used to customize the JSON output, for example, to produce an easy-to-read (for human readers) JSON output. Refer to the documentation of the <varname>json-c</varname> library for the possible values. Typical values are as follows:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: JSON_C_TO_STRING_SPACED</para></listitem>
					<listitem><para>2: JSON_C_TO_STRING_PRETTY</para></listitem>
				</itemizedlist>
				<para>The <varname>maxdecdigits</varname> argument can be used to set the maximum number of decimal places in the output of floating point values (default 15).</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asMFJSON(tcbuffer 'CBuffer(Point(1 2),1)@2019-01-01 18:00:00.15+02');
/* {"type":"MovingPoint","coordinates":[[1,2]],"datetimes":["2019-01-01T17:00:00.15+01"],
   "interpolation":"None"} */
SELECT asMFJSON(tcbuffer 'SRID=4326;
  Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 3, 2);
/* {"type":"MovingPoint","crs":{"type":"name","properties":{"name":"EPSG:4326"}},
   "stBoundedBy":{"bbox":[50.81,4.38,50.81,4.38],
   "period":{"begin":"2019-01-01 17:00:00.15+01","end":"2019-01-01 17:00:00.15+01"}},
   "coordinates":[[50.81,4.38]],"datetimes":["2019-01-01T17:00:00.15+01"],
   "interpolations":"None"} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_asBinary">
				<indexterm><primary><varname>asBinary</varname></primary></indexterm>
				<para>Return the Well-Known Binary (WKB) representation</para>
				<para><varname>asBinary(tcbuffer,endian text='') → bytea</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asBinary(tcbuffer 'CBuffer(Point(1 2),1)@2001-01-01');
-- \x012e0011000000000000f03f00000000000000400000000000000840009c57d3c11c0000
</programlisting>
			</listitem>

			<listitem id="tcbuffer_asEWKB">
				<indexterm><primary><varname>asEWKB</varname></primary></indexterm>
				<para>Return the Extended Well-Known Binary (EWKB) representation</para>
				<para><varname>asEWKB(tcbuffer,endian text='') → bytea</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKB(tcbuffer 'SRID=7844;CBuffer(Point(1 2),1)@2001-01-01');
-- \x012f0071a41e0000000000000000f03f00000000000000400000000000000840009c57d3c11c0000
</programlisting>
			</listitem>

			<listitem id="tcbuffer_asHexEWKB">
				<indexterm><primary><varname>asHexEWKB</varname></primary></indexterm>
				<para>Return the Hexadecimal Extended Well-Known Binary (EWKB) representation as text</para>
				<para><varname>asHexEWKB(tcbuffer,endian text='') → text</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asHexEWKB(tcbuffer 'SRID=3812;CBuffer(Point(1 2),1)@2001-01-01');
-- 012E0051E40E0000000000000000F03F00000000000000400000000000000840009C57D3C11C0000
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcbufferFromText">
				<indexterm><primary><varname>tcbufferFromText</varname></primary></indexterm>
				<para>Input a temporal point from its Well-Known Text (WKT) representation</para>
				<para><varname>tcbufferFromText(text) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromText(text '[CBuffer(Point(1 2),1)@2001-01-01, 
  CBuffer(Point(3 4),2)@2001-01-02]'));
-- [CBuffer(POINT(1 2),1)@2001-01-01, CBuffer(POINT(3 4),2)@2001-01-02]
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcbufferFromEWKT">
				<indexterm><primary><varname>tcbufferFromEWKT</varname></primary></indexterm>
				<para>Input a temporal point from its Extended Well-Known Text (EWKT) representation</para>
				<para><varname>tcbufferFromEWKT(text) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromEWKT(text 'SRID=3812;[CBuffer(Point(1 2),1)@2001-01-01,
  CBuffer(Point(3 4),2)@2001-01-02]'));
-- SRID=3812;[CBuffer(Point(1 2),1)@2001-01-01, CBuffer(Point(3 4),2)@2001-01-02]
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcbufferFromMFJSON">
				<indexterm><primary><varname>tcbufferFromMFJSON</varname></primary></indexterm>
				<para>TODO Input a temporal point from its Moving Features JSON representation</para>
				<para><varname>tcbufferFromMFJSON(text) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
  "properties":{"name":"EPSG:4326"}},"coordinates":[[50.81,4.38]],
  "datetimes":["2019-01-01T17:00:00.15+01"],"interpolation":"None"}'));
-- SRID=4326;Cbuffer(POINT(50.81 4.38),1)@2019-01-01 17:00:00.15+01
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcbufferFromBinary">
				<indexterm><primary><varname>tcbufferFromBinary</varname></primary></indexterm>
				<para>Input a temporal point from its Well-Known Binary (WKB) representation</para>
				<para><varname>tcbufferFromBinary(bytea) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromBinary(
  '\x012e0011000000000000f03f00000000000000400000000000000840009c57d3c11c0000'));
-- Cbuffer(POINT(1 2),1)@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcbufferFromEWKB">
				<indexterm><primary><varname>tcbufferFromEWKB</varname></primary></indexterm>
				<para>Input a temporal point from its Extended Well-Known Binary (EWKB) representation</para>
				<para><varname>tcbufferFromEWKB(bytea) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromEWKB(
  '\x012f0071a41e0000000000000000f03f00000000000000400000000000000840009c57d3c11c0000'));
-- SRID=7844;CBuffer(Point(1 1),2)@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcbufferFromHexEWKB">
				<indexterm><primary><varname>tcbufferFromHexEWKB</varname></primary></indexterm>
				<para>Input a temporal point from its Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para><varname>tcbufferFromHexEWKB(text) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromHexEWKB(
  '012E0051E40E0000000000000000F03F00000000000000400000000000000840009C57D3C11C0000'));
-- SRID=3812;CBuffer(POINT(1 2),1)@2001-01-01
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_constructors">
		<title>Constructors</title>

		<itemizedlist>
			<listitem id="tcbuffer_const">
				<indexterm><primary><varname>tcbuffer</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferSeq</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferSeqSet</varname></primary></indexterm>
				<para>Constructor for temporal circular buffers having a constant value</para>
				<para><varname>tcbuffer(cbuffer,timestamptz) → tcbufferInst</varname></para>
				<para><varname>tcbuffer(cbuffer,tstzset) → tcbufferDiscSeq</varname></para>
				<para><varname>tcbuffer(cbuffer,tstzspan,interp='linear') → tcbufferContSeq</varname></para>
				<para><varname>tcbuffer(cbuffer,tstzspanset,interp='linear') → tcbufferSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.5)', timestamptz '2001-01-01'));
-- Cbuffer(Point(1 1),0.5)@2001-01-01
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.3)', 
  tstzset '{2001-01-01, 2001-01-03, 2001-01-05}'));
/* {Cbuffer(Point(1 1),0.3)@2001-01-01, Cbuffer(Point(1 1),0.3)@2001-01-03, 
   Cbuffer(Point(1 1),0.3)@2001-01-05} */
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.5)', 
  tstzspan '[2001-01-01, 2001-01-02]'));
-- [Cbuffer(Point(1 1),0.5)@2001-01-01, Cbuffer(Point(1 1),0.5)@2001-01-02]
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.2)', 
  tstzspanset '{[2001-01-01, 2001-01-03]}', 'step'));
-- Interp=Step;{[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(1 1),0.2)@2001-01-03]}
</programlisting>
			</listitem>

			<listitem id="tcbufferSeq">
				<indexterm><primary><varname>=</varname></primary></indexterm>
				<para>Constructor for temporal circular buffers of sequence subtype</para>
				<para><varname>tcbufferSeq(tcbufferInst[],interp={'step','linear'},leftInc bool=true,</varname></para>
				<para><varname>  rightInc bool=true) →tcbufferSeq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbufferSeq(ARRAY[tcbuffer 'Cbuffer(Point(1 1), 0.3)@2001-01-01',
  'Cbuffer(Point(2 2), 0.5)@2001-01-02', 'Cbuffer(Point(1 1), 0.5)@2001-01-03']));
/* {Cbuffer(Point(1 1),0.3)@2001-01-01, Cbuffer(Point(2 2),0.5)@2001-01-02, 
   Cbuffer(Point(1 1),0.5)@2001-01-03} */
SELECT asText(tcbufferSeq(ARRAY[tcbuffer 'Cbuffer(Point(1 1), 0.2)@2001-01-01',
  'Cbuffer(Point(1 1), 0.4)@2001-01-02', 'Cbuffer(Point(1 1), 0.5)@2001-01-03']));
/* [Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(1 1),0.4)@2001-01-02, 
   Cbuffer(Point(1 1),0.5)@2001-01-03] */
</programlisting>
			</listitem>

			<listitem id="tcbufferSeqSet">
				<indexterm><primary><varname>tcbufferSeqSet</varname></primary></indexterm>
				<para>Constructor for temporal circular buffers of sequence set subtype</para>
				<para><varname>tcbufferSeqset(tcbuffer[]) → tcbufferSeqSet</varname></para>
				<para><varname>tcbufferSeqSetGaps(tcbufferInst[],maxt=NULL,maxdist=NULL,interp='linear') →</varname></para>
				<para><varname>  tcbufferSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbufferSeqSet(ARRAY[tcbuffer 
  '[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(2 2),0.4)@2001-01-02]', 
  '[Cbuffer(Point(2 2),0.6)@2001-01-03, Cbuffer(Point(2 2),0.8)@2001-01-04]']));
/* {[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(2 2),0.4)@2001-01-02],
   [Cbuffer(Point(2 2),0.6)@2001-01-03, Cbuffer(Point(2 2),0.6)@2001-01-04]} */
SELECT asText(tcbufferSeqSetGaps(ARRAY[tcbuffer 'Cbuffer(Point(1 1),0.1)@2001-01-01',
  'Cbuffer(Point(1 1),0.3)@2001-01-03', 'Cbuffer(Point(1 1),0.5)@2001-01-05'], '1 day'));
/* {[Cbuffer(Point(1 1),0.1)@2001-01-01], [Cbuffer(Point(1 1),0.3)@2001-01-03], 
   [Cbuffer(Point(1 1),0.5)@2001-01-05]} */
</programlisting>
			</listitem>

			<listitem id="tgeompoint_tcbuffer">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>TODO Construct a temporal circular buffer from a temporal geometry point and a temporal float</para>
				<para><varname>tcbuffer(tgeompoint, tfloat) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[POINT(23.057077727326 28.7666335767956)@2001-01-01,
  POINT(48.7117553116406 20.9256801894708)@2001-01-02)'::tcbuffer
-- [Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(1 1),0.3)@2001-01-02)
SELECT tgeompoint '[POINT(23.057077727326 28.7666335767956)@2001-01-01,
  POINT(48.7117553116406 20.9)@2001-01-02)'::tcbuffer
-- NULL
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_conversions">
		<title>Conversions</title>

		<para>A temporal circular buffer value can be converted to and from a temporal geometry point. This can be done using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation. A null value is returned if any of the composing geometry point values cannot be converted into a <varname>cbuffer</varname> value.</para>
		<itemizedlist>
			<listitem id="tcbuffer_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convert a temporal circular buffer to a temporal geometry point</para>
				<para><varname>tcbuffer::tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01,
  Cbuffer(Point(1 1), 0.3)@2001-01-02)')::tgeompoint);
-- [POINT(1 1)@2001-01-01, POINT(1 1)@2001-01-02)
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tfloat">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convert a temporal circular buffer to a temporal float</para>
				<para><varname>tcbuffer::tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT (tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01,
  Cbuffer(Point(1 1), 0.3)@2001-01-02)')::tfloat;
-- [0.2@2001-01-01, 0.3@2001-01-02)
</programlisting>
			</listitem>
		</itemizedlist>
		<para>We give next the functions and operators for circular buffer types.</para>
	</sect1>

	<sect1 id="temporal_circular_buffers_ops">
		<title>Operations</title>

		<para>Most functions for temporal types described in the previous chapters can be applied for temporal circular buffer types. Therefore, in the signatures of the functions, the notation <varname>base</varname> represents a <varname>cbuffer</varname> and the notations <varname>ttype</varname>, <varname>tpoint</varname>, and <varname>tgeompoint</varname> also represent a <varname>tcbuffer</varname>. Furthermore, the functions that have an argument of type <varname>geometry</varname> accept in addition an argument of type <varname>cbuffer</varname>. To avoid redundancy, we only present next some examples of these functions and operators for temporal circular buffers.</para>

		<itemizedlist>
			<listitem id="tcbuffer_subtype">
				<indexterm><primary><varname>tcbufferInst</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferSeq</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferSeqSet</varname></primary></indexterm>
				<para>Transform a temporal circular buffer to another subtype</para>
				<para><varname>tcbufferInst(tcbuffer) → tcbufferInst</varname></para>
				<para><varname>tcbufferSeq(tcbuffer) → tcbufferSeq</varname></para>
				<para><varname>tcbufferSeqSet(tcbuffer) → tcbufferSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbufferSeq(tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01', 'discrete'));
-- {Cbuffer(Point(1 1),0.5)@2001-01-01}
SELECT asText(tcbufferSeq(tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01'));
-- [Cbuffer(Point(1 1),0.5)@2001-01-01]
SELECT asText(tcbufferSeqSet(tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01'));
-- {[Cbuffer(Point(1 1),0.5)@2001-01-01]}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_setInterp">
				<indexterm><primary><varname>setInterp</varname></primary></indexterm>
				<para>Transform a temporal circular buffer to another interpolation</para>
				<para><varname>setInterp(tcbuffer, interp) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(setInterp(tcbuffer 'Cbuffer(Point(1 1),0.2)@2001-01-01','linear'));
-- [Cbuffer(Point(1 1),0.2)@2001-01-01]
SELECT asText(setInterp(tcbuffer '{[Cbuffer(Point(1 1),0.1)@2001-01-01], 
  [Cbuffer(Point(1 1),0.2)@2001-01-02]}', 'discrete'));
-- {Cbuffer(Point(1 1),0.1)@2001-01-01, Cbuffer(Point(1 1),0.2)@2001-01-02}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Round the fraction of the temporal circular buffer to the number of decimal places</para>
				<para><varname>round(tcbuffer,integer) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(round(tcbuffer '{[Cbuffer(Point(1 1),0.123456789)@2001-01-01, 
  Cbuffer(Point(1 1),0.5)@2001-01-02)}', 6));
/* {[Cbuffer(Point(1 1),0.123457)@2001-01-01, Cbuffer(Point(1 1),0.5)@2001-01-02)} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_getValues">
				<indexterm><primary><varname>getValues</varname></primary></indexterm>
				<para>Return the values</para>
				<para><varname>getValues(tcbuffer) → cbufferset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(getValues(tcbuffer '{[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02)}'));
-- {"Cbuffer(Point(1 1),0.3)","Cbuffer(Point(1 1),0.5)"}
SELECT asText(getValues(tcbuffer '{[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-02)}'));
-- {"Cbuffer(Point(1 1),0.3)"}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_points">
				<indexterm><primary><varname>points</varname></primary></indexterm>
				<para>Return the points</para>
				<para><varname>points(tcbuffer) → bigintset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(points(tcbuffer '{Cbuffer(Point(3 3), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02}'));
-- {Point(1 1), Point(3 3)}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_valueAtTimestamp">
				<indexterm><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Return the value at a timestamp</para>
				<para><varname>valueAtTimestamp(tcbuffer,timestamptz) → cbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(valueAtTimestamp(tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(3 3), 0.5)@2001-01-03)', '2001-01-02'));
-- Cbuffer(Point(2 2),0.4)
</programlisting>
			</listitem>

			<listitem id="tcbuffer_setSRID">
				<indexterm><primary><varname>setSRID</varname></primary></indexterm>
				<para>TODO Set the spatial reference identifier</para>
				<para><varname>setSRID(tcbuffer) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(setSRID(tcbuffer '[CBuffer(Point(0 0),1)@2001-01-01, CBuffer(Point(1 1),2)@2001-01-02)', 4326));
-- SRID=4326;[CBuffer(POINT(0 0),1)@2001-01-01, CBuffer(POINT(1 1),2)@2001-01-02)
</programlisting>
				</listitem>

			<listitem id="tcbuffer_transform">
				<indexterm><primary><varname>transform</varname></primary></indexterm>
				<indexterm><primary><varname>transformPipeline</varname></primary></indexterm>
				<para>TODO Transform to a different spatial reference</para>
				<para><varname>transform(tcbuffer,integer) → tcbuffer</varname></para>
				<para><varname>transform(tcbuffer,pipeline text,to_srid integer,is_forward bool=true) → tcbuffer</varname></para>
				<para>The <varname>transform</varname> function specifies the transformation with a target SRID. An error is raised when the input temporal circular buffer has an unknown SRID (represented by 0).</para>
				<para>The <varname>transformPipeline</varname> function specifies the transformation with a defined coordinate transformation pipeline represented with the following string format: <varname>urn:ogc:def:coordinateOperation:AUTHORITY::CODE</varname>. The SRID of the input temporal circular buffer is ignored, and the SRID of the output temporal circular buffer will be set to zero unless a value is provided via the optional <varname>to_srid</varname> parameter. As stated by the last parameter, the pipeline is executed by default in a forward direction; by setting the parameter to false, the pipeline is executed in the inverse direction.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(transform(tcbuffer 'SRID=4326;CBuffer(Point(4.35 50.85),1)@2001-01-01', 
  3812));
-- SRID=3812;CBuffer(POINT(648679.018035303 671067.055638114),2)@2001-01-01
</programlisting>
				<programlisting language="sql" xml:space="preserve">
WITH test(tcbuffer, pipeline) AS (
  SELECT tcbuffer 'SRID=4326;{CBuffer(Point(4.3525 50.846667),1)@2001-01-01,
    CBuffer(Point(-0.1275 51.507222),2)@2001-01-02}',
    text 'urn:ogc:def:coordinateOperation:EPSG::16031' )
SELECT asEWKT(transformPipeline(transformPipeline(tcbuffer, pipeline, 4326),
  pipeline, 4326, false), 6)
FROM test;
/* SRID=4326;{CBuffer(POINT(4.3525 50.846667),1)@2001-01-01,
   CBuffer(POINT(-0.1275 51.507222 100),2)@2001-01-02} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_traversedArea">
				<indexterm><primary><varname>traversedArea</varname></primary></indexterm>
				<para>TODO Return the area traversed by the temporal circular buffer</para>
				<para><varname>traversedArea(tcbuffer) → geometry</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT traversedArea(tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]');
-- 54.3757408468784
</programlisting>
			</listitem>

			<listitem id="tcbuffer_stbox">
				<indexterm><primary><varname>stbox</varname></primary></indexterm>
				<para>Construct the bounding box from a cbuffer and, optionally, a timestamp or a period</para>
				<para><varname>stbox(cbuffer) → stbox</varname></para>
				<para><varname>stbox(cbuffer,{timestamptz,tstzspan}) → stbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT stbox(cbuffer 'Cbuffer(Point(1 1),0.3)');
-- STBOX X((0.7,0.7),(1.3,1.3))
SELECT stbox(cbuffer 'Cbuffer(Point(1 1),0.3)', timestamptz '2001-01-01');
-- STBOX XT(((0.7,0.7),(1.3,1.3)),[2001-01-01, 2001-01-01])
SELECT stbox(cbuffer 'Cbuffer(Point(1 1),0.3)', tstzspan '[2001-01-01,2001-01-02]');
-- STBOX XT(((0.7,0.7),(1.3,1.3)),[2001-01-01 00:00:00+01, 2001-01-02 00:00:00+01])
</programlisting>
			</listitem>

			<listitem id="tcbuffer_nearestApproachInstant">
				<indexterm><primary><varname>nearestApproachInstant</varname></primary></indexterm>
				<para>TODO Return the instant of the first temporal circular buffer at which the two arguments are at the nearest distance </para>
				<para><varname>nearestApproachInstant({geo,cbuffer,tpoint},{geo,cbuffer,tpoint}) → tpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT nearestApproachInstant(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)');
-- Cbuffer(Point(2 2),0.349928)@2001-01-01 02:59:44.402905+01
SELECT nearestApproachInstant(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', cbuffer 'Cbuffer(Point(1 1), 0.5)');
-- Cbuffer(Point(2 2),0.592181)@2001-01-01 17:31:51.080405+01
</programlisting>
			</listitem>

			<listitem id="tcbuffer_nearestApproachDistance">
				<indexterm><primary><varname>nearestApproachDistance</varname></primary></indexterm>
				<para>TODO Return the smallest distance ever between the two arguments</para>
				<para><varname>nearestApproachDistance({geo,cbuffer,tpoint},{geo,cbuffer,tpoint}) → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT nearestApproachDistance(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)');
-- 1.41793220500979
SELECT nearestApproachDistance(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', cbuffer 'Cbuffer(Point(1 1), 0.5)');
-- Cbuffer(Point(2 2),0.592181)@2001-01-01 17:31:51.080405+01
</programlisting>
				<para>Function <varname>nearestApproachDistance</varname> has an associated operator <varname>|=|</varname> that can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="temporal_types_indexing" />).</para>
			</listitem>

			<listitem id="tcbuffer_shortestLine">
				<indexterm><primary><varname>shortestLine</varname></primary></indexterm>
				<para>TODO Return the line connecting the nearest approach point between the two arguments</para>
				<para><varname>shortestLine({geo,cbuffer,tpoint},{geo,cbuffer,tpoint}) → geometry</varname></para>
				<para>The function will only return the first line that it finds if there are more than one</para>
				<programlisting language="sql" xml:space="preserve">
SELECT st_astext(shortestLine(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)'));
-- LINESTRING(50.7960725266492 48.8266286733015,50 50)
SELECT st_astext(shortestLine(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', cbuffer 'Cbuffer(Point(1 1), 0.5)'));
-- LINESTRING(77.0902838115125 66.6659083092593,90.8134936900394 46.4385792121146)
</programlisting>
			</listitem>

			<listitem id="tcbuffer_atValue">
				<indexterm><primary><varname>atValue</varname></primary></indexterm>
				<indexterm><primary><varname>minusValue</varname></primary></indexterm>
				<para>TODO Restrict to (the complement of) a value</para>
				<para><varname>atValue(tcbuffer,base) → tcbuffer</varname></para>
				<para><varname>minusValue(tcbuffer,base) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atValue(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]', 'Cbuffer(Point(2 2), 0.5)');
-- {[Cbuffer(Point(2 2),0.5)@2001-01-02]}
SELECT minusValue(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]', 'Cbuffer(Point(2 2), 0.5)');
/* {[Cbuffer(Point(2 2),0.3)@2001-01-01, Cbuffer(Point(2 2),0.5)@2001-01-02),
   (Cbuffer(Point(2 2),0.5)@2001-01-02, Cbuffer(Point(2 2),0.7)@2001-01-03]} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_atGeometry">
				<indexterm><primary><varname>atGeometry</varname></primary></indexterm>
				<indexterm><primary><varname>minusGeometry</varname></primary></indexterm>
				<para>TODO Restrict to a geometry</para>
				<para><varname>atGeometry(tcbuffer,geometry) → tcbuffer</varname></para>
				<para><varname>minusGeometry(tcbuffer,geometry) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atGeometry(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]',
  'Polygon((40 40,40 50,50 50,50 40,40 40))');
SELECT minusGeometry(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]',
  'Polygon((40 40,40 50,50 50,50 40,40 40))');
/* {(Cbuffer(Point(2 2),0.342593)@2001-01-01 05:06:40.364673+01,
   Cbuffer(Point(2 2),0.7)@2001-01-03 00:00:00+01]} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_comp">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Traditional comparison operators</para>
				<para><varname>tcbuffer = tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;= tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &gt;= tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '{[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-02),
  [Cbuffer(Point(1 1), 0.3)@2001-01-02, Cbuffer(Point(1 1), 0.5)@2001-01-03]}' =
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-03]';
-- true
SELECT tcbuffer '{[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]}' &lt;&gt;
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-03]';
-- false
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.6)@2001-01-03]';
-- true
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcomp">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Temporal comparison operators</para>
				<para><varname>tcbuffer #= tcbuffer → tbool</varname></para>
				<para><varname>tcbuffer #&lt;&gt; tcbuffer → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.4)@2001-01-03)' #= cbuffer 'Cbuffer(Point(1 1), 0.3)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.8)@2001-01-03)' #&lt;&gt;
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, Cbuffer(Point(1 1), 0.7)@2001-01-03)';
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_ever_always">
				<indexterm><primary><varname>?=</varname></primary></indexterm>
				<indexterm><primary><varname>%=</varname></primary></indexterm>
				<para>Ever and always equal operators</para>
				<para><varname>tcbuffer ?= tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer %= tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.4)@2001-01-04)' ?= Cbuffer(Point(1 1), 0.3);
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.2)@2001-01-04)' &amp;= Cbuffer(Point(1 1), 0.2);
-- true
</programlisting>
			</listitem>

			<listitem id="tcbuffer_pos">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Position operators</para>
				<para><varname>tcbuffer &lt;&lt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&lt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &gt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;&lt;| tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&lt;| tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer |&gt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer |&amp;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;&lt;# tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&lt;# tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer #&gt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer #&amp;&gt; tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &lt;&lt; cbuffer 'Cbuffer(Point(1 1), 0.2)'
-- false
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &lt;&lt;| stbox(cbuffer 'Cbuffer(Point(1 1), 0.5)')
-- false
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &amp;&gt; cbuffer 'Cbuffer(Point(1 1), 0.3)'::geometry
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &gt;&gt;#
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-03, Cbuffer(Point(1 1), 0.5)@2001-01-05]'
-- true
</programlisting>
			</listitem>

			<listitem id="tcbuffer_topo">
				<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
				<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
				<indexterm><primary><varname>~=</varname></primary></indexterm>
				<indexterm><primary><varname>-|-</varname></primary></indexterm>
				<para>Topological operators</para>
				<para><varname>tcbuffer &amp;&amp; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;@ tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer @&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer ~= tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer -|- tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &amp;&amp; cbuffer 'Cbuffer(Point(1 1), 0.5)'
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' @&gt; stbox(cbuffer 'Cbuffer(Point(1 1), 0.5)')
-- true
SELECT cbuffer 'Cbuffer(Point(1 1), 0.5)'::geometry &lt;@
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-02]'
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' ~= tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.35)@2001-01-02, Cbuffer(Point(1 1), 0.5)@2001-01-03]'
-- true
</programlisting>
			</listitem>

			<listitem id="tcbuffer_smallestDistance">
				<indexterm><primary><varname>|=|</varname></primary></indexterm>
				<para>TODO Return the smallest distance ever between the two arguments</para>
				<para><varname>tgeompoint |=| tcbuffer → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' |=| cbuffer 'Cbuffer(Point(1 1), 0.2)';
-- 2.34988300875063
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' |=| geometry 'Linestring(2 2,2 1,3 1)';
-- 82.2059262761477
</programlisting>
			</listitem>

			<listitem id="tcbuffer_distance">
				<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
				<para>TODO Return the temporal distance</para>
				<para><varname>tgeompoint &lt;-&gt; tcbuffer → tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;-&gt; cbuffer 'Cbuffer(Point(1 1), 0.2)';
-- [2.34988300875063@2001-01-02 00:00:00+01, 2.34988300875063@2001-01-03 00:00:00+01]
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;-&gt; geometry 'Point(50 50)';
-- [25.0496666945044@2001-01-01 00:00:00+01, 26.4085688426232@2001-01-03 00:00:00+01]
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;-&gt;
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-02, Cbuffer(Point(1 1), 0.5)@2001-01-04]'
-- [2.34988300875063@2001-01-02 00:00:00+01, 2.34988300875063@2001-01-03 00:00:00+01]
</programlisting>
			</listitem>

			<listitem id="tcbuffer_espatialrels">
				<indexterm><primary><varname>eContains</varname></primary></indexterm>
				<indexterm><primary><varname>aContains</varname></primary></indexterm>
				<indexterm><primary><varname>eDisjoint</varname></primary></indexterm>
				<indexterm><primary><varname>aDisjoint</varname></primary></indexterm>
				<indexterm><primary><varname>eIntersects</varname></primary></indexterm>
				<indexterm><primary><varname>aIntersects</varname></primary></indexterm>
				<indexterm><primary><varname>eTouches</varname></primary></indexterm>
				<indexterm><primary><varname>aTouches</varname></primary></indexterm>
				<indexterm><primary><varname>eDwithin</varname></primary></indexterm>
				<indexterm><primary><varname>aDwithin</varname></primary></indexterm>
				<para>TODO Ever and always spatial relationships</para>
				<para><varname>eContains(geometry,tcbuffer) → boolean</varname></para>
				<para><varname>aContains(geometry,tcbuffer) → boolean</varname></para>
				<para><varname>eDisjoint({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>aDisjoint({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>eIntersects({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>aIntersects({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>eTouches({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>aTouches({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>eDwithin({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer},float) → boolean</varname></para>
				<para><varname>aDwithin({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer},float) → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT eContains(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.3)@2001-01-03)');
-- false
SELECT eDisjoint(cbuffer 'Cbuffer(Point(2 2), 0.0)',
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.3)@2001-01-03)');
-- true
SELECT eIntersects(tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-03)',
  tcbuffer '[Cbuffer(Point(2 2), 0.0)@2001-01-01, Cbuffer(Point(2 2), 1)@2001-01-03)');
-- false
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tspatialrels">
				<indexterm><primary><varname>tContains</varname></primary></indexterm>
				<indexterm><primary><varname>tDisjoint</varname></primary></indexterm>
				<indexterm><primary><varname>tIntersects</varname></primary></indexterm>
				<indexterm><primary><varname>tTouches</varname></primary></indexterm>
				<indexterm><primary><varname>tDwithin</varname></primary></indexterm>
				<para>TODO Temporal spatial relationships</para>
				<para><varname>tContains(geometry,tcbuffer) → boolean</varname></para>
				<para><varname>tDisjoint({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>tIntersects({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>tTouches({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>tDwithin({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer},float) → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tDisjoint(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.3)@2001-01-03)');
-- {[t@2001-01-01 00:00:00+01, t@2001-01-03 00:00:00+01)}
SELECT tDwithin(tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03)', tcbuffer '[Cbuffer(Point(1 1), 0.5)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-03)', 1);
/* {[t@2001-01-01 00:00:00+01, t@2001-01-01 22:35:55.379053+01],
   (f@2001-01-01 22:35:55.379053+01, t@2001-01-02 01:24:04.620946+01,
   t@2001-01-03 00:00:00+01)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_aggregations">
		<title>Aggregations</title>

		<para>The three aggregate functions for temporal circular buffers are illustrated next.</para>

		<itemizedlist>
			<listitem id="tcbuffer_tCount">
				<indexterm><primary><varname>tCount</varname></primary></indexterm>
				<para>Temporal count</para>
				<para><varname>tCount(tcbuffer) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
    Cbuffer(Point(1 1), 0.3)@2001-01-03)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-02, 
    Cbuffer(Point(1 1), 0.4)@2001-01-04)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-03, 
    Cbuffer(Point(1 1), 0.5)@2001-01-05)' )
SELECT tCount(Temp)
FROM Temp;
-- {[1@2001-01-01, 2@2001-01-02, 1@2001-01-04, 1@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_wCount">
				<indexterm><primary><varname>wCount</varname></primary></indexterm>
				<para>Window count</para>
				<para><varname>wCount(tcbuffer) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
    Cbuffer(Point(1 1), 0.3)@2001-01-03)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-02, 
    Cbuffer(Point(1 1), 0.4)@2001-01-04)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-03, 
    Cbuffer(Point(1 1), 0.5)@2001-01-05)' )
SELECT wCount(Temp, '1 day')
FROM Temp;
/* {[1@2001-01-01, 2@2001-01-02, 3@2001-01-03, 2@2001-01-04, 1@2001-01-05,
   1@2001-01-06)} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tCentroid">
				<indexterm><primary><varname>tCentroid</varname></primary></indexterm>
				<para>TODO Temporal centroid</para>
				<para><varname>tCentroid(tcbuffer) → tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-03)' UNION
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.4)@2001-01-03)' UNION
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03)' )
SELECT astext(tCentroid(Temp))
FROM Temp;
/* {[POINT(72.451531682218 76.5231414472853)@2001-01-01,
   POINT(55.7001249027598 72.9552602410653)@2001-01-03)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_indexing">
		<title>Indexing</title>

		<para>GiST and SP-GiST indexes can be created for table columns of temporal circular buffers. An example of index creation is follows:</para>
		<programlisting language="sql" xml:space="preserve">
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		<para>The GiST and SP-GiST indexes store the bounding box for the temporal circular buffers, which is an stbox and thus stores the absolute coordinates of the underlying space.</para>

		<para>A GiST or SP-GiST index can accelerate queries involving the following operators:</para>
		<itemizedlist>
			<listitem>
				<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, which only consider the spatial dimension in temporal circular buffers,</para>
			</listitem>
			<listitem>
				<para><varname>&lt;&lt;#</varname>, <varname>&amp;&lt;#</varname>, <varname>#&amp;&gt;</varname>, <varname>#&gt;&gt;</varname>, which only consider the time dimension in temporal circular buffers,</para>
			</listitem>
			<listitem>
				<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, <varname>-|-</varname>, and <varname>|=|</varname> , which consider as many dimensions as they are shared by the indexed column and the query argument.</para>
			</listitem>
		</itemizedlist>
		<para>These operators work on bounding boxes, not the entire values.</para>
	</sect1>
</chapter>
