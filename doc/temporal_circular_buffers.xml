<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="temporal_circular_buffers">
	<title>Temporal Circular Buffers</title>

	<para>A static circular buffer <varname>cbuffer</varname> represents a 2D point and a radius greater than or equal to 0 around the point. The radius represent the &ldquo;impact&rdquo; of the point on its surroundings. This impact could be interpreted as noise, pollution, or similar aspects depending on application requirements.</para>

	<para>The <varname>cbuffer</varname> type serves as base type for defining the temporal circular buffer type <varname>tcbuffer</varname>. The <varname>tcbuffer</varname> type has similar functionality as the temporal point type <varname>tgeompoint</varname> with the exception that it only considers two dimensions. Thus, most functions and operators described before for the <varname>tgeompoint</varname> type are also applicable for the <varname>tcbuffer</varname> type. In addition, there are specific functions defined for the <varname>tcbuffer</varname> type.</para>

	<sect1 id="static_circular_buffers">
		<title>Static Circular Buffers</title>

		<para>A <varname>cbuffer</varname> value is a couple of the form <varname>(point,radius)</varname> where <varname>point</varname> is a geometric point and <varname>radius</varname> is a <varname>float</varname> value greater than or equal to zero representing a radius around the point expressed using the units of the SRID of the point. Examples of input of circular buffer values are as follows:</para>
		<programlisting language="sql" xml:space="preserve">
SELECT cbuffer 'Cbuffer(Point(1 1), 0.3)';
SELECT cbuffer 'Cbuffer(Point(1 1), 10.0)';
</programlisting>

		<para>Values of the circular buffer type must satisfy several constraints so that they are well defined. Examples of incorrect circular buffer type values are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
-- incorrect point value
SELECT cbuffer 'Cbuffer(Linestring(1 1,2 2), 1.0)';
-- incorrect radius value
SELECT cbuffer 'Cbuffer(Point(1 1), -2.0)';
</programlisting>
		<para>We give next the functions and operators for the circular buffer type.</para>

		<sect2 id="cbuffer_constructors">
			<title>Constructors</title>
			<itemizedlist>
				<listitem id="cbuffer">
					<indexterm><primary><varname>cbuffer</varname></primary></indexterm>
					<para>Constructor for circular buffers</para>
					<para><varname>cbuffer(geompoint,float) → cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(cbuffer(ST_Point(1,1), 0.3));
-- Cbuffer(POINT(1 1),0.3)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_conversions">
			<title>Conversions</title>
			<para>Values of the <varname>cbuffer</varname> type can be converted to the <varname>geometry</varname> point type using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation as shown below. Similarly, a <varname>geometry</varname> that define a circle can be converted to a <varname>cbuffer</varname> values. For this, the geometry must be a curve polygon with three points. If this is not the case, an error is returned.</para>
			<itemizedlist>
				<listitem id="cbuffer_geometry">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convert between a circular buffer and a geometry point</para>
					<para><varname>cbuffer::geompoint</varname></para>
					<para><varname>geompoint::cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(cbuffer(ST_Point(1,1), 1)::geometry);
-- CURVEPOLYGON(CIRCULARSTRING(0 0,2 2,0 0))
SELECT asText(geometry 'SRID=5676;CURVEPOLYGON(CIRCULARSTRING(0 0,2 2,0 0))'::cbuffer);
-- Cbuffer(POINT(1 1),1)
SELECT asText(geometry 'SRID=5676;CIRCULARSTRING(0 0,2 2,0 0)'::cbuffer);
-- Only circle geometries accepted
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_accessors">
			<title>Accessors</title>
			<itemizedlist>
				<listitem id="point">
					<indexterm><primary><varname>point</varname></primary></indexterm>
					<para>Return the point</para>
					<para><varname>point(cbuffer) → geompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(point(cbuffer 'Cbuffer(Point(1 1), 0.3)'));
-- Point(1 1)
</programlisting>
				</listitem>

				<listitem id="radius">
					<indexterm><primary><varname>radius</varname></primary></indexterm>
					<para>Return the radius</para>
					<para><varname>radius(cbuffer) → float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT radius(cbuffer 'Cbuffer(Point(1 1), 0.3)');
-- 0.3
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_transformations">
			<title>Transformations</title>
			<itemizedlist>
				<listitem id="cbuffer_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Round the point and the radius of the circular buffer to the number of decimal places</para>
					<para><varname>round(cbuffer,integer=0) → cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(round(cbuffer(ST_Point(1.123456789,1.123456789), 0.123456789), 6));
-- Cbuffer(POINT(1.123457 1.123457),0.123457)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_spatial_functions">
			<title>Spatial Operations</title>

			<itemizedlist>
				<listitem id="cbuffer_SRID">
					<indexterm><primary><varname>SRID</varname></primary></indexterm>
					<para>Return the spatial reference identifier</para>
					<para><varname>srid(cbuffer) → integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT SRID(cbuffer 'Cbuffer(SRID=5676;Point(1 1), 0.3)');
-- 5676
</programlisting>
				</listitem>

				<listitem id="cbuffer_setSRID">
					<indexterm><primary><varname>setSRID</varname></primary></indexterm>
					<para>Set the spatial reference identifier</para>
				<para><varname>setSRID(cbuffer) → cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(setSRID(cbuffer 'Cbuffer(Point(0 0),1)', 4326));
-- SRID=4326;Cbuffer(POINT(0 0),1)
</programlisting>
				</listitem>

				<listitem id="cbuffer_transform">
					<indexterm><primary><varname>transform</varname></primary></indexterm>
					<indexterm><primary><varname>transformPipeline</varname></primary></indexterm>
					<para>Transform to a spatial reference identifier</para>
					<para><varname>transform(cbuffer,integer) → cbuffer</varname></para>
					<para><varname>transformPipeline(cbuffer,pipeline text,to_srid integer,is_forward bool=true) → </varname></para>
					<para><varname>  cbuffer</varname></para>
					<para>The <varname>transform</varname> function specifies the transformation with a target SRID. An error is raised when the input circular buffer has an unknown SRID (represented by 0).</para>
					<para>The <varname>transformPipeline</varname> function specifies the transformation with a defined coordinate transformation pipeline represented with the following string format: <varname>urn:ogc:def:coordinateOperation:AUTHORITY::CODE</varname>. The SRID of the input circular buffer is ignored, and the SRID of the output circular buffer will be set to zero unless a value is provided via the optional <varname>to_srid</varname> parameter. As stated by the last parameter, the pipeline is executed by default in a forward direction; by setting the parameter to false, the pipeline is executed in the inverse direction.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(transform(cbuffer 'SRID=4326;Cbuffer(Point(4.35 50.85),1)', 3812));
-- SRID=3812;Cbuffer(POINT(648679.0180353033 671067.0556381135),1)
</programlisting>
					<programlisting language="sql" xml:space="preserve">
WITH test(cbuffer, pipeline) AS (
  SELECT cbuffer 'Cbuffer(SRID=4326;Point(4.3525 50.846667),1)',
    text 'urn:ogc:def:coordinateOperation:EPSG::16031' )
SELECT asEWKT(transformPipeline(transformPipeline(cbuffer, pipeline, 4326), pipeline,
  4326, false), 6)
FROM test;
-- SRID=4326;Cbuffer(POINT(4.3525 50.846667),1)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="cbuffer_static_operators">
			<title>Comparisons</title>

			<para>The comparison operators (=, &lt;, and so on) are available for circular buffers. They compare first the points and then the radius of the arguments. Excepted the equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on circular buffers.</para>

			<itemizedlist>
				<listitem id="cbuffer_comp">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>Traditional comparisons</para>
					<para><varname>cbuffer = cbuffer</varname></para>
					<para><varname>cbuffer &lt;&gt; cbuffer</varname></para>
					<para><varname>cbuffer &lt; cbuffer</varname></para>
					<para><varname>cbuffer &gt; cbuffer</varname></para>
					<para><varname>cbuffer &lt;= cbuffer</varname></para>
					<para><varname>cbuffer &gt;= cbuffer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT cbuffer 'Cbuffer(Point(3 3), 0.5)' = cbuffer 'Cbuffer(Point(3 3), 0.5)';
-- true
SELECT cbuffer 'Cbuffer(Point(3 3), 0.5)' &lt;&gt; cbuffer 'Cbuffer(Point(3 3), 0.6)';
-- true
SELECT cbuffer 'Cbuffer(Point(3 3), 0.5)' &lt; cbuffer 'Cbuffer(Point(3 3), 0.6)';
-- true
SELECT cbuffer 'Cbuffer(Point(3 3), 0.6)' > cbuffer 'Cbuffer(Point(2 2), 0.6)';
-- true
SELECT cbuffer 'Cbuffer(Point(1 1), 0.5)' &lt;= cbuffer 'Cbuffer(Point(2 2), 0.5)';
-- true
SELECT cbuffer 'Cbuffer(Point(1 1), 0.6)' &gt;= cbuffer 'Cbuffer(Point(1 1), 0.5)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id="temp_circular_buffers">
		<title>Temporal Circular Buffers</title>
		<para>The temporal circular buffer type <varname>tcbuffer</varname> allows to represent the movement of objects together with a circular radius around them. It corresponds to the temporal point type <varname>tgeompoint</varname> restricted to two-dimensional coordinates. As all the other temporal types it comes in trhee subtypes, namely, instant, sequence, and sequence set. Examples of <varname>tcbuffer</varname> values in these subtypes are given next.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01';
SELECT tcbuffer '{Cbuffer(Point(1 1), 0.3)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-02,
  Cbuffer(Point(1 1), 0.5)@2001-01-03}';
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, Cbuffer(Point(1 1), 0.4)@2001-01-02,
  Cbuffer(Point(1 1), 0.5)@2001-01-03]';
SELECT tcbuffer '{[Cbuffer(Point(1 1), 1)@2001-01-01, Cbuffer(Point(2 2), 1)@2001-01-02],
  [Cbuffer(Point(2 2), 2)@2001-01-04, Cbuffer(Point(2 2), 3)@2001-01-05]}';
</programlisting>
		<para>The temporal circular buffer type accepts type modifiers (or <varname>typmod</varname> in PostgreSQL terminology) to specify the subtype and/or the spatial reference identifier (SRID). The possible values for the subtype are <varname>Instant</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. The two arguments are optional and if any of them is not specified for a column, values of any subtype and/or SRID are allowed.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbuffer(Sequence,5676) 'SRID=5676;[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]');
-- SRID=5676;[Cbuffer(POINT(1 1),0.2)@2001-01-01, Cbuffer(POINT(1 1),0.5)@2001-01-03]
SELECT tcbuffer(Sequence) 'Cbuffer(Point(1 1), 0.2)@2001-01-01';
-- ERROR: Temporal type (Instant) does not match column type (Sequence)
SELECT tcbuffer(5676) 'Cbuffer(Point(1 1), 0.2)@2001-01-01';
-- ERROR:  Temporal circular buffer SRID (0) does not match column SRID (5676)
</programlisting>

		<para>Temporal circular buffer values of sequence or sequence set subtype are converted into a normal form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. Three consecutive instant values can be merged into two if the linear functions defining the evolution of values are the same. Examples of transformation into a normal form are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01,
  Cbuffer(Point(2 2), 0.4)@2001-01-02, Cbuffer(Point(3 3), 0.6)@2001-01-03)');
-- [Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(3 3),0.6)@2001-01-03)
SELECT asText(tcbuffer '{[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(2 2), 0.3)@2001-01-02, Cbuffer(Point(2 2), 0.5)@2001-01-03), 
  [Cbuffer(Point(2 2), 0.5)@2001-01-03, Cbuffer(Point(2 2), 0.7)@2001-01-04)}');
/* {[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(2 2),0.3)@2001-01-02, 
   Cbuffer(Point(2 2),0.7)@2001-01-04)} */
</programlisting>
	</sect1>

	<sect1 id="temporal_circular_buffers_validity">
		<title>Validity of Temporal Circular Buffers</title>

		<para>Temporal circular buffer values must satisfy the constraints specified in <xref linkend="temporal_types_validity" /> so that they are well defined. An error is raised whenever one of these constraints are not satisfied. Examples of incorrect values are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
-- Null values are not allowed
SELECT tcbuffer 'NULL@2001-01-01 08:05:00';
SELECT tcbuffer 'Point(0 0)@NULL';
-- Base type is not a circular buffer
SELECT tcbuffer 'Point(0 0)@2001-01-01 08:05:00';
</programlisting>
		<para>We give next the functions and operators for temporal circular buffer. Most functions and operators for temporal types described in the previous chapters can be applied for temporal circular buffer types. Therefore, in the signatures of the functions, the notation <varname>base</varname> represents a <varname>cbuffer</varname> and the notations <varname>ttype</varname>, <varname>tpoint</varname>, and <varname>tgeompoint</varname> also represent a <varname>tcbuffer</varname>. Furthermore, the functions that have an argument of type <varname>geometry</varname> accept in addition an argument of type <varname>cbuffer</varname>. To avoid redundancy, we only present next some examples of these functions and operators for temporal circular buffers.</para>
	</sect1>

	<sect1 id="tcbuffer_inout">
		<title>Input and Output</title>

		<itemizedlist>
			<listitem id="tcbuffer_asText">
				<indexterm><primary><varname>asText</varname></primary></indexterm>
				<indexterm><primary><varname>asEWKT</varname></primary></indexterm>
				<para>Return the Well-Known Text (WKT) or the Extended Well-Known Text (EWKT) representation</para>
				<para><varname>asText({tcbuffer,tcbuffer[],cbuffer[]}) → {text,text[]}</varname></para>
				<para><varname>asEWKT({tcbuffer,tcbuffer[],cbuffer[]}) → {text,text[]}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbuffer 'SRID=4326;[Cbuffer(Point(0 0),1)@2001-01-01, 
  Cbuffer(Point(1 1),2)@2001-01-02)');
-- [Cbuffer(Point(0 0),1)@2001-01-01, Cbuffer(Point(1 1),2)@2001-01-02)
SELECT asText(ARRAY[cbuffer 'Cbuffer(Point(0 0),1)', 'Cbuffer(Point(1 1),2)']);
-- {"Cbuffer(POINT(0 0),1)","Cbuffer(POINT(1 1),2)"}
SELECT asEWKT(tcbuffer 'SRID=4326;[Cbuffer(Point(0 0),1)@2001-01-01, 
  Cbuffer(Point(1 1),2)@2001-01-02)');
-- SRID=4326;[Cbuffer(Point(0 0),1)@2001-01-01, Cbuffer(Point(1 1),2)@2001-01-02)
SELECT asEWKT(ARRAY[cbuffer 'Cbuffer(SRID=5676;Point(0 0),1)', 
  'Cbuffer(SRID=5676;Point(1 1),2)']);
-- {"Cbuffer(SRID=5676;POINT(0 0),1)","Cbuffer(SRID=5676;POINT(1 1),2))"}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_asBinary">
				<indexterm><primary><varname>asBinary</varname></primary></indexterm>
				<indexterm><primary><varname>asEWKB</varname></primary></indexterm>
				<indexterm><primary><varname>asHexEWKB</varname></primary></indexterm>
				<para>Return the Well-Known Binary (WKB), the Extended Well-Known Binary (EWKB) representation, or the Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para><varname>asBinary(tcbuffer,endian text='') → bytea</varname></para>
				<para><varname>asEWKB(tcbuffer,endian text='') → bytea</varname></para>
				<para><varname>asHexEWKB(tcbuffer,endian text='') → text</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asBinary(tcbuffer 'Cbuffer(Point(1 2),1)@2001-01-01');
-- \x013a0001000000000000f03f0000000000000040000000000000f03f009c57d3c11c0000
SELECT asEWKB(tcbuffer 'SRID=7844;Cbuffer(Point(1 2),1)@2001-01-01');
-- \x013a0001000000000000f03f0000000000000040000000000000f03f009c57d3c11c0000
SELECT asHexEWKB(tcbuffer 'SRID=3812;Cbuffer(Point(1 2),1)@2001-01-01');
-- 013A0001000000000000F03F0000000000000040000000000000F03F009C57D3C11C0000
</programlisting>
			</listitem>

			<listitem id="tcbufferFromText">
				<indexterm><primary><varname>tcbufferFromText</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferFromEWKT</varname></primary></indexterm>
				<para>Input from the Well-Known Text (WKT) representation or from the Extended Well-Known Text (EWKT) representation</para>
				<para><varname>tcbufferFromText(text) → tcbuffer</varname></para>
				<para><varname>tcbufferFromEWKT(text) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromText(text '[Cbuffer(Point(1 2),1)@2001-01-01, 
  Cbuffer(Point(3 4),2)@2001-01-02]'));
-- [Cbuffer(POINT(1 2),1)@2001-01-01, Cbuffer(POINT(3 4),2)@2001-01-02]
SELECT asEWKT(tcbufferFromEWKT(text 'SRID=3812;[Cbuffer(Point(1 2),1)@2001-01-01,
  Cbuffer(Point(3 4),2)@2001-01-02]'));
-- SRID=3812;[Cbuffer(Point(1 2),1)@2001-01-01, Cbuffer(Point(3 4),2)@2001-01-02]
</programlisting>
			</listitem>

			<listitem id="tcbufferFromBinary">
				<indexterm><primary><varname>tcbufferFromBinary</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferFromEWKB</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferFromHexEWKB</varname></primary></indexterm>
				<para>Input from the Well-Known Binary (WKB) representation, from the Extended Well-Known Binary (EWKB) representation, or from the Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para><varname>tcbufferFromBinary(bytea) → tcbuffer</varname></para>
				<para><varname>tcbufferFromEWKB(bytea) → tcbuffer</varname></para>
				<para><varname>tcbufferFromHexEWKB(text) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tcbufferFromBinary(
  '\x013a0001000000000000f03f0000000000000040000000000000f03f009c57d3c11c0000'));
-- Cbuffer(POINT(1 2),1)@2001-01-01
SELECT asEWKT(tcbufferFromEWKB(
  '\x013a0001000000000000f03f0000000000000040000000000000f03f009c57d3c11c0000'));
-- SRID=7844;Cbuffer(Point(1 1),2)@2001-01-01
SELECT asEWKT(tcbufferFromHexEWKB(
  '013A0041E40E0000E40E0000000000000000F03F...40000000000000F03F009C57D3C11C0000'));
-- SRID=3812;Cbuffer(POINT(1 2),1)@2001-01-01
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_constructors">
		<title>Constructors</title>

		<itemizedlist>
			<listitem id="tcbuffer_const">
				<indexterm><primary><varname>tcbuffer</varname></primary></indexterm>
				<para>Constructor for temporal circular buffers having a constant value</para>
				<para><varname>tcbuffer(cbuffer,timestamptz) → tcbufferInst</varname></para>
				<para><varname>tcbuffer(cbuffer,tstzset) → tcbufferDiscSeq</varname></para>
				<para><varname>tcbuffer(cbuffer,tstzspan,interp='linear') → tcbufferContSeq</varname></para>
				<para><varname>tcbuffer(cbuffer,tstzspanset,interp='linear') → tcbufferSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.5)', timestamptz '2001-01-01'));
-- Cbuffer(Point(1 1),0.5)@2001-01-01
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.3)', 
  tstzset '{2001-01-01, 2001-01-03, 2001-01-05}'));
/* {Cbuffer(Point(1 1),0.3)@2001-01-01, Cbuffer(Point(1 1),0.3)@2001-01-03, 
   Cbuffer(Point(1 1),0.3)@2001-01-05} */
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.5)', 
  tstzspan '[2001-01-01, 2001-01-02]'));
-- [Cbuffer(Point(1 1),0.5)@2001-01-01, Cbuffer(Point(1 1),0.5)@2001-01-02]
SELECT asText(tcbuffer('Cbuffer(Point(1 1), 0.2)', 
  tstzspanset '{[2001-01-01, 2001-01-03]}', 'step'));
-- Interp=Step;{[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(1 1),0.2)@2001-01-03]}
</programlisting>
			</listitem>

			<listitem id="tcbufferSeq">
				<indexterm><primary><varname>tcbufferSeq</varname></primary></indexterm>
				<para>Constructor for temporal circular buffers of sequence subtype</para>
				<para><varname>tcbufferSeq(tcbufferInst[],interp={'step','linear'},leftInc bool=true,</varname></para>
				<para><varname>  rightInc bool=true) →tcbufferSeq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbufferSeq(ARRAY[tcbuffer 'Cbuffer(Point(1 1), 0.3)@2001-01-01',
  'Cbuffer(Point(2 2), 0.5)@2001-01-02', 'Cbuffer(Point(1 1), 0.5)@2001-01-03']));
/* {Cbuffer(Point(1 1),0.3)@2001-01-01, Cbuffer(Point(2 2),0.5)@2001-01-02, 
   Cbuffer(Point(1 1),0.5)@2001-01-03} */
SELECT asText(tcbufferSeq(ARRAY[tcbuffer 'Cbuffer(Point(1 1), 0.2)@2001-01-01',
  'Cbuffer(Point(1 1), 0.4)@2001-01-02', 'Cbuffer(Point(1 1), 0.5)@2001-01-03']));
/* [Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(1 1),0.4)@2001-01-02, 
   Cbuffer(Point(1 1),0.5)@2001-01-03] */
</programlisting>
			</listitem>

			<listitem id="tcbufferSeqSet">
				<indexterm><primary><varname>tcbufferSeqSet</varname></primary></indexterm>
				<para>Constructor for temporal circular buffers of sequence set subtype</para>
				<para><varname>tcbufferSeqset(tcbuffer[]) → tcbufferSeqSet</varname></para>
				<para><varname>tcbufferSeqSetGaps(tcbufferInst[],maxt=NULL,maxdist=NULL,interp='linear') →</varname></para>
				<para><varname>  tcbufferSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbufferSeqSet(ARRAY[tcbuffer 
  '[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(2 2),0.4)@2001-01-02]', 
  '[Cbuffer(Point(2 2),0.6)@2001-01-03, Cbuffer(Point(2 2),0.8)@2001-01-04]']));
/* {[Cbuffer(Point(1 1),0.2)@2001-01-01, Cbuffer(Point(2 2),0.4)@2001-01-02],
   [Cbuffer(Point(2 2),0.6)@2001-01-03, Cbuffer(Point(2 2),0.6)@2001-01-04]} */
SELECT asText(tcbufferSeqSetGaps(ARRAY[tcbuffer 'Cbuffer(Point(1 1),0.1)@2001-01-01',
  'Cbuffer(Point(1 1),0.3)@2001-01-03', 'Cbuffer(Point(1 1),0.5)@2001-01-05'], '1 day'));
/* {[Cbuffer(Point(1 1),0.1)@2001-01-01], [Cbuffer(Point(1 1),0.3)@2001-01-03], 
   [Cbuffer(Point(1 1),0.5)@2001-01-05]} */
</programlisting>
			</listitem>

			<listitem id="tgeompoint_tfloat_tcbuffer">
				<indexterm><primary><varname>tcbuffer</varname></primary></indexterm>
				<para>Construct a temporal circular buffer from a temporal geometry point and a temporal float</para>
				<para><varname>tcbuffer(tgeompoint, tfloat) → tcbuffer</varname></para>
				<para>The time frame of the result is the intersection of the time frames of the temporal point and the temporal float. If they do not intersect, a null value is returned</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbuffer(tgeompoint '[POINT(1 1)@2001-01-01, POINT(2 2)@2001-01-02)',
  tfloat '[1@2001-01-01, 2@2001-01-02)'));
-- [Cbuffer(Point(1 1),1)@2001-01-01, Cbuffer(Point(1 1),2)@2001-01-02)
SELECT asText(tcbuffer(tgeompoint '[POINT(1 1)@2001-01-01, POINT(2 2)@2001-01-02)',
  tfloat '[2@2001-01-03, 3@2001-01-04)'));
-- NULL
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_conversions">
		<title>Conversions</title>
		<para>A temporal circular buffer value can be converted to and from a temporal geometry point. This can be done using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation. A null value is returned if any of the composing geometry point values cannot be converted into a <varname>cbuffer</varname> value.</para>
		<itemizedlist>
			<listitem id="tcbuffer_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convert a temporal circular buffer to a temporal geometry point</para>
				<para><varname>tcbuffer::tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01,
  Cbuffer(Point(1 1), 0.3)@2001-01-02)')::tgeompoint);
-- [POINT(1 1)@2001-01-01, POINT(1 1)@2001-01-02)
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tfloat">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convert a temporal circular buffer to a temporal float</para>
				<para><varname>tcbuffer::tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT (tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01,
  Cbuffer(Point(1 1), 0.3)@2001-01-02)')::tfloat;
-- [0.2@2001-01-01, 0.3@2001-01-02)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_accessors">
		<title>Accessors</title>
		<itemizedlist>
			<listitem id="tcbuffer_getValues">
				<indexterm><primary><varname>getValues</varname></primary></indexterm>
				<para>Return the values</para>
				<para><varname>getValues(tcbuffer) → cbufferset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(getValues(tcbuffer '{[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02)}'));
-- {"Cbuffer(Point(1 1),0.3)","Cbuffer(Point(1 1),0.5)"}
SELECT asEWKT(getValues(tcbuffer 'SRID=5676;{[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-02)}'));
-- SRID=5676;{"Cbuffer(Point(1 1),0.3)"}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_points">
				<indexterm><primary><varname>points</varname></primary></indexterm>
				<para>Return the points</para>
				<para><varname>points(tcbuffer) → bigintset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(points(tcbuffer 'SRID=5676;{Cbuffer(Point(3 3), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02}'));
-- SRID=5676;{Point(1 1), Point(3 3)}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_valueAtTimestamp">
				<indexterm><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Return the value at a timestamp</para>
				<para><varname>valueAtTimestamp(tcbuffer,timestamptz) → cbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(valueAtTimestamp(tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(3 3), 0.5)@2001-01-03)', '2001-01-02'));
-- Cbuffer(Point(2 2),0.4)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_transformations">
		<title>Transformations</title>
		<itemizedlist>
			<listitem id="tcbuffer_subtype">
				<indexterm><primary><varname>tcbufferInst</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferSeq</varname></primary></indexterm>
				<indexterm><primary><varname>tcbufferSeqSet</varname></primary></indexterm>
				<para>Transform a temporal circular buffer to another subtype</para>
				<para><varname>tcbufferInst(tcbuffer) → tcbufferInst</varname></para>
				<para><varname>tcbufferSeq(tcbuffer) → tcbufferSeq</varname></para>
				<para><varname>tcbufferSeqSet(tcbuffer) → tcbufferSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tcbufferSeq(tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01', 'discrete'));
-- {Cbuffer(Point(1 1),0.5)@2001-01-01}
SELECT asText(tcbufferSeq(tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01'));
-- [Cbuffer(Point(1 1),0.5)@2001-01-01]
SELECT asText(tcbufferSeqSet(tcbuffer 'Cbuffer(Point(1 1), 0.5)@2001-01-01'));
-- {[Cbuffer(Point(1 1),0.5)@2001-01-01]}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_setInterp">
				<indexterm><primary><varname>setInterp</varname></primary></indexterm>
				<para>Transform a temporal circular buffer to another interpolation</para>
				<para><varname>setInterp(tcbuffer, interp) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(setInterp(tcbuffer 'Cbuffer(Point(1 1),0.2)@2001-01-01','linear'));
-- [Cbuffer(Point(1 1),0.2)@2001-01-01]
SELECT asText(setInterp(tcbuffer '{[Cbuffer(Point(1 1),0.1)@2001-01-01], 
  [Cbuffer(Point(1 1),0.2)@2001-01-02]}', 'discrete'));
-- {Cbuffer(Point(1 1),0.1)@2001-01-01, Cbuffer(Point(1 1),0.2)@2001-01-02}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Round the points and the radii of the temporal circular buffer to the number of decimal places</para>
				<para><varname>round(tcbuffer,integer) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(round(tcbuffer '{[Cbuffer(Point(1 1.123456789),0.123456789)@2001-01-01, 
  Cbuffer(Point(1 1),0.5)@2001-01-02)}', 3));
/* {[Cbuffer(Point(1 1.123),0.123)@2001-01-01, Cbuffer(Point(1 1),0.5)@2001-01-02)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_spatial">
		<title>Spatial Operations</title>
		<itemizedlist>
			<listitem id="tcbuffer_SRID">
				<indexterm><primary><varname>SRID</varname></primary></indexterm>
				<para>Get the spatial reference identifier</para>
				<para><varname>SRID(tcbuffer) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT SRID(tcbuffer 'SRID=5676;[Cbuffer(Point(0 0),1)@2001-01-01, 
  Cbuffer(Point(1 1),2)@2001-01-02)'));
-- 5676
</programlisting>
			</listitem>

			<listitem id="tcbuffer_setSRID">
				<indexterm><primary><varname>setSRID</varname></primary></indexterm>
				<para>Set the spatial reference identifier</para>
				<para><varname>setSRID(tcbuffer) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(setSRID(tcbuffer '[Cbuffer(Point(0 0),1)@2001-01-01, 
  Cbuffer(Point(1 1),2)@2001-01-02)', 5676));
-- SRID=5676;[Cbuffer(POINT(0 0),1)@2001-01-01, Cbuffer(POINT(1 1),2)@2001-01-02)
</programlisting>
			</listitem>

			<listitem id="tcbuffer_transform">
				<indexterm><primary><varname>transform</varname></primary></indexterm>
				<indexterm><primary><varname>transformPipeline</varname></primary></indexterm>
				<para>Transform to a spatial reference identifier</para>
				<para><varname>transform(tcbuffer,integer) → tcbuffer</varname></para>
				<para><varname>transformPipeline(tcbuffer,pipeline text,to_srid integer,is_forward bool=true) →</varname></para>
				<para><varname>  tcbuffer</varname></para>
				<para>The <varname>transform</varname> function specifies the transformation with a target SRID. An error is raised when the input temporal circular buffer has an unknown SRID (represented by 0).</para>
				<para>The <varname>transformPipeline</varname> function specifies the transformation with a defined coordinate transformation pipeline represented with the following string format: <varname>urn:ogc:def:coordinateOperation:AUTHORITY::CODE</varname>. The SRID of the input temporal circular buffer is ignored, and the SRID of the output temporal circular buffer will be set to zero unless a value is provided via the optional <varname>to_srid</varname> parameter. As stated by the last parameter, the pipeline is executed by default in a forward direction; by setting the parameter to false, the pipeline is executed in the inverse direction.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(transform(tcbuffer 'SRID=4326;Cbuffer(Point(4.35 50.85),1)@2001-01-01', 
  3812));
-- SRID=3812;Cbuffer(POINT(648679.0180353033 671067.0556381135),1)@2001-01-01
</programlisting>
				<programlisting language="sql" xml:space="preserve">
WITH test(tcbuffer, pipeline) AS (
  SELECT tcbuffer 'SRID=4326;{Cbuffer(Point(4.3525 50.846667),1)@2001-01-01,
    Cbuffer(Point(-0.1275 51.507222),2)@2001-01-02}',
    text 'urn:ogc:def:coordinateOperation:EPSG::16031' )
SELECT asEWKT(transformPipeline(transformPipeline(tcbuffer, pipeline, 4326),  pipeline,
  4326, false), 6)
FROM test;
/* SRID=4326;{Cbuffer(POINT(4.3525 50.846667),1)@2001-01-01, 
   Cbuffer(POINT(-0.1275 51.507222),2)@2001-01-02} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_traversedArea">
				<indexterm><primary><varname>traversedArea</varname></primary></indexterm>
				<para>TODO Return the area traversed by the temporal circular buffer</para>
				<para><varname>traversedArea(tcbuffer) → geometry</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT traversedArea(tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]');
-- 54.3757408468784
</programlisting>
			</listitem>

			<listitem id="tcbuffer_stbox">
				<indexterm><primary><varname>stbox</varname></primary></indexterm>
				<para>Construct a spatiotemporal box from a circular buffer and, optionally, a timestamp or a period</para>
				<para><varname>stbox(cbuffer) → stbox</varname></para>
				<para><varname>stbox(cbuffer,{timestamptz,tstzspan}) → stbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT stbox(cbuffer 'SRID=5676;Cbuffer(Point(1 1),0.3)');
-- SRID=5676;STBOX X((0.7,0.7),(1.3,1.3))
SELECT stbox(cbuffer 'Cbuffer(Point(1 1),0.3)', timestamptz '2001-01-01');
-- STBOX XT(((0.7,0.7),(1.3,1.3)),[2001-01-01, 2001-01-01])
SELECT stbox(cbuffer 'Cbuffer(Point(1 1),0.3)', tstzspan '[2001-01-01,2001-01-02]');
-- STBOX XT(((0.7,0.7),(1.3,1.3)),[2001-01-01, 2001-01-02])
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_distance">
		<title>Distance Operations</title>
		<itemizedlist>
			<listitem id="tcbuffer_nearestApproachInstant">
				<indexterm><primary><varname>nearestApproachInstant</varname></primary></indexterm>
				<para>TODO Return the instant of the first temporal circular buffer at which the two arguments are at the nearest distance</para>
				<para><varname>nearestApproachInstant({geo,cbuffer,tpoint},{geo,cbuffer,tpoint}) → tpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT nearestApproachInstant(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)');
-- Cbuffer(Point(2 2),0.349928)@2001-01-01 02:59:44.402905+01
SELECT nearestApproachInstant(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', cbuffer 'Cbuffer(Point(1 1), 0.5)');
-- Cbuffer(Point(2 2),0.592181)@2001-01-01 17:31:51.080405+01
</programlisting>
			</listitem>

			<listitem id="tcbuffer_nearestApproachDistance">
				<indexterm><primary><varname>nearestApproachDistance</varname></primary></indexterm>
				<para>TODO Return the smallest distance ever between the two arguments</para>
				<para><varname>nearestApproachDistance({geo,cbuffer,tpoint},{geo,cbuffer,tpoint}) → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT nearestApproachDistance(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)');
-- 1.41793220500979
SELECT nearestApproachDistance(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', cbuffer 'Cbuffer(Point(1 1), 0.5)');
-- Cbuffer(Point(2 2),0.592181)@2001-01-01 17:31:51.080405+01
</programlisting>
				<para>Function <varname>nearestApproachDistance</varname> has an associated operator <varname>|=|</varname> that can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="temporal_types_indexing" />).</para>
			</listitem>

			<listitem id="tcbuffer_shortestLine">
				<indexterm><primary><varname>shortestLine</varname></primary></indexterm>
				<para>TODO Return the line connecting the nearest approach point between the two arguments</para>
				<para><varname>shortestLine({geo,cbuffer,tpoint},{geo,cbuffer,tpoint}) → geometry</varname></para>
				<para>The function will only return the first line that it finds if there are more than one</para>
				<programlisting language="sql" xml:space="preserve">
SELECT st_astext(shortestLine(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)'));
-- LINESTRING(50.7960725266492 48.8266286733015,50 50)
SELECT st_astext(shortestLine(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01,
  Cbuffer(Point(2 2), 0.7)@2001-01-02]', cbuffer 'Cbuffer(Point(1 1), 0.5)'));
-- LINESTRING(77.0902838115125 66.6659083092593,90.8134936900394 46.4385792121146)
</programlisting>
			</listitem>

			<listitem id="tcbuffer_smallestDistance">
				<indexterm><primary><varname>|=|</varname></primary></indexterm>
				<para>TODO Return the smallest distance ever between the two arguments</para>
				<para><varname>tgeompoint |=| tcbuffer → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' |=| cbuffer 'Cbuffer(Point(1 1), 0.2)';
-- 2.34988300875063
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' |=| geometry 'Linestring(2 2,2 1,3 1)';
-- 82.2059262761477
</programlisting>
			</listitem>

			<listitem id="tcbuffer_distance">
				<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
				<para>TODO Return the temporal distance</para>
				<para><varname>tgeompoint &lt;-&gt; tcbuffer → tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;-&gt; cbuffer 'Cbuffer(Point(1 1), 0.2)';
-- [2.34988300875063@2001-01-02 00:00:00+01, 2.34988300875063@2001-01-03 00:00:00+01]
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;-&gt; geometry 'Point(50 50)';
-- [25.0496666945044@2001-01-01 00:00:00+01, 26.4085688426232@2001-01-03 00:00:00+01]
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;-&gt;
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-02, Cbuffer(Point(1 1), 0.5)@2001-01-04]'
-- [2.34988300875063@2001-01-02 00:00:00+01, 2.34988300875063@2001-01-03 00:00:00+01]
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_restrictions">
		<title>Restrictions</title>
		<itemizedlist>
			<listitem id="tcbuffer_atValues">
				<indexterm><primary><varname>atValues</varname></primary></indexterm>
				<indexterm><primary><varname>minusValues</varname></primary></indexterm>
				<para>TODO Restrict to (the complement of) a set of values</para>
				<para><varname>atValues(tcbuffer,values) → tcbuffer</varname></para>
				<para><varname>minusValues(tcbuffer,values) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atValues(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]', 'Cbuffer(Point(2 2), 0.5)');
-- {[Cbuffer(Point(2 2),0.5)@2001-01-02]}
SELECT minusValues(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]', 'Cbuffer(Point(2 2), 0.5)');
/* {[Cbuffer(Point(2 2),0.3)@2001-01-01, Cbuffer(Point(2 2),0.5)@2001-01-02),
   (Cbuffer(Point(2 2),0.5)@2001-01-02, Cbuffer(Point(2 2),0.7)@2001-01-03]} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_atGeometry">
				<indexterm><primary><varname>atGeometry</varname></primary></indexterm>
				<indexterm><primary><varname>minusGeometry</varname></primary></indexterm>
				<para>TODO Restrict to (the complement of) a geometry</para>
				<para><varname>atGeometry(tcbuffer,geometry) → tcbuffer</varname></para>
				<para><varname>minusGeometry(tcbuffer,geometry) → tcbuffer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atGeometry(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]',
  'Polygon((40 40,40 50,50 50,50 40,40 40))');
SELECT minusGeometry(tcbuffer '[Cbuffer(Point(2 2), 0.3)@2001-01-01, 
  Cbuffer(Point(2 2), 0.7)@2001-01-03]',
  'Polygon((40 40,40 50,50 50,50 40,40 40))');
/* {(Cbuffer(Point(2 2),0.342593)@2001-01-01 05:06:40.364673+01,
   Cbuffer(Point(2 2),0.7)@2001-01-03 00:00:00+01]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_comparisons">
		<title>Comparisons</title>
		<itemizedlist>
			<listitem id="tcbuffer_comp">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Traditional comparisons</para>
				<para><varname>tcbuffer = tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;= tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &gt;= tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '{[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-02),
  [Cbuffer(Point(1 1), 0.3)@2001-01-02, Cbuffer(Point(1 1), 0.5)@2001-01-03]}' =
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-03]';
-- true
SELECT tcbuffer '{[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]}' &lt;&gt;
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-03]';
-- false
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' &lt;
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.6)@2001-01-03]';
-- true
</programlisting>
			</listitem>

			<listitem id="tcbuffer_ever_always">
				<indexterm><primary><varname>?=</varname></primary></indexterm>
				<indexterm><primary><varname>%=</varname></primary></indexterm>
				<para>Ever and always comparisons</para>
				<para><varname>tcbuffer ?= tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer %= tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.4)@2001-01-04)' ?= Cbuffer(Point(1 1), 0.3);
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.2)@2001-01-04)' &amp;= Cbuffer(Point(1 1), 0.2);
-- true
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tcomp">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Temporal comparisons</para>
				<para><varname>tcbuffer #= tcbuffer → tbool</varname></para>
				<para><varname>tcbuffer #&lt;&gt; tcbuffer → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.4)@2001-01-03)' #= cbuffer 'Cbuffer(Point(1 1), 0.3)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.8)@2001-01-03)' #&lt;&gt;
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, Cbuffer(Point(1 1), 0.7)@2001-01-03)';
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_bbox_ops">
		<title>Bounding Box Operations</title>
		<itemizedlist>
			<listitem id="tcbuffer_topo">
				<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
				<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
				<indexterm><primary><varname>~=</varname></primary></indexterm>
				<indexterm><primary><varname>-|-</varname></primary></indexterm>
				<para>Topological operators</para>
				<para><varname>tcbuffer &amp;&amp; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;@ tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer @&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer ~= tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer -|- tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &amp;&amp; cbuffer 'Cbuffer(Point(1 1), 0.5)'
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' @&gt; stbox(cbuffer 'Cbuffer(Point(1 1), 0.5)')
-- true
SELECT cbuffer 'Cbuffer(Point(1 1), 0.5)'::geometry &lt;@
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, Cbuffer(Point(1 1), 0.5)@2001-01-02]'
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03]' ~= tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.35)@2001-01-02, Cbuffer(Point(1 1), 0.5)@2001-01-03]'
-- true
</programlisting>
			</listitem>

			<listitem id="tcbuffer_pos">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Position operators</para>
				<para><varname>tcbuffer &lt;&lt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&lt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &gt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;&lt;| tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&lt;| tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer |&gt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer |&amp;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &lt;&lt;# tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer &amp;&lt;# tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer #&gt;&gt; tcbuffer → boolean</varname></para>
				<para><varname>tcbuffer #&amp;&gt; tcbuffer → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &lt;&lt; cbuffer 'Cbuffer(Point(1 1), 0.2)'
-- false
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &lt;&lt;| stbox(cbuffer 'Cbuffer(Point(1 1), 0.5)')
-- false
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &amp;&gt; cbuffer 'Cbuffer(Point(1 1), 0.3)'::geometry
-- true
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-02]' &gt;&gt;#
  tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-03, Cbuffer(Point(1 1), 0.5)@2001-01-05]'
-- true
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_spatial_rels">
		<title>Spatial Relationships</title>
		<itemizedlist>
			<listitem id="tcbuffer_espatialrels">
				<indexterm><primary><varname>eContains</varname></primary></indexterm>
				<indexterm><primary><varname>aContains</varname></primary></indexterm>
				<indexterm><primary><varname>eDisjoint</varname></primary></indexterm>
				<indexterm><primary><varname>aDisjoint</varname></primary></indexterm>
				<indexterm><primary><varname>eIntersects</varname></primary></indexterm>
				<indexterm><primary><varname>aIntersects</varname></primary></indexterm>
				<indexterm><primary><varname>eTouches</varname></primary></indexterm>
				<indexterm><primary><varname>aTouches</varname></primary></indexterm>
				<indexterm><primary><varname>eDwithin</varname></primary></indexterm>
				<indexterm><primary><varname>aDwithin</varname></primary></indexterm>
				<para>TODO Ever and always spatial relationships</para>
				<para><varname>eContains(geometry,tcbuffer) → boolean</varname></para>
				<para><varname>aContains(geometry,tcbuffer) → boolean</varname></para>
				<para><varname>eDisjoint({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>aDisjoint({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>eIntersects({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>aIntersects({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>eTouches({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>aTouches({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>eDwithin({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer},float) → boolean</varname></para>
				<para><varname>aDwithin({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer},float) → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT eContains(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.3)@2001-01-03)');
-- false
SELECT eDisjoint(cbuffer 'Cbuffer(Point(2 2), 0.0)',
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.3)@2001-01-03)');
-- true
SELECT eIntersects(tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-03)',
  tcbuffer '[Cbuffer(Point(2 2), 0.0)@2001-01-01, Cbuffer(Point(2 2), 1)@2001-01-03)');
-- false
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tspatialrels">
				<indexterm><primary><varname>tContains</varname></primary></indexterm>
				<indexterm><primary><varname>tDisjoint</varname></primary></indexterm>
				<indexterm><primary><varname>tIntersects</varname></primary></indexterm>
				<indexterm><primary><varname>tTouches</varname></primary></indexterm>
				<indexterm><primary><varname>tDwithin</varname></primary></indexterm>
				<para>TODO Temporal spatial relationships</para>
				<para><varname>tContains(geometry,tcbuffer) → boolean</varname></para>
				<para><varname>tDisjoint({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>tIntersects({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>tTouches({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer}) → boolean</varname></para>
				<para><varname>tDwithin({geometry,cbuffer,tcbuffer},{geometry,cbuffer,tcbuffer},float) → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tDisjoint(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
  tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, Cbuffer(Point(1 1), 0.3)@2001-01-03)');
-- {[t@2001-01-01 00:00:00+01, t@2001-01-03 00:00:00+01)}
SELECT tDwithin(tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03)', tcbuffer '[Cbuffer(Point(1 1), 0.5)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-03)', 1);
/* {[t@2001-01-01 00:00:00+01, t@2001-01-01 22:35:55.379053+01],
   (f@2001-01-01 22:35:55.379053+01, t@2001-01-02 01:24:04.620946+01,
   t@2001-01-03 00:00:00+01)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_aggregations">
		<title>Aggregations</title>
		<para>The three aggregate functions for temporal circular buffers are illustrated next.</para>

		<itemizedlist>
			<listitem id="tcbuffer_tCount">
				<indexterm><primary><varname>tCount</varname></primary></indexterm>
				<para>Temporal count</para>
				<para><varname>tCount(tcbuffer) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
    Cbuffer(Point(1 1), 0.3)@2001-01-03)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-02, 
    Cbuffer(Point(1 1), 0.4)@2001-01-04)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-03, 
    Cbuffer(Point(1 1), 0.5)@2001-01-05)' )
SELECT tCount(Temp)
FROM Temp;
-- {[1@2001-01-01, 2@2001-01-02, 1@2001-01-04, 1@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="tcbuffer_wCount">
				<indexterm><primary><varname>wCount</varname></primary></indexterm>
				<para>Window count</para>
				<para><varname>wCount(tcbuffer) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
    Cbuffer(Point(1 1), 0.3)@2001-01-03)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-02, 
    Cbuffer(Point(1 1), 0.4)@2001-01-04)' UNION
  SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-03, 
    Cbuffer(Point(1 1), 0.5)@2001-01-05)' )
SELECT wCount(Temp, '1 day')
FROM Temp;
/* {[1@2001-01-01, 2@2001-01-02, 3@2001-01-03, 2@2001-01-04, 1@2001-01-05,
   1@2001-01-06)} */
</programlisting>
			</listitem>

			<listitem id="tcbuffer_tCentroid">
				<indexterm><primary><varname>tCentroid</varname></primary></indexterm>
				<para>TODO Temporal centroid</para>
				<para><varname>tCentroid(tcbuffer) → tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.1)@2001-01-01, 
  Cbuffer(Point(1 1), 0.3)@2001-01-03)' UNION
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.2)@2001-01-01, 
  Cbuffer(Point(1 1), 0.4)@2001-01-03)' UNION
SELECT tcbuffer '[Cbuffer(Point(1 1), 0.3)@2001-01-01, 
  Cbuffer(Point(1 1), 0.5)@2001-01-03)' )
SELECT astext(tCentroid(Temp))
FROM Temp;
/* {[POINT(72.451531682218 76.5231414472853)@2001-01-01,
   POINT(55.7001249027598 72.9552602410653)@2001-01-03)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_circular_buffers_indexing">
		<title>Indexing</title>

		<para>GiST and SP-GiST indexes can be created for table columns of temporal circular buffers. An example of index creation is follows:</para>
		<programlisting language="sql" xml:space="preserve">
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		<para>The GiST and SP-GiST indexes store the bounding box for the temporal circular buffers, which is an stbox and thus stores the absolute coordinates of the underlying space.</para>

		<para>A GiST or SP-GiST index can accelerate queries involving the following operators:</para>
		<itemizedlist>
			<listitem>
				<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, which only consider the spatial dimension in temporal circular buffers,</para>
			</listitem>
			<listitem>
				<para><varname>&lt;&lt;#</varname>, <varname>&amp;&lt;#</varname>, <varname>#&amp;&gt;</varname>, <varname>#&gt;&gt;</varname>, which only consider the time dimension in temporal circular buffers,</para>
			</listitem>
			<listitem>
				<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, <varname>-|-</varname>, and <varname>|=|</varname> , which consider as many dimensions as they are shared by the indexed column and the query argument.</para>
			</listitem>
		</itemizedlist>
		<para>These operators work on bounding boxes, not the entire values.</para>
	</sect1>
</chapter>
