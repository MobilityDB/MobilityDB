<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="manipulating_temporal_types">
	<title>Manipulación de tipos temporales</title>
	<para>A continuación presentamos las funciones y operadores para tipos temporales. Estas funciones y operadores son polimórficos, es decir, sus argumentos pueden ser de varios tipos y el tipo del resultado puede depender del tipo de los argumentos. Para expresar esto, usamos la siguiente notación:</para>

	<itemizedlist>
		<listitem>
			<para><varname>time</varname> representa cualquier tipo de tiempo, es decir, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname> o <varname>periodset</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>ttype</varname> representa cualquier tipo temporal,</para>
		</listitem>

		<listitem>
			<para><varname>tdisc</varname> representa cualquier tipo temporal con tipo de base discreto, es decir, <varname>tbool</varname>, <varname>tint</varname> o <varname>ttext</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tcont</varname> representa cualquier tipo temporal con tipo de base continuo, es decir, <varname>tfloat</varname>, <varname>tgeompoint</varname> o <varname>tgeogpoint</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>torder</varname> representa cualquier tipo temporal cuyo tipo de base tiene definido un orden total, es decir, <varname>tint</varname>, <varname>tfloat</varname> o <varname>ttext</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tnumber</varname> representa cualquier tipo de número temporal, es decir, <varname>tint</varname> o <varname>tfloat</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tpoint</varname> representa un tipo de punto temporal, es decir, <varname>tgeompoint</varname> o <varname>tgeogpoint</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_inst</varname> representa cualquier tipo temporal con subtipo instante,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_seq</varname> representa cualquier tipo temporal con subtipo secuencia,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_discseq</varname> representa cualquier tipo temporal con subtipo secuencia e interpolación discreta,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_seqset</varname> representa cualquier tipo temporal con subtipo conjunto de secuencias</para>
		</listitem>

		<listitem>
			<para><varname>base</varname> representa cualquier tipo de base de un tipo temporal, es decir, <varname>boolean</varname>, <varname>integer</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname> o <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>number</varname> representa cualquier tipo de base numérico, es decir, <varname>integer</varname> o <varname>float</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>numspan</varname> representa cualquier tipo de rango numérico, es decir, <varname>intspan</varname> o <varname>floatspan</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>geo</varname> representa los tipos <varname>geometry</varname> o <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>geompoint</varname> representa el tipo <varname>geometry</varname> restringido a un punto.</para>
		</listitem>

		<listitem>
			<para><varname>point</varname> representa los tipos  <varname>geometry</varname> o <varname>geography</varname> restringidos a un punto.</para>
		</listitem>

		<listitem>
			<para><varname>type[]</varname> representa una matriz de <varname>type</varname>.</para>
		</listitem>
	</itemizedlist>

	<para>
		Una forma común de generalizar las operaciones tradicionales a los tipos temporales es aplicar la operación en <emphasis>cada instante</emphasis>, lo que da un valor temporal como resultado. En ese caso, la operación sólo se define en la intersección de las extensiones temporales de los operandos; si las extensiones temporales son disjuntas, el resultado es nulo. Por ejemplo, los operadores de comparación temporal, como <varname>#&lt;</varname>, determinan si los valores tomados por sus operandos en cada instante satisfacen la condición y devuelven un booleano temporal. A continuación se dan ejemplos de las diversas generalizaciones de los operadores.
	</para>
	<programlisting language="sql" xml:space="preserve">
-- Comparación temporal
SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';
-- {[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';
-- NULL

-- Adición temporal
SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';
-- [3@2001-01-02, 3@2001-01-03)

-- Intersección temporal
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}

-- Distancia temporal
SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;
tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';
-- [0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)
</programlisting>

	<para>
		Otro requisito común es determinar si los operandos satisfacen <emphasis>alguna vez</emphasis> o <emphasis>siempre</emphasis> una condición con respecto a una operación. Estos se pueden obtener aplicando los operadores de comparación alguna vez/siempre. Estos operadores se indican anteponiendo los operadores de comparación tradicionales con, respectivamente, <varname>?</varname> (alguna vez) y <varname>%</varname> (siempre). A continuación se dan ejemplos de operadores de comparación alguna vez y siempre.
	</para>
	<programlisting language="sql" xml:space="preserve">
-- ¿Se cruzan los operandos alguna vez?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;
-- true

-- ¿Se cruzan los operandos siempre?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;
-- true

-- ¿Es el operando izquierdo alguna vez menor que el derecho?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
  tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;
-- true

-- ¿Es el operando izquierdo siempre menor que el derecho?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
  tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;
-- true
</programlisting>
	<para>
		Por razones de eficiencia, algunas operaciones comunes con la semántica alguna vez o siempre se proporcionan de forma nativa. Por ejemplo, la función <varname>intersects</varname> determina si hay un instante en el que los dos argumentos se cruzan espacialmente.
	</para>

	<para>
		A continuación describimos las funciones y operadores para tipos temporales. Para mayor concisión, en los ejemplos usamos principalmente secuencias compuestas por dos instantes.
	</para>

	<sect1 id="input_output_temporal_types">
		<title>Entrada/salida de tipos temporales</title>
			<para>
				MobilityDB generaliza los formatos de entrada/salida Well-Known Text (WKT), Moving Features JSON (MF-JSON) y Well-Known Binary (WKB) del Open Geospatial Consortium para todos los tipos temporales. Presentamos a continuación las funciones de entrada y salida para los tipos temporales. Empezamos describiendo formato WKT.
			</para>

		<para>
			Un valor de instante es un par de la forma <varname>v@t</varname>, donde <varname>v</varname> es un valor del tipo de base y <varname>t</varname> es un valor de <varname>timestamptz</varname>. Ejemplos de entrada de valores de instante son los siguientes:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool 'true@2001-01-01 08:00:00';
SELECT tint '1@2001-01-01 08:00:00';
SELECT tfloat '1.5@2001-01-01 08:00:00';
SELECT ttext 'AAA@2001-01-01 08:00:00';
SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';
</programlisting>

		<para>
			Un valor de secuencia es un conjunto de valores <varname>v1@t1,...,vn@tn</varname> delimitado por límites superior e inferior, que pueden ser inclusivo (representados por &lsquo;<varname>[</varname>&rsquo; y &lsquo;<varname>]</varname>&rsquo;) o exclusivos (representados por &lsquo;<varname>(</varname>&rsquo; y &lsquo;<varname>)</varname>&rsquo;). Un valor de secuencia compuesto por una sola pareja <varname>v@t</varname> se denomina <emphasis>secuencia instantánea</emphasis>. Los valores de secuencia tienen una <emphasis>función de interpolación</emphasis> asociada que puede ser discreta, lineal o escalonada. Por definición, los límites inferior y superior de una secuencia instantánea o de un valor de secuencia con interpolación discreta son inclusivos. La extensión temporal de un valor de secuencia con interpolación discreta es un conjunto de marcas de tiempo. Ejemplos de valores de secuencia con interpolación discreta son los siguientes.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00}'; -- Instantaneous sequence
SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';
SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';
SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
</programlisting>
		<para>
			La extensión temporal de un valor de secuencia con interpolación lineal o escalonada es un período definido por el primer y el últimpo instante, así como por los límites inferior y superior. Ejemplos de valores de secuencia con interpolación lineal son los siguientes:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';
SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';
SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';
SELECT tfloat '[1.5@2001-01-01 08:00:00]'; -- Instantaneous sequence
SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';
SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';
SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,
  Point(0 0)@2017-01-01 08:10:00)';
</programlisting>
		<para>Los valores de secuencia cuyo tipo base es continuo pueden especificar que la interpolación es escalonada con el prefijo <varname>Interp=Stepwise</varname>. Si no se especifica, se supone que la interpolación es lineal por defecto. A continuación se dan ejemplos de valores de secuencia con interpolación escalonada:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01 08:00:00, 3@2001-01-01 08:10:00]';
SELECT tgeompoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
  Point(1 1)@2017-01-01 08:05:00, Point(1 1)@2017-01-01 08:10:00)';
SELECT tgeompoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
 Point(1 1)@2017-01-01 08:05:00, Point(0 0)@2017-01-01 08:10:00)';
ERROR:  Invalid end value for temporal sequence with stepwise interpolation
SELECT tgeogpoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
  Point(1 1)@2017-01-01 08:10:00]';
</programlisting>
		<para>
			Los dos últimos instantes de un valor de secuencia con interpolación discreta y límite superior exclusivo deben tener el mismo valor base, como se muestra en el segundo y tercer ejemplo anteriores.
		</para>
		<para>
			Un <emphasis>valor de conjunto de secuencias</emphasis> es un conjunto <varname>{v1,...,vn}</varname> donde cada <varname>vi</varname> es un valor de secuencia. La interpolación de los valores conjunto de secuencias solo puede ser lineal o escalonada, no discreta. Todas las secuencias que componen un valor de conjunto de secuencias deben tener la misma interpolación. La extensión temporal de un valor de conjunto de secuencias es un conjunto de períodos. Ejemplos de valores de conjunto de secuencias con interpolación lineal son los siguientes:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),
  [true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';
SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),
  [2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,
  3@2001-01-06 08:00:00]}';
SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),
  [CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';
SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
  [Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
  [Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
</programlisting>
		<para>
			Los valores de conjunto de secuencias cuyo tipo base es continuo pueden especificar que la interpolación es escalonada con el prefijo <varname>Interp=Stepwise</varname>. Si no se especifica, se supone que la interpolación es lineal por defecto. A continuación se dan ejemplos de valores de conjunto de secuencias con interpolación escalonada:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00,
  2@2001-01-04 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tgeompoint 'Interp=Stepwise;{[Point(0 0)@2017-01-01 08:00:00,
  Point(0 1)@2017-01-01 08:05:00], [Point(0 1)@2017-01-01 08:10:00,
  Point(0 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint 'Interp=Stepwise;{[Point(0 0)@2017-01-01 08:00:00,
  Point(0 1)@2017-01-01 08:05:00], [Point(0 1)@2017-01-01 08:10:00,
  Point(0 1)@2017-01-01 08:15:00)}';
</programlisting>

		<para>
			Para los puntos temporales, es posible especificar el identificador de referencia espacial (SRID) utilizando la representación extendida de texto conocido (EWKT) de la siguiente manera:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'
</programlisting>
		<para>
			Todas las geometrías componentes serán entonces del SRID dado. Además, cada geometría componente puede especificar su SRID con el formato EWKT como en el siguiente ejemplo
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'
</programlisting>
		<para>
			Se genera un error si las geometrías componentes no están todas en el mismo SRID o si el SRID de una geometría componente es diferente al del punto temporal.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';
-- ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,
  SRID=4326;Point(0 1)@2000-01-02]'
-- ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
</programlisting>

		<para>
			Damos a continuación las funciones de entrada/salida en formato Moving Features JSON (MF-JSON) y binario conocido (WKB) para los tipos alfanuméricos temporales. Las funciones correspondientes para los puntos temporales se detallan en la <xref linkend="tpoint_inout" />.
		</para>

		<itemizedlist>
			<listitem id="temporal_asMFJSON">
				<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>Obtener la representación JSON de características móviles (Moving Features JSON o MF-JSON)</para>
				<para><varname>asMFJSON(ttype,options integer=0,flags integer=0,maxdecdigits integer=15): bytea</varname></para>
				<para>El argumento <varname>options</varname> puede usarse para agregar un cuadro delimitador en la salida MFJSON:</para>
				<itemizedlist>
						<listitem><para>0: significa que no hay opción (valor por defecto)</para></listitem>
						<listitem><para>1: cuadro delimitador MFJSON</para></listitem>
				</itemizedlist>
				<para>El argumento <varname>flags</varname> puede usarse para personalizar la salida JSON, por ejemplo, para producir una salida JSON fácil de leer (para lectores humanos). Consulte la documentación de la biblioteca <varname>json-c</varname>. Los valores típicos son los siguientes:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: JSON_C_TO_STRING_SPACED</para></listitem>
					<listitem><para>2: JSON_C_TO_STRING_PRETTY</para></listitem>
				</itemizedlist>
				<para>El argumento <varname>maxdecdigits</varname> puede usarse para establecer el número máximo de decimales en la salida de los valores en punto flotante (por defecto 15).</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asMFJSON(tbool 't@2019-01-01 18:00:00', 1);
/* {"type":"MovingBoolean","stBoundedBy":{"period":{"begin":"2019-01-01 18:00:00+01",
   "end":"2019-01-01 18:00:00+01","lower_inc":true,"upper_inc":true}},"values":true,
   "datetimes":"2019-01-01T18:00:00+01","interpolations":"Discrete"} */
SELECT asMFJSON(tint '{10@2019-01-01 18:00:00, 25@2019-01-01 18:10:00}', 1); */
/* {"type":"MovingInteger","stBoundedBy":{"bbox":[10,25],
   "period":{"begin":"2019-01-01 18:00:00+01","end":"2019-01-01 18:10:00+01"}},
   "values":[10,25],"datetimes":["2019-01-01T18:00:00+01","2019-01-01T18:10:00+01"],
   "interpolations":["Discrete"]} */
SELECT asMFJSON(tfloat '[10.5@2019-01-01 18:00:00+02, 25.5@2019-01-01 18:10:00+02]');
/* {"type":"MovingFloat","values":[10.5,25.5],
   "datetimes":["2019-01-01T17:00:00+01","2019-01-01T17:10:00+01"],
   "lower_inc":true,"upper_inc":true,"interpolations":["Linear"]} */
SELECT asMFJSON(ttext '{[walking@2019-01-01 18:00:00+02,
  driving@2019-01-01 18:10:00+02]}');
/* {"type":"MovingText","sequences":[{"values":["walking","driving"],
   "datetimes":["2019-01-01T17:00:00+01","2019-01-01T17:10:00+01"],
   "lower_inc":true,"upper_inc":true}],"interpolations":["Stepwise"]} */
</programlisting>
			</listitem>

			<listitem id="temporal_asBinary">
				<indexterm><primary><varname>asBinary</varname></primary></indexterm>
				<para>Obtener la representación binaria conocida (Well-Known Binary o WKB)</para>
				<para><varname>asBinary(ttype): bytea</varname></para>
				<para><varname>asBinary(ttype,endian text): bytea</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asBinary(tbool 'true@2001-01-01');
-- \x010d000101009c57d3c11c0000
SELECT asBinary(tint '1@2001-01-01', 'XDR');
-- \x000016010000000100001cc1d3579c00
SELECT asBinary(tfloat '1.5@2001-01-01');
-- \x01130081000000000000f83f009c57d3c11c0000
SELECT asBinary(ttext 'AAA@2001-01-01');
-- \x01170001040000000000000041414100009c57d3c11c0000
</programlisting>
			</listitem>

			<listitem id="temporal_asHexWKB">
				<indexterm><primary><varname>asHexWKB</varname></primary></indexterm>
				<para>Obtener la representación hexadecimal binaria conocida (HexWKB) en formato texto</para>
				<para><varname>asHexWKB(ttype): text</varname></para>
				<para><varname>asHexWKB(ttype,endian text): text</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza NDR.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asHexWKB(tbool 'true@2001-01-01');
-- 010D000101009C57D3C11C0000
SELECT asHexWKB(tint '1@2001-01-01', 'XDR');
-- 000016010000000100001CC1D3579C00
SELECT asHexWKB(tfloat '1.5@2001-01-01');
-- 01130081000000000000F83F009C57D3C11C0000
SELECT asHexWKB(ttext 'AAA@2001-01-01');
-- 01170001040000000000000041414100009C57D3C11C0000
</programlisting>
			</listitem>

			<listitem id="tboolFromBinary">
				<indexterm><primary><varname>tboolFromBinary</varname></primary></indexterm>
				<para>Entrar un booleano temporal de su representación binaria conocida (WKB)</para>
				<para><varname>tboolFromBinary(bytea): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tboolFromBinary('\x010d000101009c57d3c11c0000');
-- t@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tintFromBinary">
				<indexterm><primary><varname>tintFromBinary</varname></primary></indexterm>
				<para>Entrar un entero temporal de su representación binaria conocida (WKB)</para>
				<para><varname>tintFromBinary(bytea): tint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tintFromBinary('\x000016010000000100001cc1d3579c00');
-- 1@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tfloatFromBinary">
				<indexterm><primary><varname>tfloatFromBinary</varname></primary></indexterm>
				<para>Entrar un flotante temporal de su representación binaria conocida (WKB)</para>
				<para><varname>tfloatFromBinary(bytea): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloatFromBinary('\x01130081000000000000f83f009c57d3c11c0000');
-- 1.5@2001-01-01
</programlisting>
			</listitem>

			<listitem id="ttextFromBinary">
				<indexterm><primary><varname>ttextFromBinary</varname></primary></indexterm>
				<para>Entrar un texto temporal de su representación binaria conocida (WKB)</para>
				<para><varname>ttextFromBinary(bytea): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ttextFromBinary('\x01170001040000000000000041414100009c57d3c11c0000');
-- "AAA"@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tboolFromHexWKB">
				<indexterm><primary><varname>tboolFromHexWKB</varname></primary></indexterm>
				<para>Entrar un booleano temporal de su representación hexadecimal binaria conocida (HexWKB)</para>
				<para><varname>tboolFromHexWKB(text): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tboolFromHexWKB('010D000101009C57D3C11C0000');
-- t@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tintFromHexWKB">
				<indexterm><primary><varname>tintFromHexWKB</varname></primary></indexterm>
				<para>Entrar un entero temporal de su representación hexadecimal binaria conocida (HexWKB)</para>
				<para><varname>tintFromHexWKB(text): tint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tintFromHexWKB('000016010000000100001CC1D3579C00');
-- 1@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tfloatFromHexWKB">
				<indexterm><primary><varname>tfloatFromHexWKB</varname></primary></indexterm>
				<para>Entrar un flotante temporal de su representación hexadecimal binaria conocida (HexWKB)</para>
				<para><varname>tfloatFromHexWKB(text): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloatFromHexWKB('01130081000000000000F83F009C57D3C11C0000');
-- 1.5@2001-01-01
</programlisting>
			</listitem>

			<listitem id="ttextFromHexWKB">
				<indexterm><primary><varname>ttextFromHexWKB</varname></primary></indexterm>
				<para>Entrar un texto temporal de su representación hexadecimal binaria conocida (HexWKB)</para>
				<para><varname>ttextFromHexWKB(text): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ttextFromHexWKB('01170001040000000000000041414100009C57D3C11C0000');
-- "AAA"@2001-01-01
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="constructor_temporal_tyes">
		<title>Funciones de constructor</title>

		<para>
			Cada tipo temporal tiene una función de constructor con el mismo nombre que el tipo y un sufijo para el subtipo, donde los sufijos &lsquo;<varname>_inst</varname>&rsquo;, &lsquo;<varname>_discseq</varname>&rsquo;, &lsquo;<varname>_seq</varname>&rsquo; y &lsquo;<varname>_seqset</varname>&rsquo; corresponden, respectivamente, a los subtipos instante, secuencia con interpolación discreta, secuencia con interpolación linear o escalonada y conjunto de secuencias. Ejemplos son <varname>tint_seq</varname> o <varname>tgeompoint_seqset</varname>. El uso de la función de constructor suele ser más conveniente que escribir una constante literal.
		</para>

		<itemizedlist>
			<listitem>
				<para>Un primer conjunto de funciones tiene dos argumentos, un tipo base y un tipo de tiempo, donde el último es un valor de <varname>timestamptz</varname>, <varname>timestampset</varname>, <varname>period</varname> o <varname>periodset</varname> para construir, respectivamente, un valor de subtipo instante, una secuencia con interpolación discreta, una secuencia con interpolación linear o escalonada o un conjunto de secuencias. Las funciones para valores de secuencia o de conjunto de secuencias con tipo base continuo tienen además un tercer argumento opcional que es un booleano para indicar si el valor temporal resultante tiene interpolación lineal o no. Por defecto, este argumento es verdadero si no se especifica.</para>
			</listitem>

			<listitem>
				<para>Otro conjunto de funciones para valores de secuencia con interpolación discreta tiene un solo argumento, que es una matriz de valores de instante correspondientes.</para>
			</listitem>

			<listitem>
				<para>Otro conjunto de funciones para valores de secuencia tiene un argumento para la matriz de valores de instante correspondiente y dos argumentos booleanos opcionales que indican, respectivamente, si los límites izquierdo y derecho son inclusivos o exclusivos. Si estos argumentos no se especifican, se supone que son verdaderos por defecto. Además, las funciones para valores de secuencia con tipo base continuo tienen un argumento booleano adicional que indica si la interpolación es lineal o no. Si este argumento no se especifica, se asume que es verdadero por defecto.</para>
			</listitem>

			<listitem>
				<para>Otro conjunto de funciones para valores de conjuntos de secuencias tiene un único argumento, que es una matriz de valores de secuencia correspondientes. Para valores de secuencia con tipo de base continuo, la interpolación del valor temporal resultante depende de la interpolación de las secuencias que la componen. Se genera un error si las secuencias que componen la matriz tienen interpolación diferentes.</para>
			</listitem>

			<listitem>
				<para>Finalmente, otro conjunto de funciones para valores de conjunto de secuencias tiene como primer argumento una matriz de valores de los valores instantáneos correspondientes, y dos argumentos que establecen una distancia máxima y un intervalo de tiempo máximo tal que se introduce una brecha entre la composición de secuencias del resultado siempre que dos instantes de entrada consecutivos tengan una distancia o un intervalo de tiempo superior a estos valores. Para puntos temporales, la distancia se especifica en unidades del SRID subyacente. Estos dos argumentos de brechas son opcionales y, si no se dan, se asume un valor cero, que no se tiene en cuenta para determinar las brechas en el resultado. Además, las funciones para valores de secuencia con tipo de base continuo tienen un argumento adicional de valor booleano que indica si la interpolación es lineal o no. Si no se especifica este argumento, se asume que es verdadero por defecto.</para>
			</listitem>
		</itemizedlist>

		<para>A continuación, damos las funciones de constructor para los distintos subtipos.</para>

		<itemizedlist>
			<listitem id="ttype_inst">
				<indexterm><primary><varname>ttype_inst</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo instante</para>
				<para><varname>ttype_inst(base,timestamptz): ttype_inst</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_inst(true, '2001-01-01');
SELECT tint_inst(1, '2001-01-01');
SELECT tfloat_inst(1.5, '2001-01-01');
SELECT ttext_inst('AAA', '2001-01-01');
SELECT tgeompoint_inst('Point(1 1)', '2001-01-01');
SELECT tgeogpoint_inst('SRID=7844;Point(1 1)', '2001-01-01');
</programlisting>
			</listitem>

			<listitem id="ttype_discseq">
				<indexterm><primary><varname>ttype_discseq</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo secuencia con interpolación discreta</para>
				<para><varname>ttype_discseq(base,timestampset): ttype_discseq</varname></para>
				<para><varname>ttype_discseq(ttype_inst[]): ttype_discseq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_discseq(true, '{2001-01-01, 2001-01-02}');
SELECT tint_discseq(1, '{2001-01-01, 2001-01-02}');
SELECT tfloat_discseq(1.5, '{2001-01-01, 2001-01-02}');
SELECT ttext_discseq('AAA', '{2001-01-01, 2001-01-02}');
SELECT tgeompoint_discseq('Point(1 1)', '{2001-01-01, 2001-01-02}');
SELECT tgeogpoint_discseq('SRID=7844;Point(1 1)', '{2001-01-01, 2001-01-02}');
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_discseq(ARRAY[tbool 'true@2001-01-01 08:00:00','false@2001-01-01 08:05:00']);
SELECT tint_discseq(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);
SELECT tfloat_discseq(ARRAY[tfloat '1.0@2001-01-01 08:00:00', '2.0@2001-01-01 08:05:00']);
SELECT ttext_discseq(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);
SELECT tgeompoint_discseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);
SELECT tgeogpoint_discseq(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',
  'Point(2 2)@2001-01-01 08:05:00']);
</programlisting>
			</listitem>

			<listitem id="ttype_seq">
				<indexterm><primary><varname>ttype_seq</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo secuencia con interpolación linear o escalonada</para>
				<para><varname>tdisc_seq(base,period): tdisc_seq</varname></para>
				<para><varname>tcont_seq(base,period,linear=true): tcont_seq</varname></para>
				<para><varname>tdisc_seq(ttype_inst[],left_inc=true,right_inc=true}): tdisc_seq</varname></para>
				<para><varname>tcont_seq(ttype_inst[],left_inc=true,right_inc=true,linear=true}): tcont_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seq(true, '[2001-01-01, 2001-01-02]');
SELECT tint_seq(1, '[2001-01-01, 2001-01-02]');
SELECT tfloat_seq(1.5, '[2001-01-01, 2001-01-02]', false);
SELECT ttext_seq('AAA', '[2001-01-01, 2001-01-02]');
SELECT tgeompoint_seq('Point(0 0)', '[2001-01-01, 2001-01-02]', false);
SELECT tgeogpoint_seq('SRID=7844;Point(0 0)', '[2001-01-01, 2001-01-02]');
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],
  true, true);
SELECT tint_seq(ARRAY[tint(2,'2001-01-01 08:00:00'), tint(2,'2001-01-01 08:10:00')],
  true, false);
SELECT tfloat_seq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
  '1@2001-01-03 08:10:00'], true, false);
SELECT tfloat_seq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
  '1@2001-01-03 08:10:00'], true, true, false);
SELECT ttext_seq(ARRAY[ttext('AAA', '2001-01-01 08:00:00'),
  ttext('BBB', '2001-01-03 08:05:00'), ttext('BBB', '2001-01-03 08:10:00')]);
SELECT tgeompoint_seq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);
SELECT tgeogpoint_seq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 0)@2001-01-03 08:05:00'], true, true, false);
</programlisting>
			</listitem>

			<listitem id="ttype_seqset">
				<indexterm><primary><varname>ttype_seqset</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo conjunto de secuencias</para>
				<para><varname>tdisc_seqset(base,periodset): tdisc_seqset</varname></para>
				<para><varname>tcont_seqset(base,periodset,linear=true): tcont_seqset</varname></para>
				<para><varname>ttype_seqset(ttype_seq[]): ttype_seqset</varname></para>
				<para><varname>tint_seqset_gaps(tint_inst[],maxdist=0.0,maxt='0 minutes'): tint_seqset</varname></para>
				<para><varname>tcont_seqset_gaps(tcont_inst[],linear=true,maxdist=0.0,maxt='0 minutes'):</varname></para>
				<para><varname>  tcont_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seqset(true, '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tint_seqset(1, '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tfloat_seqset(1.5, '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT ttext_seqset('AAA', '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tgeompoint_seqset('Point(0 0)', '{[2001-01-01, 2001-01-02],
  [2001-01-03, 2001-01-04]}', false);
SELECT tgeogpoint_seqset('SRID=7844;Point(0 0)', '{[2001-01-01, 2001-01-02],
  [2001-01-03, 2001-01-04]}', false);
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seqset(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',
  '[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);
SELECT tint_seqset(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,
  2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);
SELECT tfloat_seqset(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,
  2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT tfloat_seqset(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
  2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
  'Interp=Stepwise;[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT ttext_seqset(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',
  '[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);
SELECT tgeompoint_seqset(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,
  Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',
  '[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);
SELECT tgeogpoint_seqset(ARRAY[tgeogpoint
  'Interp=Stepwise;[Point(0 0)@2001-01-01 08:00:00, Point(0 0)@2001-01-01 08:05:00)',
  'Interp=Stepwise;[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);
SELECT tfloat_seqset(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
  2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
  '[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
-- ERROR:  Input sequences must have the same interpolation
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tint_seqset_gaps(ARRAY[tint '1@2000-01-01', '3@2000-01-02', '4@2000-01-03',
  '5@2000-01-05'], 1, '1 day');
-- {[1@2000-01-01], [3@2000-01-02, 4@2000-01-03], [5@2000-01-05]}
SELECT asText(tgeompoint_seqset_gaps(ARRAY[tgeompoint 'Point(1 1)@2000-01-01',
  'Point(2 2)@2000-01-02', 'Point(3 2)@2000-01-03', 'Point(3 2)@2000-01-05'],
  true, 1, '1 day'));
/* {[POINT(1 1)@2000-01-01], [POINT(2 2)@2000-01-02, POINT(3 2)@2000-01-03],
   [POINT(3 2)@2000-01-05]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="casting_temporal_types">
		<title>Conversión de tipos</title>

		<para>Un valor temporal se puede convertir en un tipo compatible usando la notación <varname>CAST(ttype1 AS ttype2)</varname> o <varname>ttype1::ttype2</varname>.</para>
		<itemizedlist>
			<listitem id="temporal_period">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un valor temporal a un período</para>
				<para><varname>ttype::period</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::period;
-- [2001-01-01, 2001-01-03]
SELECT ttext '(A@2000-01-01, B@2000-01-03, C@2000-01-05]'::period;
-- (2000-01-01,2000-01-05]
</programlisting>
			</listitem>

			<listitem id="tnumber_span">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un número temporal a un rango</para>
				<para><varname>tnumber::span</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::intspan;
-- [1, 3)
SELECT tfloat '(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::floatspan;
-- (1, 3]
SELECT tfloat 'Interp=Stepwise;(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::floatspan;
-- [1, 3]
</programlisting>
			</listitem>

			<listitem id="tnumber_tbox">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un número temporal number a un <varname>tbox</varname></para>
				<para><varname>tnumber::tbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tbox;
-- TBOX XT([1,2],[2001-01-01,2001-01-03])
SELECT tfloat '(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::tbox;
-- TBOX XT((1,3],(2001-01-01,2001-01-05])
</programlisting>
			</listitem>

			<listitem id="tpoint_stbox">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un punto temporal a un <varname>stbox</varname></para>
				<para><varname>tpoint::stbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]'::stbox;
-- STBOX XT((3,3),[2001-01-01, 2001-01-03],((1,1)))
SELECT tgeogpoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]'::stbox;
/* SRID=4326;GEODSTBOX XT(
  ((0.9972609281539917,0.017449747771024704,0.01745240643728351),
  (0.9996954202651978,0.05226423218846321,0.05233595624294383)),
  [2001-01-01, 2001-01-03]) */
</programlisting>
			</listitem>

			<listitem id="tint_tfloat">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un entero temporal en un flotante temporal</para>
				<para><varname>tint::tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;
-- [1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]
SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;
-- Interp=Stepwise;[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]
</programlisting>
			</listitem>

			<listitem id="tfloat_tint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un flotante temporal en un entero temporal</para>
				<para><varname>tfloat::tint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- [1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]
SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer
</programlisting>
			</listitem>

			<listitem id="tgeompoint_tgeogpoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un punto geométrico temporal en un punto geográfico temporal</para>
				<para><varname>tgeompoint::tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);
-- {POINT(0 0)@2001-01-01}
</programlisting>
			</listitem>

			<listitem id="tgeogpoint_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un punto geográfico temporal en un punto geométrico temporal</para>
				<para><varname>tgeogpoint::tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);
-- {[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}
</programlisting>
			</listitem>
		</itemizedlist>

		<para>
			Una forma común de almacenar puntos temporales en PostGIS es representarlos como geometrías de tipo <varname>LINESTRING M</varname> y utilizar la dimensión M para codificar marcas de tiempo como segundos desde 1970-01-01 00:00:00. Estas geometrías aumentadas con tiempo, llamadas <emphasis>trayectorias</emphasis>, se pueden validar con la función <varname>ST_IsValidTrajectory</varname> para verificar quel el valor M está creciendo de cada vértice al siguiente. Las trayectorias se pueden manipular con las funciones <varname>ST_ClosestPointOfApproach</varname>, <varname>ST_DistanceCPA</varname> y <varname>ST_CPAWithin</varname>. Los valores de puntos temporales se pueden convertir a/desde trayectorias de PostGIS.
		</para>

		<itemizedlist>
			<listitem id="tgeompoint_geometry">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un punto temporal en una trayectoria PostGIS</para>
				<para><varname>tgeompoint::geometry</varname></para>
				<para><varname>tgeogpoint::geography</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);
-- POINT M (0 0 978307200)
SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(1 1)@2001-01-03}')::geometry);
-- MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)
SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);
-- LINESTRING M (0 0 978307200,1 1 978393600)
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
  [Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
/* MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),
  (1 1 978652800,0 0 978739200)) */
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
  [Point(1 1)@2001-01-03],
  [Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
/* GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
   POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200)) */
</programlisting>
			</listitem>

			<listitem id="geometry_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir una trayectoria PostGIS a un punto temporal</para>
				<para><varname>geometry::tgeompoint</varname></para>
				<para><varname>geography::tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,
  1 1 978480000)'::tgeompoint);
-- [POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03]
SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
  POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);
/* {[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],
   [POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones de accesor</title>
		<itemizedlist>

			<listitem id="ttype_memSize">
				<indexterm><primary><varname>memSize</varname></primary></indexterm>
				<para>Obtener el tamaño de la memoria en bytes</para>
				<para><varname>memSize(ttype): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT memSize(tint '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- 280
</programlisting>
			</listitem>

			<listitem id="tempSubtype">
				<indexterm><primary><varname>tempSubtype</varname></primary></indexterm>
				<para>Obtener el subtipo temporal</para>
				<para><varname>tempSubtype(ttype): {'Instant','Sequence','SequenceSet'}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tempSubtype(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Sequence
</programlisting>
			</listitem>

			<listitem id="interpolation">
				<indexterm><primary><varname>interpolation</varname></primary></indexterm>
				<para>Obtener la interpolación</para>
				<para><varname>interpolation(ttype): {'Discrete','Stepwise','Linear'}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT interpolation(tfloat '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- Discrete
SELECT interpolation(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Stepwise
SELECT interpolation(tfloat '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Linear
SELECT interpolation(tfloat 'Interp=Stepwise;[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Stepwise
SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2001-01-01,
  Point(2 2)@2001-01-02, Point(3 3)@2001-01-03]');
-- Stepwise
</programlisting>
			</listitem>

			<listitem id="getValue">
				<indexterm><primary><varname>getValue</varname></primary></indexterm>
				<para>Obtener el valor</para>
				<para><varname>getValue(ttype_inst): base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getValue(tint '1@2001-01-01');
-- 1
SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2001-01-01'));
-- POINT(0 0)
</programlisting>
			</listitem>

			<listitem id="getValues">
				<indexterm><primary><varname>getValues</varname></primary></indexterm>
				<para>Obtener los valores</para>
				<para><varname>getValues(ttype): {base[],floatspan[],geo}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getValues(tint '[1@2001-01-01, 2@2001-01-03]');
-- {1,2}
SELECT getValues(tfloat '[1@2001-01-01, 2@2001-01-03)');
-- {[1,2)}
SELECT getValues(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 4@2001-01-05)}');
-- {[1,2),[3,4)}
SELECT getValues(tfloat 'Interp=Stepwise;{[1@2001-01-01, 2@2001-01-02],
  [3@2001-01-03, 4@2001-01-05]}');
-- {"[1,1]","[2,2]","[3,3]","[4,4]"}
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04)}'));
-- LINESTRING(0 0,0 1,1 1)
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(2 2)@2001-01-04)}'));
-- MULTILINESTRING((0 0,0 1),(1 1,2 2)
SELECT ST_AsText(getValues(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2001-01-01,
  Point(0 1)@2001-01-02], [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04]}'));
-- GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))
SELECT ST_AsText(getValues(tgeompoint '{Point(0 0)@2001-01-01, Point(0 1)@2001-01-02}'));
-- MULTIPOINT(0 0,0 1)
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
  [Point(2 1)@2001-01-05, Point(2 2)@2001-01-06)}'));
-- GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))
</programlisting>
			</listitem>

			<listitem id="startValue">
				<indexterm><primary><varname>startValue</varname></primary></indexterm>
				<para>Obtener el valor inicial</para>
				<para><varname>startValue(ttype): base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startValue(tfloat '(1@2001-01-01, 2@2001-01-03)');
-- 1
</programlisting>
			</listitem>

			<listitem id="endValue">
				<indexterm><primary><varname>endValue</varname></primary></indexterm>
				<para>Obtener el valor final</para>
				<para><varname>endValue(ttype): base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT endValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</programlisting>
			</listitem>

			<listitem id="minValue">
				<indexterm><primary><varname>minValue</varname></primary></indexterm>
				<para>Obtener el valor mínimo</para>
				<para><varname>minValue(torder): base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minValue(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1
</programlisting>
			</listitem>

			<listitem id="maxValue">
				<indexterm><primary><varname>maxValue</varname></primary></indexterm>
				<para>Obtener el valor máximo</para>
				<para><varname>maxValue(torder): base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT maxValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</programlisting>
			</listitem>

			<listitem id="minInstant">
				<indexterm><primary><varname>minInstant</varname></primary></indexterm>
				<para>Obtener el instante con el valor máximo</para>
				<para><varname>minInstant(torder): base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no. Si varios instantes tienen el valor mínimo, se devuelve el primero.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minInstant(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1@2001-01-01
</programlisting>
			</listitem>

			<listitem id="maxInstant">
				<indexterm><primary><varname>maxInstant</varname></primary></indexterm>
				<para>Obtener el instante con el valor máximo</para>
				<para><varname>maxInstant(torder): base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no. Si varios instantes tienen el valor máximo, se devuelve el primero.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT maxInstant(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5@2001-01-05
</programlisting>
			</listitem>

			<listitem id="valueSpan">
				<indexterm><primary><varname>valueSpan</varname></primary></indexterm>
				<para>Obtener el rango de valores</para>
				<para><varname>valueSpan(tnumber): numspan</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT valueSpan(tfloat '{[2@2001-01-01, 1@2001-01-03), [4@2001-01-03, 6@2001-01-05)}');
-- [1,6]
SELECT valueSpan(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [1,3])
</programlisting>
			</listitem>

			<listitem id="valueAtTimestamp">
				<indexterm><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Obtener el valor en una marca de tiempo</para>
				<para><varname>valueAtTimestamp(ttype,timestamptz): base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT valueAtTimestamp(tfloat '[1@2001-01-01, 4@2001-01-04)', '2001-01-02');
-- 2
</programlisting>
			</listitem>

			<listitem id="getTimestamp">
				<indexterm><primary><varname>getTimestamp</varname></primary></indexterm>
				<para>Obtener la marca de tiempo</para>
				<para><varname>getTimestamp(ttype_inst): timestamptz</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getTimestamp(tint '1@2001-01-01');
-- 2001-01-01
</programlisting>
			</listitem>

			<listitem id="getTime">
				<indexterm><primary><varname>getTime</varname></primary></indexterm>
				<para>Obtener el tiempo</para>
				<para><varname>getTime(ttype): periodset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getTime(tint '[1@2001-01-01, 1@2001-01-15)');
-- {[2001-01-01, 2001-01-15)}
</programlisting>
			</listitem>

			<listitem id="ttype_duration">
				<indexterm><primary><varname>duration</varname></primary></indexterm>
				<para>Obtener el intervalo de tiempo</para>
				<para><varname>duration(ttype): interval</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT duration(tfloat '[1@2001-01-01, 2@2001-01-03, 2@2001-01-05)');
-- 4 days
SELECT duration(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}');
-- 3 days
</programlisting>
			</listitem>

			<listitem id="ttype_timespan">
				<indexterm><primary><varname>timespan</varname></primary></indexterm>
				<para>Obtener el intervalo de tiempo ignorando las posibles brechas de tiempo</para>
				<para><varname>timespan(ttype): interval</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timespan(tfloat '{1@2001-01-01, 2@2001-01-03, 2@2001-01-05}');
-- 4 days
SELECT timespan(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}');
-- 4 days
</programlisting>
			</listitem>

			<listitem id="ttype_period">
				<indexterm><primary><varname>period</varname></primary></indexterm>
				<para>Obtener el período en el que está definido el valor temporal ignorando las posibles brechas de tiempo</para>
				<para><varname>period(ttype): period</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT period(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [2001-01-01, 2001-01-05]
SELECT period(tfloat '{[1@2001-01-01, 1@2001-01-02), [2@2001-01-03, 3@2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</programlisting>
			</listitem>

			<listitem id="numInstants">
				<indexterm><primary><varname>numInstants</varname></primary></indexterm>
				<para>Obtener el número de instantes diferentes</para>
				<para><varname>numInstants(ttype): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3
</programlisting>
			</listitem>

			<listitem id="startInstant">
				<indexterm><primary><varname>startInstant</varname></primary></indexterm>
				<para>Obtener el instante inicial</para>
				<para><varname>startInstant(ttype): ttype_inst</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02),
  (2@2000-01-02, 3@2000-01-03)}');
-- 1@2000-01-01
</programlisting>
			</listitem>

			<listitem id="endInstant">
				<indexterm><primary><varname>endInstant</varname></primary></indexterm>
				<para>Obtener el instante final</para>
				<para><varname>endInstant(ttype): ttype_inst</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3@2000-01-03
</programlisting>
			</listitem>

			<listitem id="instantN">
				<indexterm><primary><varname>instantN</varname></primary></indexterm>
				<para>Obtener el enésimo instante diferente</para>
				<para><varname>instantN(ttype,integer): ttype_inst</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);
-- 3@2000-01-03
</programlisting>
			</listitem>

			<listitem id="instants">
				<indexterm><primary><varname>instants</varname></primary></indexterm>
				<para>Obtener los instantes diferentes</para>
				<para><varname>instants(ttype): ttype_inst[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- {"1@2000-01-01","2@2000-01-02","3@2000-01-03"}
</programlisting>
			</listitem>

			<listitem id="ttype_numTimestamps">
				<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
				<para>Obtener el número de marcas de tiempo diferentes</para>
				<para><varname>numTimestamps(ttype): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numTimestamps(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 3
</programlisting>
			</listitem>

			<listitem id="ttype_startTimestamp">
				<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
				<para>Obtener la marca de tiempo inicial</para>
				<para><varname>startTimestamp(ttype): timestamptz</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startTimestamp(tfloat '[1@2001-01-01, 2@2001-01-03)');
-- 2001-01-01
</programlisting>
			</listitem>

			<listitem id="ttype_endTimestamp">
				<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
				<para>Obtener la marca de tiempo final</para>
				<para><varname>endTimestamp(ttype): timestamptz</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT endTimestamp(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2001-01-05
</programlisting>
			</listitem>

			<listitem id="ttype_timestampN">
				<indexterm><primary><varname>timestampN</varname></primary></indexterm>
				<para>Obtener la enésima marca de tiempo diferente</para>
				<para><varname>timestampN(ttype,integer): timestamptz</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timestampN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 3);
-- 2001-01-05
</programlisting>
			</listitem>

			<listitem id="ttype_timestamps">
				<indexterm><primary><varname>timestamps</varname></primary></indexterm>
				<para>Obtener las marcas de tiempo diferentes</para>
				<para><varname>timestamps(ttype): timestamptz[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timestamps(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"2001-01-01", "2001-01-03", "2001-01-05"}
</programlisting>
			</listitem>

			<listitem id="numSequences">
				<indexterm><primary><varname>numSequences</varname></primary></indexterm>
				<para>Obtener el número de secuencias</para>
				<para><varname>numSequences({ttype_seq,ttype_seqset}): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numSequences(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2
</programlisting>
			</listitem>

			<listitem id="startSequence">
				<indexterm><primary><varname>startSequence</varname></primary></indexterm>
				<para>Obtener la secuencia inicial</para>
				<para><varname>startSequence({ttype_seq,ttype_seqset}): ttype_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT startSequence(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- [1@2001-01-01, 2@2001-01-03)
</programlisting>
			</listitem>

			<listitem id="endSequence">
				<indexterm><primary><varname>endSequence</varname></primary></indexterm>
				<para>Obtener la secuencia final</para>
				<para><varname>endSequence({ttype_seq,ttype_seqset}): ttype_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT endSequence(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- [3@2001-01-03, 5@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="sequenceN">
				<indexterm><primary><varname>sequenceN</varname></primary></indexterm>
				<para>Obtener la enésima secuencia</para>
				<para><varname>sequenceN({ttype_seq,ttype_seqset},integer): ttype_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT sequenceN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 2);
-- [3@2001-01-03, 5@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="sequences">
				<indexterm><primary><varname>sequences</varname></primary></indexterm>
				<para>Obtener las secuencias</para>
				<para><varname>sequences({ttype_seq,ttype_seqset}): ttype_seq[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT sequences(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"[1@2001-01-01, 2@2001-01-03)", "[3@2001-01-03, 5@2001-01-05)"}
</programlisting>
			</listitem>

			<listitem id="segments">
				<indexterm><primary><varname>segments</varname></primary></indexterm>
				<para>Obtener los segmentos</para>
				<para><varname>segments({ttype_seq,ttype_seqset}): ttype_seq[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT segments(tint '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 1@2001-01-02)","[3@2001-01-02, 3@2001-01-03)","[2@2001-01-03]",
  "(3@2001-01-03, 3@2001-01-05)","[5@2001-01-05]"} */
SELECT segments(tfloat '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 3@2001-01-02)","[3@2001-01-02, 2@2001-01-03]",
   "(3@2001-01-03, 5@2001-01-05]"} */
</programlisting>
			</listitem>

			<listitem id="intersectsTimestamp">
				<indexterm><primary><varname>intersectsTimestamp</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con la marca de tiempo?</para>
				<para><varname>intersectsTimestamp(ttype,timestamptz): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsTimestamp(tint '[1@2001-01-01, 1@2001-01-15)', timestamptz '2001-01-03');
-- true
</programlisting>
			</listitem>

			<listitem id="intersectsTimestampSet">
				<indexterm><primary><varname>intersectsTimestampSet</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con el conjunto de marcas tiempo?</para>
				<para><varname>intersectsTimestampSet(ttype,timestampset): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsTimestampSet(tint '[1@2001-01-01, 1@2001-01-15)',
  timestampset '{2001-01-01, 2001-01-03}');
-- true
</programlisting>
			</listitem>

			<listitem id="intersectsPeriod">
				<indexterm><primary><varname>intersectsPeriod</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con el período?</para>
				<para><varname>intersectsPeriod(ttype,period): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsPeriod(tint '[1@2001-01-01, 1@2001-01-04)',
  period '[2001-01-01,2001-01-05)');
-- true
</programlisting>
			</listitem>

			<listitem id="intersectsPeriodSet">
				<indexterm><primary><varname>intersectsPeriodSet</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con el conjunto de períodos?</para>
				<para><varname>intersectsPeriodSet(ttype,periodset): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsPeriodSet(tbool '[t@2001-01-01, f@2001-01-15]',
  periodset '{[2001-01-01, 2001-01-03), [2001-01-05, 2001-01-07)}');
-- true
</programlisting>
			</listitem>

			<listitem id="twAvg">
				<indexterm><primary><varname>twAvg</varname></primary></indexterm>
				<para>Obtener el promedio ponderado en el tiempo</para>
				<para><varname>twAvg(tnumber): float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT twAvg(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-06)}');
-- 1.75
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="transformation_functions">
		<title>Funciones de transformación</title>
		<para>Un valor temporal se puede transformar en otro subtipo. Se genera un error si los subtipos son incompatibles.</para>
		<itemizedlist>
			<listitem id="ttype_transform">
				<indexterm><primary><varname>ttype_inst</varname></primary></indexterm>
				<indexterm><primary><varname>ttype_seq</varname></primary></indexterm>
				<indexterm><primary><varname>ttype_discseq</varname></primary></indexterm>
				<indexterm><primary><varname>ttype_seqset</varname></primary></indexterm>
				<para>Transformar un tipo temporal a otro subtipo</para>
				<para><varname>ttype_inst(ttype): ttype_inst</varname></para>
				<para><varname>ttype_seq(ttype): ttype_seq</varname></para>
				<para><varname>ttype_discseq(ttype): ttype_discseq</varname></para>
				<para><varname>ttype_seqset(ttype): ttype_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_inst(tbool '{[true@2001-01-01]}');
-- t@2001-01-01
SELECT tbool_inst(tbool '{[true@2001-01-01, true@2001-01-02]}');
-- ERROR: Cannot transform input to a temporal instant
SELECT tbool_discseq(tbool 'true@2001-01-01');
-- {t@2001-01-01}
SELECT tint_seq(tint '1@2001-01-01');
-- [1@2001-01-01]
SELECT tfloat_seqset(tfloat '2.5@2001-01-01');
-- {[2.5@2001-01-01]}
SELECT tfloat_seqset(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');
-- {[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}
</programlisting>
			</listitem>

			<listitem id="toLinear">
				<indexterm><primary><varname>toLinear</varname></primary></indexterm>
				<para>Transformar un valor temporal con tipo de base continuo de interpolación escalonada a lineal</para>
				<para><varname>toLinear(ttype): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02,
  1@2000-01-03, 2@2000-01-04]');
/* {[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03),
   [1@2000-01-03, 1@2000-01-04), [2@2000-01-04]}" */
SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01,
  Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));
/* {[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02],
   [POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]} */
</programlisting>
			</listitem>

			<listitem id="appendInstant">
				<indexterm><primary><varname>appendInstant</varname></primary></indexterm>
				<para>Anexar un instante temporal a un valor temporal</para>
				<para><varname>appendInstant(ttype,ttype_inst): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');
-- {1@2000-01-01, 1@2000-01-02}
SELECT appendInstant(tint_seq(tint '1@2000-01-01'), tint '1@2000-01-02');
-- [1@2000-01-01, 1@2000-01-02]
SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tgeompoint 'Point(1 1 1)@2000-01-06'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
   [POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05,
   POINT Z (1 1 1)@2000-01-06]} */
</programlisting>
			</listitem>

			<listitem id="merge">
				<indexterm><primary><varname>merge</varname></primary></indexterm>
				<para>Fusionar los valores temporales</para>
				<para><varname>merge(ttype,ttype): ttype</varname></para>
				<para><varname>merge(ttype[]): ttype</varname></para>
				<para>Los valores pueden compartir una sola marca de tiempo, en ese caso, los valores temporales se unen en el resultado si su valor en la marca de tiempo común es el mismo; de lo contrario, se genera un error.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT merge(tint '1@2000-01-01', tint '1@2000-01-02');
-- {1@2000-01-01, 1@2000-01-02}
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[2@2000-01-02, 1@2000-01-03]');
-- [1@2000-01-01, 2@2000-01-02, 1@2000-01-03]
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[3@2000-01-03, 1@2000-01-04]');
-- {[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 1@2000-01-04]}
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[1@2000-01-02, 2@2000-01-03]');
-- ERROR:  Both arguments have different value at their overlapping timestamp
SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tgeompoint '{[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]}'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
   [POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05,
   POINT Z (1 1 1)@2000-01-06]} */

SELECT merge(ARRAY[tint '1@2000-01-01', '1@2000-01-02']);
-- {1@2000-01-01, 1@2000-01-02}
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{2@2000-01-02, 3@2000-01-03}']);
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03}
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{3@2000-01-03, 4@2000-01-04}']);
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04}
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[2@2000-01-02, 1@2000-01-03]']);
-- [1@2000-01-01, 2@2000-01-02, 1@2000-01-03]
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[3@2000-01-03, 4@2000-01-04]']);
-- {[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 4@2000-01-04]}
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
  [Point(3 3)@2000-01-03, Point(4 4)@2000-01-04]}', '{[Point(4 4)@2000-01-04,
  Point(3 3)@2000-01-05], [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}']);
/* {[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], [Point(3 3)@2000-01-03,
   Point(4 4)@2000-01-04, Point(3 3)@2000-01-05],
   [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]} */
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02]}',
  '{[Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]}']);
-- [Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]
</programlisting>
			</listitem>

			<listitem id="shift">
				<indexterm><primary><varname>shift</varname></primary></indexterm>
				<para>Desplazar el intervalo de tiempo del valor temporal con un intervalo</para>
				<para><varname>shift(ttype,interval): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- {1@2001-01-02, 2@2001-01-04, 1@2001-01-06}
SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- [1@2001-01-02, 2@2001-01-04]
SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03],
  [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
/* {[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04],
   [POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]} */
</programlisting>
			</listitem>

			<listitem id="tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Escalear el intervalo de tiempo del valor temporal a un intervalo. Si el intervalo de tiempo del valor temporal es cero (por ejemplo, para un instante temporal), el resultado es el valor temporal. El intervalo dado debe ser estrictamente mayor que cero.</para>
				<para><varname>tscale(ttype,interval): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tscale(tint '1@2001-01-01', '1 day');
-- 1@2001-01-01
SELECT tscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- {1@2001-01-01 00:00:00+01, 2@2001-01-01 12:00:00+01, 1@2001-01-02 00:00:00+01}
SELECT tscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- [1@2001-01-01, 2@2001-01-02]
SELECT asText(tscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
/* {[POINT(1 1)@2001-01-01 00:00:00+01, POINT(2 2)@2001-01-01 06:00:00+01,
   POINT(1 1)@2001-01-01 12:00:00+01], [POINT(2 2) @2001-01-01 18:00:00+01,
   POINT(1 1)@2001-01-02 00:00:00+01]} */
SELECT tscale(tint '1@2001-01-01', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem id="shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Desplazar y escalear el intervalo de tiempo del valor temporal a los dos intervalos. Esta función combina en un solo paso las funciones <link linkend="shift"><varname>shift</varname></link> y <link linkend="tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale(ttype,interval,interval): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shiftTscale(tint '1@2001-01-01', '1 day', '1 day');
-- 1@2001-01-02
SELECT shiftTscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day', '1 day');
-- {1@2001-01-02 00:00:00+01, 2@2001-01-02 12:00:00+01, 1@2001-01-03 00:00:00+01}
SELECT shiftTscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day', '1 day');
-- [1@2001-01-02, 2@2001-01-03]
SELECT asText(shiftTscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}',
  '1 day', '1 day'));
/* {[POINT(1 1)@2001-01-02 00:00:00+01, POINT(2 2)@2001-01-02 06:00:00+01,
   POINT(1 1)@2001-01-02 12:00:00+01], [POINT(2 2) @2001-01-02 18:00:00+01,
   POINT(1 1)@2001-01-03 00:00:00+01]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="restriction_functions">
		<title>Funciones de restricción</title>

		<sect2>
			<title>Funciones de selección</title>
			<para>Estas funciones restringen el valor temporal con respecto a una extensión de valores o de tiempo.</para>

			<itemizedlist>
				<listitem id="atValue">
					<indexterm><primary><varname>atValue</varname></primary></indexterm>
					<para>Restringir a un valor</para>
					<para><varname>atValue(ttype,base): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atValue(tint '[1@2001-01-01, 1@2001-01-15)', 1);
-- [1@2001-01-01, 1@2001-01-15)
SELECT asText(atValue(tgeompoint '[Point(0 0 0)@2001-01-01, Point(2 2 2)@2001-01-03)',
  'Point(1 1 1)'));
-- {[POINT Z (1 1 1)@2001-01-02]}
</programlisting>
				</listitem>

				<listitem id="atValues">
					<indexterm><primary><varname>atValues</varname></primary></indexterm>
					<para>Restringir a una matriz de valores</para>
					<para><varname>atValues(ttype,base[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atValues(tfloat '[1@2001-01-01, 4@2001-01-4)', ARRAY[1, 3, 5]);
-- {[1@2001-01-01], [3@2001-01-03]}
SELECT asText(atValues(tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)',
  ARRAY[geometry 'Point(0 0)', 'Point(1 1)']));
-- {[POINT(0 0)@2001-01-01], [POINT(1 1)@2001-01-02]}
</programlisting>
				</listitem>

				<listitem id="atSpan">
					<indexterm><primary><varname>atSpan</varname></primary></indexterm>
					<para>Restringir a un rango de valores</para>
					<para><varname>atSpan(tnumber,numspan): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atSpan(tfloat '[1@2001-01-01, 4@2001-01-4)', floatspan '[1,3]');
-- [1@2001-01-01, 3@2001-01-03]
</programlisting>
				</listitem>

				<listitem id="atSpans">
					<indexterm><primary><varname>atSpans</varname></primary></indexterm>
					<para>Restringir a una matriz de rangos de valores</para>
					<para><varname>atSpans(tnumber,numspan[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atSpans(tfloat '[1@2001-01-01, 5@2001-01-05)',
  ARRAY[floatspan '[1,2]', '[3,4]']);
-- {[1@2001-01-01, 2@2001-01-02],[3@2001-01-03, 4@2001-01-04]}
</programlisting>
				</listitem>

				<listitem id="atMin">
					<indexterm><primary><varname>atMin</varname></primary></indexterm>
					<para>Restringir al valor mínimo</para>
					<para><varname>atMin(torder): torder</varname></para>
					<para>La función devuelve nulo si el valor mínimo sólo ocurre en límites exclusivos.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT atMin(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}');
-- {1@2001-01-01, 1@2001-01-05}
SELECT atMin(tint '(1@2001-01-01, 3@2001-01-03]');
-- {(1@2001-01-01, 1@2001-01-03)}
SELECT atMin(tfloat '(1@2001-01-01, 3@2001-01-03]');
-- NULL
SELECT atMin(ttext '{(AA@2001-01-01, AA@2001-01-03), (BB@2001-01-03, AA@2001-01-05]}');
-- {(AA@2001-01-01, AA@2001-01-03), [AA@2001-01-05]}
</programlisting>
				</listitem>

				<listitem id="atMax">
					<indexterm><primary><varname>atMax</varname></primary></indexterm>
					<para>Restringir al valor máximo</para>
					<para><varname>atMax(torder): torder</varname></para>
					<para>La función devuelve nulo si el valor máximo sólo ocurre en límites exclusivos.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT atMax(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- {3@2001-01-05}
SELECT atMax(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- NULL
SELECT atMax(tfloat '{(2@2001-01-01, 1@2001-01-03), [2@2001-01-03, 2@2001-01-05)}');
-- {[2@2001-01-03, 2@2001-01-05]}
SELECT atMax(ttext '{(AA@2001-01-01, AA@2001-01-03), (BB@2001-01-03, AA@2001-01-05]}');
-- {("BB"@2001-01-03, "BB"@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="atGeometry">
					<indexterm><primary><varname>atGeometry</varname></primary></indexterm>
					<para>Restringir a una geometría</para>
					<para><varname>atGeometry(tgeompoint,geometry): tgeompoint</varname></para>
					<para>Tenga en cuenta que está permitido mezclar geometrías 2D/3D, pero el cálculo sólo se realiza en 2D.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- {"[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-03]"}
SELECT astext(atGeometry(tgeompoint '[Point(0 0 0)@2000-01-01, Point(4 4 4)@2000-01-05]',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- {[POINT Z (1 1 1)@2000-01-02, POINT Z (2 2 2)@2000-01-03]}
</programlisting>
				</listitem>

				<listitem id="atTimestamp">
					<indexterm><primary><varname>atTimestamp</varname></primary></indexterm>
					<para>Restringir a una marca de tiempo</para>
					<para><varname>atTimestamp(ttype,timestamptz): ttype_inst</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atTimestamp(tfloat '[1@2001-01-01, 5@2001-01-05)', '2001-01-02');
-- 2@2001-01-02
</programlisting>
				</listitem>

				<listitem id="atTimestampSet">
					<indexterm><primary><varname>atTimestampSet</varname></primary></indexterm>
					<para>Restringir a un conjunto de marcas de tiempo</para>
					<para><varname>atTimestampSet(ttype,timestampset): {ttype_inst,ttype_seq}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atTimestampSet(tint '[1@2001-01-01, 1@2001-01-15)',
  timestampset '{2001-01-01, 2001-01-03}');
-- {1@2001-01-01, 1@2001-01-03}
</programlisting>
				</listitem>

				<listitem id="atPeriod">
					<indexterm><primary><varname>atPeriod</varname></primary></indexterm>
					<para>Restringir a un período</para>
					<para><varname>atPeriod(ttype,period): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atPeriod(tfloat '{[1@2001-01-01, 3@2001-01-03), [3@2001-01-04, 1@2001-01-06)}',
  '[2001-01-02,2001-01-05)');
-- {[2@2001-01-02, 3@2001-01-03), [3@2001-01-04, 2@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="atPeriodSet">
					<indexterm><primary><varname>atPeriodSet</varname></primary></indexterm>
					<para>Restringir a un conjunto de períodos</para>
					<para><varname>atPeriodSet(ttype,periodset): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atPeriodSet(tint '[1@2001-01-01, 1@2001-01-15)',
  periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- {[1@2001-01-01, 1@2001-01-03),[1@2001-01-04, 1@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="atTbox">
					<indexterm><primary><varname>atTbox</varname></primary></indexterm>
					<para>Restringir a un <varname>tbox</varname></para>
					<para><varname>atTbox(tnumber,tbox): tnumber</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atTbox(tfloat '[0@2001-01-01, 3@2001-01-04)',
  tbox 'TBOX XT((0,2),[2001-01-02, 2001-01-04])');
-- {[1@2001-01-02, 2@2001-01-03]}
</programlisting>
				</listitem>

				<listitem id="atStbox">
					<indexterm><primary><varname>atStbox</varname></primary></indexterm>
					<para>Restringir a un <varname>stbox</varname></para>
					<para><varname>atStbox(tgeompoint,stbox): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(atStbox(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  stbox 'STBOX XT(((0,0),(2,2))),[2001-01-02, 2001-01-04]'));
-- {[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-03]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones de diferencia</title>
			<para>Estas funciones restringen el valor temporal con respecto al complemento de una extensión de valores y/o de tiempo.</para>
			<itemizedlist>
				<listitem id="minusValue">
					<indexterm><primary><varname>minusValue</varname></primary></indexterm>
					<para>Diferencia con un valor</para>
					<para><varname>minusValue(ttype,base): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusValue(tint '[1@2001-01-01, 2@2001-01-02, 2@2001-01-03)', 1);
-- {[2@2001-01-02, 2@2001-01-03)}
SELECT asText(minusValue(tgeompoint '[Point(0 0 0)@2001-01-01, Point(2 2 2)@2001-01-03)',
  'Point(1 1 1)'));
/* {[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02),
   (POINT Z (1 1 1)@2001-01-02, POINT Z (2 2 2)@2001-01-03)} */
</programlisting>
				</listitem>

				<listitem id="minusValues">
					<indexterm><primary><varname>minusValues</varname></primary></indexterm>
					<para>Diferencia con una matriz de valores</para>
					<para><varname>minusValues(ttype,base[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusValues(tfloat '[1@2001-01-01, 4@2001-01-4)', ARRAY[2, 3]);
/* {[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03),
   (3@2001-01-03, 4@2001-01-04)} */
SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2001-01-01, Point(3 3 3)@2001-01-04)',
  ARRAY[geometry 'Point(1 1 1)', 'Point(2 2 2)']));
/* {[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02),
   (POINT Z (1 1 1)@2001-01-02, POINT Z (2 2 2)@2001-01-03),
   (POINT Z (2 2 2)@2001-01-03, POINT Z (3 3 3)@2001-01-04)} */
</programlisting>
				</listitem>

				<listitem id="minusSpan">
					<indexterm><primary><varname>minusSpan</varname></primary></indexterm>
					<para>Diferencia con un rango de valores</para>
					<para><varname>minusSpan(tnumber,numspan): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusSpan(tfloat '[1@2001-01-01, 4@2001-01-4)', floatspan '[2,3]');
-- {[1@2001-01-01, 2@2001-01-02), (3@2001-01-03, 4@2001-01-04)}
</programlisting>
				</listitem>

				<listitem id="minusSpans">
					<indexterm><primary><varname>minusSpans</varname></primary></indexterm>
					<para>Diferencia con una matriz de rangos de valores</para>
					<para><varname>minusSpans(tnumber,numspan[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusSpans(tfloat '[1@2001-01-01, 5@2001-01-05)',
  ARRAY[floatspan '[1,2]', '[3,4]']);
-- {(2@2001-01-02, 3@2001-01-03), (4@2001-01-04, 5@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="minusMin">
					<indexterm><primary><varname>minusMin</varname></primary></indexterm>
					<para>Diferencia con el valor mínimo</para>
					<para><varname>minusMin(torder): torder</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusMin(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}');
-- {2@2001-01-03}
SELECT minusMin(tfloat '[1@2001-01-01, 3@2001-01-03]');
-- {(1@2001-01-01, 3@2001-01-03]}
SELECT minusMin(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- {(1@2001-01-01, 3@2001-01-03)}
SELECT minusMin(tint '{[1@2001-01-01, 1@2001-01-03), (1@2001-01-03, 1@2001-01-05)}');
-- NULL
</programlisting>
				</listitem>

				<listitem id="minusMax">
					<indexterm><primary><varname>minusMax</varname></primary></indexterm>
					<para>Diferencia con el valor máximo</para>
					<para><varname>minusMax(torder): torder</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusMax(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- {1@2001-01-01, 2@2001-01-03}
SELECT minusMax(tfloat '[1@2001-01-01, 3@2001-01-03]');
-- {[1@2001-01-01, 3@2001-01-03)}
SELECT minusMax(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- {(1@2001-01-01, 3@2001-01-03)}
SELECT minusMax(tfloat '{[2@2001-01-01, 1@2001-01-03), [2@2001-01-03, 2@2001-01-05)}');
-- {(2@2001-01-01, 1@2001-01-03)}
SELECT minusMax(tfloat '{[1@2001-01-01, 3@2001-01-03), (3@2001-01-03, 1@2001-01-05)}');
-- {[1@2001-01-01, 3@2001-01-03), (3@2001-01-03, 1@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="minusGeometry">
					<indexterm><primary><varname>minusGeometry</varname></primary></indexterm>
					<para>Diferencia con una geometría</para>
					<para><varname>minusGeometry(tgeompoint,geometry): tgeompoint</varname></para>
					<para>Tenga en cuenta que está permitido mezclar geometrías 2D/3D, pero el cálculo sólo se realiza en 2D.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
/* {[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02), (POINT(2 2)@2001-01-03,
  POINT(3 3)@2001-01-04)} */
SELECT astext(minusGeometry(tgeompoint '[Point(0 0 0)@2000-01-01,
  Point(4 4 4)@2000-01-05]', geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
/* {[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02),
   (POINT Z (2 2 2)@2000-01-03, POINT Z (4 4 4)@2000-01-05]} */
</programlisting>
				</listitem>

				<listitem id="minusTimestamp">
					<indexterm><primary><varname>minusTimestamp</varname></primary></indexterm>
					<para>Diferencia con una marca de tiempo</para>
					<para><varname>minusTimestamp(ttype,timestamptz): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusTimestamp(tfloat '[1@2001-01-01, 5@2001-01-05)', '2001-01-02');
-- {[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 5@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="minusTimestampSet">
					<indexterm><primary><varname>minusTimestampSet</varname></primary></indexterm>
					<para>Diferencia con un conjunto de marcas de tiempo</para>
					<para><varname>minusTimestampSet(ttype,timestampset): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusTimestampSet(tint '[1@2001-01-01, 1@2001-01-15)',
  timestampset '{2001-01-02, 2001-01-03}');
/* {[1@2001-01-01, 1@2001-01-02), (1@2001-01-02, 1@2001-01-03),
   (1@2001-01-03, 1@2001-01-15)} */
</programlisting>
				</listitem>

				<listitem id="minusPeriod">
					<indexterm><primary><varname>minusPeriod</varname></primary></indexterm>
					<para>Diferencia con un período</para>
					<para><varname>minusPeriod(ttype,period): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusPeriod(tfloat '{[1@2001-01-01, 3@2001-01-03), [3@2001-01-04, 1@2001-01-06)}',
  '[2001-01-02,2001-01-05)');
-- {[1@2001-01-01, 2@2001-01-02), [2@2001-01-05, 1@2001-01-06)}
</programlisting>
				</listitem>

				<listitem id="minusPeriodSet">
					<indexterm><primary><varname>minusPeriodSet</varname></primary></indexterm>
					<para>Diferencia con un conjunto de períodos</para>
					<para><varname>minusPeriodSet(ttype,periodset): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusPeriodSet(tint '[1@2001-01-01, 1@2001-01-15)',
  periodset '{[2001-01-02, 2001-01-03), [2001-01-04, 2001-01-05)}');
/* {[1@2001-01-01, 1@2001-01-02), [1@2001-01-03, 1@2001-01-04),
   [1@2001-01-05, 1@2001-01-15)} */
</programlisting>
				</listitem>

				<listitem id="minusTbox">
					<indexterm><primary><varname>minusTbox</varname></primary></indexterm>
					<para>Diferencia con un <varname>tbox</varname></para>
					<para><varname>minusTbox(tnumber,tbox): tnumber</varname></para>
					<para>Observe que cuando el cuadro delimitador tiene dimensiones de valor y de tiempo, la diferencia se calcula restringiendo el número temporal al cuadro usando la función <varname>atTbox</varname>, calculando la extensión de tiempo de esta restricción, y restringiendo el número temporal a la diferencia de la extensión del tiempo. Esto es necesario para garantizar que <varname>tnumber = merge(atTbox(tnumber,tbox), minusTbox(tnumber,tbox))</varname> (ver la función <link linkend="merge"><varname>merge</varname></link>). En otras palabras, mientras que la función <varname>atTbox</varname> restringe el número temporal con respecto al rango <emphasis>y</emphasis> al período que definen el cuadro delimitador, la función <varname>minusTbox</varname> restringe el número temporal con respecto al rango <emphasis>o</emphasis> al período. Para obtener la restricción usando una semántica <emphasis>y</emphasis>, deben aplicarse las dos funciones <varname>minusSpan</varname> y <varname>minusPeriod</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusTbox(tfloat '[1@2001-01-01, 4@2001-01-04)',
  'TBOX XT((1,4),[2001-01-03, 2001-01-04])');
-- {[1@2001-01-01, 3@2001-01-03)}
WITH temp(temp, box) AS (SELECT tfloat '[1@2001-01-01, 4@2001-01-04)',
  'TBOX XT((1,2),[2001-01-03, 2001-01-04])' )
SELECT minusSpan(minusPeriod(temp, box::period), box::floatspan) FROM temp;
-- {[1@2001-01-01], [2@2001-01-02, 3@2001-01-03)}
</programlisting>
				</listitem>

				<listitem id="minusStbox">
					<indexterm><primary><varname>minusStbox</varname></primary></indexterm>
					<para>Diferencia con un <varname>stbox</varname></para>
					<para><varname>minusStbox(tgeompoint,stbox): tgeompoint</varname></para>
					<para>De manera similar a la función <link linkend="minusTbox"><varname>minusTbox</varname></link>, cuando el cuadro delimitador tiene dimensiones de espacio y tiempo, la función <varname> minusStbox</varname> restringe el punto temporal con respecto a las  extensiones de espacio <emphasis>o</emphasis> de tiempo del cuadro. Para obtener la restricción utilizando una semántica <emphasis>y</emphasis>, deben aplicarse las dos funciones <varname>minusGeometry</varname> y <varname>minusPeriod</varname>.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(minusStbox(tgeompoint '[Point(1 1)@2001-01-01, Point(4 4)@2001-01-04)',
  stbox 'STBOX XT(((1,1),(4,4)),[2001-01-03,2001-01-04])'));
-- {[POINT(1 1)@2001-01-01), POINT(3 3)@2001-01-03)}
WITH temp(temp, box) AS (SELECT 
  tgeompoint '[Point(1 1)@2001-01-01, Point(4 4)@2001-01-04)',
  stbox 'STBOX XT(((1,1),(2,2)),[2001-01-03,2001-01-04])')
SELECT asText(minusGeometry(minusPeriod(temp, box::period), box::geometry)) FROM temp;
-- {(POINT(2 2)@2001-01-02, POINT(3 3)@2001-01-03)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id="operators_temporal_types">
		<title>Operadores de comparación</title>

		<sect2>
			<title>Operadores de comparación tradicionales</title>

			<para>Los operadores de comparación tradicionales (<varname>=</varname>, <varname>&lt;</varname>, etc.) requieren que los operandos izquierdo y derecho sean del mismo tipo base. Excepto la igualdad y la no igualdad, los otros operadores de comparación no son útiles en el mundo real pero permiten que los índices de árbol B se construyan sobre tipos temporales. Estos operadores comparan los períodos delimitadores (ver la <xref linkend="time_comp_operators" />), después los cuadros delimitadores (ver la <xref linkend="comparison_box_types" />) y si son iguales, entonces la comparación depende del subtipo. Para los valores de instante, primero comparan las marcas de tiempo y, si son iguales, comparan los valores. Para los valores de secuencia, comparan los primeros N instantes, donde N es el mínimo del número de instantes que componen ambos valores. Finalmente, para los valores de conjuntos de secuencias, comparan los primeros N valores de secuencia, donde N es el mínimo del número de secuencias que componen ambos valores.</para>

			<para>Los operadores de igualdad y no igualdad consideran la representación equivalente para diferentes subtipos como se muestra a continuación.
				<programlisting language="sql" xml:space="preserve">
SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';
-- true
SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';
-- true
SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';
-- true
SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =
  tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';
-- true
SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =
  tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';
-- true
</programlisting>
			</para>

			<itemizedlist>
				<listitem id="ttype_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>¿Son iguales los valores temporales?</para>
					<para><varname>ttype = ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' = tint '[2@2001-01-03, 2@2001-01-05)';
-- false
</programlisting>
				</listitem>

				<listitem id="ttype_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>¿Son diferentes los valores temporales?</para>
					<para><varname>ttype &lt;&gt; ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;&gt; tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>¿Es el primer valor temporal menor que el segundo?</para>
					<para><varname>ttype &lt; ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt; tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

			<listitem id="ttype_gt">
				<indexterm><primary><varname>&gt;</varname></primary></indexterm>
				<para>¿Es el primer valor temporal mayor que el segundo?</para>
				<para><varname>ttype &gt; ttype: boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt; tint '[2@2001-01-03, 2@2001-01-05)'
-- false
</programlisting>
			</listitem>

				<listitem id="ttype_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>¿Es el primer valor temporal menor o igual que el segundo?</para>
					<para><varname>ttype &lt;= ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;= tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>¿Es el primer valor temporal mayor o igual que el segundo?</para>
					<para><varname>ttype &gt;= ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt;= tint '[2@2001-01-03, 2@2001-01-05)'
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="ever_always_comparison">
			<title>Operadores de comparación alguna vez y siempre</title>
			<para>Una posible generalización de los operadores de comparación tradicionales (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>, etc.) a tipos temporales consiste en determinar si la comparación es alguna vez o siempre verdadera. En este caso, el resultado es un valor booleano. MobilityDB proporciona operadores para probar si la comparación de un valor temporal y un valor del tipo base es alguna vez o siempre verdadera. Estos operadores se indican anteponiendo los operadores de comparación tradicionales con, respectivamente, <varname>?</varname> (alguna vez) y <varname>%</varname> (siempre). Algunos ejemplos son <varname>?=</varname>, <varname>%&lt;&gt;</varname> o <varname>?&lt;=</varname>. La igualdad y la no igualdad alguna vez/siempre  están disponibles para todos los tipos temporales, mientras que las desigualdades alguna vez/siempre sólo están disponibles para los tipos temporales cuyo tipo base tiene un orden total definido, es decir, <varname>tint</varname>, <varname>tfloat</varname> o <varname>ttext</varname>. Las comparaciones alguna vez y siempre son operadores inversos: por ejemplo,<varname>?=</varname> es el inverso de <varname>%&lt;&gt;</varname> y <varname>?&gt;</varname> es el inverso de <varname>%&lt;=</varname>.</para>

			<itemizedlist>
				<listitem id="ttype_eveq">
					<indexterm><primary><varname>?=</varname></primary></indexterm>
					<para>¿Es el valor temporal alguna vez igual al valor?</para>
					<para><varname>ttype ?= base: boolean</varname></para>
					<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?= 2;
-- true
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' ?=
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_evne">
					<indexterm><primary><varname>?&lt;&gt;</varname></primary></indexterm>
					<para>¿Es el valor temporal alguna vez diferente del valor?</para>
					<para><varname>ttype ?&lt;&gt; base: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?&lt;&gt; 2;
-- false
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' ?&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' ?&lt;&gt;
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_evlt">
					<indexterm><primary><varname>?&lt;</varname></primary></indexterm>
					<para>¿Es el valor temporal alguna vez menor que el valor?</para>
					<para><varname>tnumber ?&lt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' ?&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' ?&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_evgt">
					<indexterm><primary><varname>?&gt;</varname></primary></indexterm>
					<para>¿Es el valor temporal alguna vez mayor que el valor?</para>
					<para><varname>tnumber ?&gt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-03, 1@2001-01-05)' ?&gt; 1;
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_evle">
					<indexterm><primary><varname>?&lt;=</varname></primary></indexterm>
					<para>¿Es el valor temporal alguna vez menor o igual que el valor?</para>
					<para><varname>tnumber ?&lt;= number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' ?&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_evge">
					<indexterm><primary><varname>?&gt;=</varname></primary></indexterm>
					<para>¿Es el valor temporal alguna vez mayor o igual que el valor?</para>
					<para><varname>tnumber ?&gt;= number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text ?&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_aleq">
					<indexterm><primary><varname>%=</varname></primary></indexterm>
					<para>¿Es el valor temporal siempre igual que el valor?</para>
					<para><varname>ttype %= base: boolean</varname></para>
					<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %= 2;
-- true
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' %=
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_alne">
					<indexterm><primary><varname>%&lt;&gt;</varname></primary></indexterm>
					<para>¿Es el valor temporal siempre diferente que el valor?</para>
					<para><varname>ttype %&lt;&gt; base: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %&lt;&gt; 2;
-- false
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' %&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' %&lt;&gt;
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_allt">
					<indexterm><primary><varname>%&lt;</varname></primary></indexterm>
					<para>¿Es el valor temporal siempre menor que el valor?</para>
					<para><varname>tnumber %&lt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' %&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' %&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_algt">
					<indexterm><primary><varname>%&gt;</varname></primary></indexterm>
					<para>¿Es el valor temporal siempre mayor que el valor?</para>
					<para><varname>tnumber %&gt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-03, 1@2001-01-05)' %&gt; 1;
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_alle">
					<indexterm><primary><varname>%&lt;=</varname></primary></indexterm>
					<para>¿Es el valor temporal siempre menor o igual que el valor?</para>
					<para><varname>tnumber %&lt;= number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' %&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_alge">
					<indexterm><primary><varname>%&gt;=</varname></primary></indexterm>
					<para>¿Es el valor temporal siempre mayor o igual que el valor?</para>
					<para><varname>tnumber %&gt;= number: boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELEC	T 'AAA'::text %&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Operadores de comparación temporal</title>
			<para>Otra posible generalización de los operadores de comparación tradicionales (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>, etc.) a tipos temporales consiste en determinar si la comparación es verdadera o falsa en cada instante. En este caso, el resultado es un booleano temporal. Los operadores de comparación temporal se indican anteponiendo los operadores de comparación tradicionales con <varname>#</varname>. Algunos ejemplos son <varname>#=</varname> o <varname>#&lt;=</varname>. La igualdad y no igualdad temporal están disponibles para todos los tipos temporales, mientras que las desigualdades temporales sólo están disponibles para los tipos temporales cuyo tipo base tiene un orden total definido, es decir, <varname>tint</varname>, <varname>tfloat</varname> o <varname>ttext</varname>.</para>

			<itemizedlist>
				<listitem id="ttype_teq">
					<indexterm><primary><varname>#=</varname></primary></indexterm>
					<para>Igual temporal</para>
					<para><varname>{base,ttype} #= {base,ttype}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 2@2001-01-04)' #= 3;
-- {[f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tint '[1@2001-01-01, 1@2001-01-04)';
-- {[t@2001-01-01], (f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tfloat '[4@2001-01-02, 1@2001-01-05)';
-- {[f@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  geometry 'Point(1 1)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  tgeompoint '[Point(0 2)@2001-01-01, Point(2 0)@2001-01-03)';
-- {[f@2001-01-01], (t@2001-01-01, t@2001-01-03)}
</programlisting>
				</listitem>

				<listitem id="ttype_tne">
					<indexterm><primary><varname>#&lt;&gt;</varname></primary></indexterm>
					<para>Diferente temporal</para>
					<para><varname>{base,ttype} #&lt;&gt; {base,ttype}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; 2;
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, 2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; tint '[2@2001-01-02, 2@2001-01-05)';
-- {[f@2001-01-02], (t@2001-01-02, t@2001-01-04)}
</programlisting>
				</listitem>

				<listitem id="ttype_tlt">
					<indexterm><primary><varname>#&lt;</varname></primary></indexterm>
					<para>Menor que temporal</para>
					<para><varname>{base,torder} #&lt; {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' #&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_tgt">
					<indexterm><primary><varname>#&gt;</varname></primary></indexterm>
					<para>Mayor que temporal</para>
					<para><varname>{base,torder} #&gt; {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 1 #&gt; tint '[1@2001-01-03, 1@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_tle">
					<indexterm><primary><varname>#&lt;=</varname></primary></indexterm>
					<para>Menor o igual que temporal</para>
					<para><varname>{base,torder} #&lt;= {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' #&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_tge">
					<indexterm><primary><varname>#&gt;=</varname></primary></indexterm>
					<para>Mayor o igual que temporal</para>
					<para><varname>{base,torder} #&gt;= {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text #&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1>
		<title>Operadores de cuadro delimitador</title>

		<para>Estos operadores prueban si los cuadros delimitadores de sus argumentos satisfacen el predicado y dan como resultado un valor booleano. Como se indica en el <xref linkend="temporal_types" />, el cuadro delimitador asociado a un tipo temporal depende del tipo base: es el tipo <varname>period</varname> para los tipos <varname>tbool</varname> y <varname>ttext</varname>, el tipo <varname>tbox</varname> para los tipos <varname>tint</varname> y <varname>tfloat</varname> y el tipo <varname>stbox</varname> para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>. Además, como se dijo en la <xref linkend="casting_box_types" />, muchos tipos PostgreSQL, PostGIS o MobilityDB se pueden convertir a los tipos <varname>tbox</varname> y <varname>stbox</varname>. Por ejemplo, los tipos numéricos y los rangos se pueden convertir al tipo <varname>tbox</varname>, los tipos <varname>geometry</varname> y <varname>geography</varname> se pueden convertir al tipo <varname>stbox</varname> y los tipos de tiempo y los tipos temporales se pueden convertir a los tipos <varname>tbox</varname> y <varname>stbox</varname>.</para>

		<para>Un primer conjunto de operadores considera las relaciones topológicas entre los cuadros delimitadores. Hay cinco operadores topológicos: superposición (<varname>&amp;&amp;</varname>), contiene (<varname>@&gt;</varname>), está contenido (<varname>&lt;@</varname>), mismo (<varname>~=</varname>) y adyacente (<varname>-|-</varname>). Los argumentos de estos operadores pueden ser un tipo base, una cuadro delimitador o un tipo temporal y los operadores verifican la relación topológica teniendo en cuenta el valor y/o la dimensión temporal según el tipo de los argumentos.</para>

		<para>Otro conjunto de operadores considera la posición relativa de los cuadros delimitadores. Los operadores <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname> y <varname>&amp;&gt;</varname> consideran la dimensión de valor para los tipos <varname>tint</varname> y <varname>tfloat</varname> y las coordenadas X para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>, los operadores <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname> y <varname>|&amp;&gt;</varname> consideran las coordenadas Y para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>, los operadores <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname> y <varname>/&amp;&gt;</varname> consideran las coordenadas Z para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname> y los operadores <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname> y <varname>#&amp;&gt;</varname> consideran la dimensión tiempo para todos los tipos temporales.</para>

		<para>Finalmente, cabe destacar que los operadores de cuadro delimitador permiten mezclar geometrías 2D/3D pero en ese caso, el cálculo sólo se realiza en 2D.</para>

		<para>Refiérase a la <xref linkend="box_topo_operators" /> y a la <xref linkend="box_relpos_operators" /> para los operadores de cuadro delimitador.</para>
	</sect1>

	<sect1>
		<title>Funciones y operadores matemáticos</title>

		<itemizedlist>
			<listitem id="tnumber_add">
				<indexterm><primary><varname>+</varname></primary></indexterm>
				<para>Adición temporal</para>
				<para><varname>{number,tnumber} + {number,tnumber}: tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[2@2001-01-01, 2@2001-01-04)' + 1.5;
-- [3.5@2001-01-01, 3.5@2001-01-04)
SELECT tint '[2@2001-01-01, 2@2001-01-04)' + tfloat '[1@2001-01-01, 4@2001-01-04)';
-- [3@2001-01-01, 6@2001-01-04)
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' +
  tfloat '{[1@2001-01-01, 2@2001-01-02), [1@2001-01-02, 2@2001-01-04)}';
-- {[2@2001-01-01, 4@2001-01-04), [3@2001-01-02, 6@2001-01-04)}
</programlisting>
			</listitem>

			<listitem id="tnumber_sub">
				<indexterm><primary><varname>-</varname></primary></indexterm>
				<para>Resta temporal</para>
				<para><varname>{number,tnumber} - {number,tnumber}: tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' - tint '[2@2001-01-03, 2@2001-01-05)';
-- [-1@2001-01-03, -1@2001-01-04)
SELECT tfloat '[3@2001-01-01, 6@2001-01-04)' - tint '[2@2001-01-01, 2@2001-01-04)';
-- [1@2001-01-01, 4@2001-01-04)
</programlisting>
			</listitem>

			<listitem id="tnumber_mult">
				<indexterm><primary><varname>*</varname></primary></indexterm>
				<para>Multiplicación temporal</para>
				<para><varname>{number,tnumber} * {number,tnumber}: tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' * 2;
-- [2@2001-01-01, 8@2001-01-04)
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' * tint '[2@2001-01-01, 2@2001-01-04)';
-- [2@2001-01-01, 8@2001-01-04)
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' * '[3@2001-01-01, 1@2001-01-03)'
-- {[3@2001-01-01, 4@2001-01-02, 3@2001-01-03)}
</programlisting>
			</listitem>

			<listitem id="tnumber_div">
				<indexterm><primary><varname>/</varname></primary></indexterm>
				<para>División temporal</para>
				<para><varname>{number,tnumber} / {number,tnumber}: tnumber</varname></para>
				<para>La función genera un error si el denominador es alguna vez igual a cero durante el intervalo de tiempo común de los argumentos.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT 2 / tfloat '[1@2001-01-01, 3@2001-01-04)';
-- [2@2001-01-01, 1@2001-01-02 12:00:00+00, 0.666666666666667@2001-01-04)
SELECT tfloat '[1@2001-01-01, 5@2001-01-05)' / '[5@2001-01-01, 1@2001-01-05)'
-- {[0.2@2001-01-01, 1@2001-01-03,2001-01-03, 5@2001-01-03,2001-01-05)}
SELECT 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'
-- ERROR:  Division by zero
SELECT tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'
-- [-2@2000-01-04, 1@2000-01-05]
</programlisting>
			</listitem>

			<listitem id="round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Redondear los valores a un número de posiciones decimales</para>
				<para><varname>round(tfloat,integer): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);
-- [0.79@2000-01-01, 2.36@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="degrees">
				<indexterm><primary><varname>degrees</varname></primary></indexterm>
				<para>Convertir de radianes a grados</para>
				<para><varname>degrees(tfloat): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');
-- [45@2000-01-01, 135@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="derivative">
				<indexterm><primary><varname>derivative</varname></primary></indexterm>
				<para>Obtener la derivada sobre el tiempo del número flotante temporal en unidades por segundo</para>
				<para><varname>derivative(tfloat): tfloat</varname></para>
				<para>El número flotante temporal debe tener interpolación linear</para>
				<programlisting language="sql" xml:space="preserve">
SELECT derivative(tfloat '{[0@2000-01-01, 10@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 0@2000-01-05]}') * 3600 * 24;
--  Interp=Stepwise;{[-10@2000-01-01, 5@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 1@2000-01-05]}
SELECT derivative(tfloat 'Interp=Stepwise;[0@2000-01-01, 10@2000-01-02, 5@2000-01-03]');
-- ERROR:  The temporal value must have linear interpolation
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Operadores booleanos</title>
		<itemizedlist>
			<listitem id="tbool_and">
				<indexterm><primary><varname>&amp;</varname></primary></indexterm>
				<para>Y temporal</para>
				<para><varname>{boolean,tbool} &amp; {boolean,tbool}: tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-03, true@2001-01-05)' &amp;
  tbool '[false@2001-01-03, false@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
SELECT tbool '[true@2001-01-03, true@2001-01-05)' &amp;
  tbool '{[false@2001-01-03, false@2001-01-04),
  [true@2001-01-04, true@2001-01-05)}';
-- {[f@2001-01-03, t@2001-01-04, t@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="tbool_or">
				<indexterm><primary><varname>|</varname></primary></indexterm>
				<para>O temporal</para>
				<para><varname>{boolean,tbool} | {boolean,tbool}: tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-03, true@2001-01-05)' |
  tbool '[false@2001-01-03, false@2001-01-05)';
-- [t@2001-01-03, t@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="tbool_not">
				<indexterm><primary><varname>~</varname></primary></indexterm>
				<para>No temporal</para>
				<para><varname>~tbool: tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ~tbool '[true@2001-01-03, true@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones y operadores de texto</title>

		<itemizedlist>
			<listitem id="ttext_concat">
				<indexterm><primary><varname>||</varname></primary></indexterm>
				<para>Concatenación de texto temporal</para>
				<para><varname>{text,ttext} || {text,ttext}: ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ttext '[AA@2001-01-01, AA@2001-01-04)' || text 'B';
-- ["AAB"@2001-01-01, "AAB"@2001-01-04)
SELECT ttext '[AA@2001-01-01, AA@2001-01-04)' || ttext '[BB@2001-01-02, BB@2001-01-05)';
-- ["AABB"@2001-01-02, "AABB"@2001-01-04)
SELECT ttext '[A@2001-01-01, B@2001-01-03, C@2001-01-04]' ||
  ttext '{[D@2001-01-01, D@2001-01-02), [E@2001-01-02, E@2001-01-04)}';
-- {["DA"@2001-01-01, "EA"@2001-01-02, "EB"@2001-01-03, "EB"@2001-01-04)}
</programlisting>
			</listitem>

			<listitem id="ttext_upper">
				<indexterm><primary><varname>upper</varname></primary></indexterm>
				<para>Transformar a mayúsculas</para>
				<para><varname>upper(ttext): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- ["AA"@2000-01-01, "BB"@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="ttext_lower">
				<indexterm><primary><varname>lower</varname></primary></indexterm>
				<para>Transformar a minúsculas</para>
				<para><varname>lower(ttext): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- ["aa"@2000-01-01, "bb"@2000-01-02]
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	&spatial_functions;

	<sect1>
		<title>Funciones de similaridad</title>
		<itemizedlist>
			<listitem id="frechetDistance">
				<indexterm><primary><varname>frechetDistance</varname></primary></indexterm>
				<para>Obtener la <ulink url="https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance">distancia de Fréchet</ulink> discreta entre dos valores temporales &Z_support; &geography_support;</para>
				<para><varname>frechetDistance({tnumber, tgeo}, {tnumber, tgeo}): float</varname></para>
				<para>Esta función tiene una complejidad de espacio lineal ya que solo dos filas de la matriz de distancia son asignadas en la memoria. Sin embargo, su complejidad de tiempo es cuadrática en el número de instantes de los valores temporales. Por lo tanto, la función requerirá un tiempo considerable para valores temporales con gran número de instantes.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistance(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 0.5
SELECT round(frechetDistance(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 1.414214
</programlisting>
			</listitem>

			<listitem id="frechetDistancePath">
				<indexterm><primary><varname>frechetDistancePath</varname></primary></indexterm>
				<para>Obtener las parejas de correspondencia entre dos valores temporales con respecto a la distancia de Fréchet discreta &Z_support; &geography_support; &SRF;</para>
				<para><varname>frechetDistancePath({tnumber, tgeo}, {tnumber, tgeo}): pairs</varname></para>
				<para>Esta función requiere ubicar en memoria una matriz de distancias cuyo tamaño es cuadrático en el número de instantes de los valores temporales. Por tanto, la función fallará para valores temporales con gran número de instantes dependiendo de la memoria disponible.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistancePath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT frechetDistancePath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarp">
				<indexterm><primary><varname>dynamicTimeWarp</varname></primary></indexterm>
				<para>Obtener la distancia de distorsión de tiempo dinámica (<ulink url="https://en.wikipedia.org/wiki/Dynamic_time_warping">Dynamic Time Warp</ulink> o DTW) entre dos valores temporales &Z_support; &geography_support;</para>
				<para><varname>dynamicTimeWarp({tnumber, tgeo}, {tnumber, tgeo}): float</varname></para>
				<para>Esta función tiene una complejidad de espacio lineal ya que solo dos filas de la matriz de distancia son asignadas en la memoria. Sin embargo, su complejidad de tiempo es cuadrática en el número de instantes de los valores temporales. Por lo tanto, la función requerirá un tiempo considerable para valores temporales con gran número de instantes.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarp(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 2
SELECT round(dynamicTimeWarp(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 3.380776
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarpPath">
				<indexterm><primary><varname>dynamicTimeWarpPath</varname></primary></indexterm>
				<para>btener las parejas de correspondencia entre dos valores temporales con respecto a la distancia de distorsión de tiempo dinámica (Dynamic Time Warp o DTW) &Z_support; &geography_support; &SRF;</para>
				<para><varname>dynamicTimeWarpPath({tnumber, tgeo}, {tnumber, tgeo}): pairs</varname></para>
				<para><varname>frechetDistancePath({tnumber, tgeo}, {tnumber, tgeo}): pairs</varname></para>
				<para>Esta función requiere ubicar en memoria una matriz de distancias cuyo tamaño es cuadrático en el número de instantes de los valores temporales. Por tanto, la función fallará para valores temporales con gran número de instantes dependiendo de la memoria disponible.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarpPath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT dynamicTimeWarpPath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Mosaicos multidimensionales</title>
		<para>Los mosaicos multidimensionales es el mecanismo que se utiliza para dividir el dominio de valores temporales en intervalos o mosaicos de un número variable de dimensiones. En el caso de una sola dimensión, el dominio se puede dividir por valor o por tiempo utilizando intervalos del mismo ancho o la misma duración, respectivamente. Para los números temporales, el dominio se puede dividir en mosaicos bidimensionales del mismo ancho para la dimensión de valor y la misma duración para la dimensión de tiempo. Para los puntos temporales, el dominio se puede dividir en el espacio en mosaicos bidimensionales o tridimensionales, dependiendo del número de dimensiones de las coordenadas espaciales. Finalmente, para los puntos temporales, el dominio se puede dividir por espacio y por tiempo usando mosaicos tridimensionales o tetradimensionales. Además, los valores temporales también se pueden fragmentar de acuerdo con una malla multidimensional definida sobre el dominio subyacente.</para>

		<para>Los mosaicos multidimensionales se pueden utilizar para diversos fines. Por ejemplo, se pueden utilizar para calcular histogramas multidimensionales, donde los valores temporales se agregan de acuerdo con la partición subyacente del dominio. Por otro lado, el mosaico multidimensional se puede utilizar para distribuir un conjunto de datos en un grupo de servidores, donde cada servidor contiene una partición del conjunto de datos. La ventaja de este mecanismo de partición es que conserva la proximidad en el espacio y el tiempo, a diferencia de los mecanismos de partición tradicionales basados ​​en hash utilizados en entornos de big data.</para>

		<figure id="tiling">
			<title>Mosaicos multidimensionales para números flotantes temporales.</title>
			<mediaobject>
				<imageobject role="html"><imagedata format="SVG" fileref='../images/tiling.svg'/></imageobject>
				<imageobject role="dblatex"><imagedata scale='75' format="PDF" fileref='../images/tiling.pdf'/></imageobject>
				<imageobject role="dbtoepub"><imagedata scale='75' format="PDF" fileref='../images/tiling.pdf'/></imageobject>
			</mediaobject>
		</figure>

		<para>
			La <xref linkend="tiling" /> ilustra un mosaico multidimensional para números flotantes temporales. El dominio bidimensional se divide en mosaicos que tienen el mismo tamaño para la dimensión de valor y la misma duración para la dimensión de tiempo. Suponga que este esquema de mosaicos se usa para distribuir un conjunto de datos en un clúster de seis servidores, como sugiere el patrón gris en la figura. En este caso, los valores se fragmentan para que cada servidor reciba los datos de mosaicos contiguos. Esto implica en particular que cuatro nodos recibirán un fragmento del número flotante temporal que se muestra en la figura. Una ventaja de esta distribución de datos basada en mosaicos multidimensionales es que reduce los datos que deben intercambiarse entre nodos cuando se procesan consultas, un proceso que generalmente se denomina <emphasis>reshuffling</emphasis>.
		</para>

		<para>Muchas de las funciones de esta sección son <emphasis>funciones de retorno de conjuntos</emphasis> (también conocidas como <emphasis>funciones de tabla</emphasis>) ya que normalmente devuelven más de un valor. En este caso, las funciones están marcadas con el símbolo &SRF;.</para>

		<sect2 id="bucket_functions">
			<title>Operaciones de intervalos</title>

			<itemizedlist>
				<listitem id="bucketList">
					<indexterm><primary><varname>bucketList</varname></primary></indexterm>
					<para>Obtener un conjunto de parejas (índice, intervalo) que cubre el rango o el período con intervalos de la misma amplitud o duración alineados con el origen &SRF;.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en 0 para los rangos y en lunes 3 de enero de 2000 para los períodos. Los índices empiezan en 1. </para>
					<para><varname>bucketList(bounds span,width number,origin number=0): setof index_span</varname></para>
					<para><varname>bucketList(bounds period,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  setof index_period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(tint '[15@2000-01-01, 25@2000-01-10]'::intspan, 2) AS bl) t;
-- 1 | [14,16)
-- 2 | [16,18)
-- 3 | [18,20)
-- ...
SELECT bucketList(tfloat '[-1@2000-01-01, -10@2000-01-10]'::floatspan, 2, -7);
-- (1,"[-11,-9)")
-- (2,"[-9,-7)")
-- (3,"[-7,-5)")
-- ...
SELECT (bl).index, (bl).period
FROM (SELECT bucketList(tfloat '[1@2000-01-15, 10@2000-01-25]'::period,'2 days') AS bl) t;
-- 1 | [2000-01-15,2000-01-17)
-- 2 | [2000-01-17,2000-01-19)
-- 3 | [2000-01-19,2000-01-21)
-- ...
SELECT bucketList(tfloat '[1@2000-01-15, 10@2000-01-25]'::period, '2 days', '2000-01-02');
-- (1,"[2000-01-14,2000-01-16)")
-- (2,"[2000-01-16,2000-01-18)")
-- (3,"[2000-01-18,2000-01-20)")
-- ...
</programlisting>
				</listitem>

				<listitem id="valueBucket">
					<indexterm><primary><varname>valueBucket</varname></primary></indexterm>
					<para> Obtener el valor inicial del intervalo que contiene el número de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en 0.</para>
					<para><varname>valueBucket(value number,width number, origin number=0): number</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT valueBucket(3, 2);
-- 2
SELECT valueBucket(3.5, 2.5, 1.5);
-- 1.5
</programlisting>
				</listitem>

				<listitem id="spanBucket">
					<indexterm><primary><varname>spanBucket</varname></primary></indexterm>
					<para>Obtener el rango en el espacio de intervalos que contiene el número de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en 0.</para>
					<para><varname>spanBucket(value number,width number,origin number=0): span</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT spanBucket(2, 2);
-- [2,4)
SELECT spanBucket(2, 2, 1);
-- [1,3)
SELECT spanBucket(2, 2.5);
-- [0,2.5)
SELECT spanBucket(2, 2.5, 1.5);
-- [1.5,4)
</programlisting>
				</listitem>

				<listitem id="timeBucket">
					<indexterm><primary><varname>timeBucket</varname></primary></indexterm>
					<para> Obtener el valor inicial del intervalo que contiene la marca de tiempo de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en lunes 3 de enero de 2000.</para>
					<para><varname>timeBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  timestamptz</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days');
-- 2020-04-29 01:00:00+02
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days', timestamptz '2020-01-01');
-- 2020-04-30 01:00:00+02
</programlisting>
				</listitem>

				<listitem id="periodBucket">
					<indexterm><primary><varname>periodBucket</varname></primary></indexterm>
					<para>Obtener el período en el espacio de intervalos que contiene la marca de tiempo de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en lunes 3 de enero de 2000.</para>
					<para><varname>periodBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodBucket('2000-01-04', interval '1 week');
-- [2000-01-03,2000-01-10)
SELECT periodBucket('2000-01-04', interval '1 week', '2000-01-07');
-- [1999-12-31,2000-01-07)
</programlisting>
				</listitem>

			</itemizedlist>
		</sect2>

		<sect2 id="grid_functions">
			<title>Operaciones de malla</title>

			<itemizedlist>
				<listitem id="multidimGrid">
					<indexterm><primary><varname>multidimGrid</varname></primary></indexterm>
					<para>Obtener un conjunto de parejas (índice, mosaico) que cubre el cuadro delimitador con mosaicos multidimensionales del mismo tamaño y duración. &Z_support; &SRF;</para>
					<para>Si el origen de las dimensiones de valores y/o de tiempo no se especifican, su valor se establece por defecto en 0 o <varname>'Point (0 0 0)'</varname> para la dimensión de valores (según el tipo de cuadro delimitador) y en el lunes 3 de enero de 2000 para la dimensión de tiempo.</para>
					<para><varname>multidimGrid(bounds tbox,size float,duration interval,vorigin float=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03'): setof index_box</varname></para>
					<para><varname>multidimGrid(bounds stbox,size float,sorigin geometry='Point(0 0 0)'):</varname></para>
					<para><varname>  setof index_box</varname></para>
					<para><varname>multidimGrid(bounds stbox,size float,duration interval,sorigin geometry='Point(0 0 0)',</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03'): setof index_box</varname></para>
					<para>En el caso de una malla espacio-temporal, el SRID de las coordenadas de los mosaicos está determinado por el del cuadro de entrada y el tamaño se da en las unidades del SRID. Si se especifica el origen de las coordenadas espaciales, que debe ser un punto, su dimensionalidad y SRID deben ser iguales al del cuadro delimitador, de lo contrario se genera un error.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (gr).index, (gr).box
FROM (SELECT multidimGrid(tfloat '[15@2000-01-15, 25@2000-01-25]'::tbox, 2.0, '2 days')
  AS gr) t;
-- 1 | TBOX XT([14,16),[2000-01-15,2000-01-17))
-- 2 | TBOX XT([16,18),[2000-01-15,2000-01-17))
-- 3 | TBOX XT([18,20),[2000-01-15,2000-01-17),)
-- ...
SELECT multidimGrid(tfloat '[15@2000-01-15, 25@2000-01-25]'::tbox, 2.0, '2 days', 11.5);
-- (1,"TBOX XT([13.5,15.5),[2000-01-15,2000-01-17))")
-- (2,"TBOX XT([15.5,17.5),[2000-01-15,2000-01-17))")
-- (3,"TBOX XT([17.5,19.5),[2000-01-15,2000-01-17))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0); 
-- (1,"STBOX X(((2,2),(4,4)))")
-- (2,"STBOX X(((4,2),(6,4)))")
-- (3,"STBOX X(((6,2),(8,4)))")
-- ...
SELECT multidimGrid(tgeompoint 'SRID=3812;[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3)');
-- (1,"SRID=3812;STBOX X(((3,3),(5,5)))")
-- (2,"SRID=3812;STBOX X(((5,3),(7,5)))")
-- (3,"SRID=3812;STBOX X(((7,3),(9,5)))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3 3)');
-- (1,"STBOX Z(((3,3,3),(5,5,5)))")
-- (2,"STBOX Z(((5,3,3),(7,5,5)))")
-- (3,"STBOX Z(((7,3,3),(9,5,5)))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, interval '2 days');
-- (1,"STBOX XT(((2,2),(4,4)),[2000-01-15,2000-01-17))")
-- (2,"STBOX XT(((4,2),(6,4)),[2000-01-15,2000-01-17))")
-- (3,"STBOX XT(((6,2),(8,4)),[2000-01-15,2000-01-17))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, '2 days', 'Point(3 3 3)', '2000-01-15');
-- (1,"STBOX ZT(((3,3,3),(5,5,5)),[2000-01-15,2000-01-17))")
-- (2,"STBOX ZT(((5,3,3),(7,5,5)),[2000-01-15,2000-01-17))")
-- (3,"STBOX ZT(((7,3,3),(9,5,5)),[2000-01-15,2000-01-17))")
-- ...
</programlisting>
				</listitem>

				<listitem id="multidimTile">
					<indexterm><primary><varname>multidimTile</varname></primary></indexterm>
					<para>Obtener el mosaico de la malla multidimensional que contiene el valor y la marca de tiempo. &Z_support;</para>
					<para>Si el origen de las dimensiones de valores y/o de tiempo no se especifican, su valor se establece por defecto en 0 o <varname>'Point(0 0 0)'</varname> para la dimensión de valores y en el lunes 3 de enero de 2000 para la dimensión de tiempo, respectivamente.</para>
					<para><varname>multidimTile(value float,time timestamptz,size float,duration interval,</varname></para>
					<para><varname>  vorigin float=0.0,torigin timestamptz='2000-01-03'): tbox</varname></para>
					<para><varname>multidimTile(point geometry,size float,sorigin geometry='Point(0 0 0)'): stbox</varname></para>
					<para><varname>multidimTile(point geometry,time timestamptz,size float,duration interval,sorigin</varname></para>
					<para><varname>  geometry='Point(0 0 0)',torigin timestamptz='2000-01-03'): stbox</varname></para>
					<para>En el caso de una malla espacio-temporal, el SRID de las coordenadas de los mosaicos está determinado por el punto de entrada y la amplitud espacial se da en las unidades del SRID. Si se especifica el origen de las coordenadas espaciales, que debe ser un punto, su dimensionalidad y SRID deben ser iguales al del cuadro delimitador, de lo contrario se genera un error.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT multidimTile(15, '2000-01-15', 2, interval '2 days');
-- TBOX XT([14,16),[2000-01-15,2000-01-17))
SELECT multidimTile(15, '2000-01-15', 2, interval '2 days', 1, '2000-01-02');
-- TBOX XT([15,17),[2000-01-14,2000-01-16))
SELECT multidimTile(geometry 'Point(1 1 1)', 2.0);
-- STBOX Z(((0,0,0),(2,2,2)))
SELECT multidimTile(geometry 'Point(1 1)', '2000-01-01', 2.0, interval '2 days');
-- STBOX XT((0,0),(2,2),[2000-01-01,2000-01-03))
SELECT multidimTile(geometry 'Point(1 1)', '2000-01-01', 2.0, '2 days', 'Point(1 1)',
  '2000-01-02');
-- STBOX XT(((1,1),(3,3)),[1999-12-31,2000-01-02))
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="split_functions">
			<title>Operaciones de fragmentación</title>
			<para>Estas operaciones fragmentan un valor temporal con respecto a una secuencia de intervalos (ver la <xref linkend="bucket_functions" />) o una malla multidimensional (ver la <xref linkend="grid_functions" />).</para>
			<itemizedlist>
				<listitem id="valueSplit">
					<indexterm><primary><varname>valueSplit</varname></primary></indexterm>
					<para>Fragmentar el número temporal con respecto a intervalos de valores. &SRF;</para>
					<para><varname>valueSplit(value tnumber,width number,origin number=0): setof number_tnumber</varname></para>
					<para>Si el origen de los valores no se especifica, su valor se establece por defecto en 0.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).tnumber
FROM (SELECT valueSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05, 10@2001-01-10]',
  2) AS sp) t;
--  0 | {[1@2001-01-01 00:00:00+01, 1@2001-01-02 00:00:00+01)}
--  2 | {[2@2001-01-02 00:00:00+01, 2@2001-01-05 00:00:00+01)}
--  4 | {[5@2001-01-05 00:00:00+01, 5@2001-01-10 00:00:00+01)}
-- 10 | {[10@2001-01-10 00:00:00+01]}
SELECT valueSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 2.0, 1.0);
-- (1,"{[1@2001-01-01 00:00:00+01, 3@2001-01-03 00:00:00+01)}")
-- (3,"{[3@2001-01-03 00:00:00+01, 5@2001-01-05 00:00:00+01)}")
-- (5,"{[5@2001-01-05 00:00:00+01, 7@2001-01-07 00:00:00+01)}")
-- (7,"{[7@2001-01-07 00:00:00+01, 9@2001-01-09 00:00:00+01)}")
-- (9,"{[9@2001-01-09 00:00:00+01, 10@2001-01-10 00:00:00+01)}")
</programlisting>
				</listitem>

				<listitem id="timeSplit">
					<indexterm><primary><varname>timeSplit</varname></primary></indexterm>
					<para>Fragmentar el valor temporal con respecto a intervalos de tiempo. &Z_support; &SRF;</para>
					<para><varname>timeSplit(value ttype,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  setof time_temp</varname></para>
					<para>Si el origen del tiempo no se especifica, su valor se establece por defecto en el lunes 3 de enero de 2000.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time, (ts).temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', '2 days') AS ts) t;
-- 2011-12-31 | [1@2001-01-01, 2@2001-01-02)
-- 2001-01-02 | [2@2001-01-02, 4@2001-01-04)
-- 2001-01-04 | [4@2001-01-04, 6@2001-01-06)
-- ...
SELECT (ts).time, astext((ts).temp) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-10]',
  '2 days', '2001-01-01') AS ts) AS t;
-- 2001-01-01 | [POINT Z (1 1 1)@2001-01-01, POINT Z (3 3 3)@2001-01-03)
-- 2001-01-03 | [POINT Z (3 3 3)@2001-01-03, POINT Z (5 5 5)@2001-01-05)
-- 2001-01-05 | [POINT Z (5 5 5)@2001-01-05, POINT Z (7 7 7)@2001-01-07)
-- ...
</programlisting>
					<para>Observe que se puede fragmentar un valor temporal en intervalos de tiempo cíclicos (en lugar de lineales). Los siguientes dos ejemplos muestran cómo fragmentar un valor temporal por hora y por día de la semana.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time::time as hour, merge((ts).temp) as temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-03]', '1 hour') AS ts) t
GROUP BY hour ORDER BY hour;
/* 00:00:00 | {[1@2001-01-01 00:00:00+01, 1.1875@2001-01-01 01:00:00+01),
               [5.5@2001-01-02 00:00:00+01, 5.6875@2001-01-02 01:00:00+01)} */
/* 01:00:00 | {[1.1875@2001-01-01 01:00:00+01, 1.375@2001-01-01 02:00:00+01),
               [5.6875@2001-01-02 01:00:00+01, 5.875@2001-01-02 02:00:00+01)} */
/* 02:00:00 | {[1.375@2001-01-01 02:00:00+01, 1.5625@2001-01-01 03:00:00+01),
               [5.875@2001-01-02 02:00:00+01, 6.0625@2001-01-02 03:00:00+01)} */
/* 03:00:00 | {[1.5625@2001-01-01 03:00:00+01, 1.75@2001-01-01 04:00:00+01),
               [6.0625@2001-01-02 03:00:00+01, 6.25@2001-01-02 04:00:00+01)} */
/* ... */
SELECT EXTRACT(DOW FROM (ts).time) as dow_no, TO_CHAR((ts).time, 'Dy') as dow,
  asText(round(merge((ts).temp), 2)) as temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-14)',
  '1 hour') AS ts) t
GROUP BY dow, dow_no ORDER BY dow_no;
/* 0 | Sun | {[POINT(1 1)@2001-01-01, POINT(1.69 1.69)@2001-01-02),
              [POINT(5.85 5.85)@2001-01-08, POINT(6.54 6.54)@2001-01-09)} */
/* 1 | Mon | {[POINT(1.69 1.69)@2001-01-02, POINT(2.38 2.38)@2001-01-03),
              [POINT(6.54 6.54)@2001-01-09, POINT(7.23 7.23)@2001-01-10)} */
/* 2 | Tue | {[POINT(2.38 2.38)@2001-01-03, POINT(3.08 3.08)@2001-01-04),
              [POINT(7.23 7.23)@2001-01-10, POINT(7.92 7.92)@2001-01-11)} */
/* ... */
</programlisting>
				</listitem>

				<listitem id="valueTimeSplit">
					<indexterm><primary><varname>valueTimeSplit</varname></primary></indexterm>
					<para>Fragmentar el número temporal con respecto a los mosaicos de una malla de valores y de tiempo. &SRF;</para>
					<para><varname>valueTimeSplit(value tumber,width number,duration interval,vorigin number=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03'): setof number_time_tnumber</varname></para>
					<para>Si el origen de los valores y/o el tiempo no se especifican, su valor se establece por defecto en 0 y en el lunes 3 de enero de 2000, respectivamente.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05,
  10@2001-01-10]', 5, '5 days') AS sp) t;
-- 0 | 2011-12-31 | [1@2001-01-01, 2@2001-01-02, 2@2001-01-05)
-- 5 | 2001-01-05 | [5@2001-01-05, 5@2001-01-10)
-- 10 | 2001-01-10 | [10@2001-01-10]
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 5.0, '5 days', 1.0,
  '2001-01-01') AS sp) t;
-- 1 | 2001-01-01 | [1@2001-01-01, 6@2001-01-06)
-- 6 | 2001-01-06 | [6@2001-01-06, 10@2001-01-10)
</programlisting>
				</listitem>

				<listitem id="spaceSplit">
					<indexterm><primary><varname>spaceSplit</varname></primary></indexterm>
					<para>Fragmentar el punto temporal con respecto a los mosaicos de una malla espacial. &SRF;</para>
					<para><varname>spaceSplit(value tgeompoint,width float,origin geometry='Point(0 0 0)',</varname></para>
					<para><varname>  bitmatrix=true): setof point_tpoint</varname></para>
					<para>Si el origen del espacio no se especifica, su valor se establece por defecto en <varname>'Point(0 0 0)'</varname>. Si no se especifica el argumento <varname>bitmatrix</varname>, el cálculo utilizará una matriz de bits para acelerar el proceso.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0) AS sp) t;
-- POINT(0 0) | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | {[POINT(2 2)@2020-03-02, POINT(4 4)@2020-03-04)}
-- POINT(4 4) | {[POINT(4 4)@2020-03-04, POINT(6 6)@2020-03-06)}
-- ...
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, 'Point(1 1 1)') AS sp) t;
-- POINT Z (1 1 1) | {[POINT Z (1 1 1)@2020-03-01, POINT Z (3 3 3)@2020-03-03)}
-- POINT Z (3 3 3) | {[POINT Z (3 3 3)@2020-03-03, POINT Z (5 5 5)@2020-03-05)}
-- POINT Z (5 5 5) | {[POINT Z (5 5 5)@2020-03-05, POINT Z (7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
				<listitem id="spaceTimeSplit">
					<indexterm><primary><varname>spaceTimeSplit</varname></primary></indexterm>
					<para>Fragmentar el punto temporal con respecto a los mosaicos de una malla espacio-temporal. &SRF;</para>
					<para><varname>spaceTimeSplit(value tgeompoint,size float,duration interval,sorigin </varname></para>
					<para><varname>  geometry='Point(0 0 0)',torigin timestamptz='2000-01-03', bitmatrix=true):</varname></para>
					<para><varname>  setof point_time_tpoint</varname></para>
					<para>Si el origen del espacio y/o el tiempo no se especifica, su valor se establece por defecto en <varname>'Point(0 0 0)'</varname> y en el lunes 3 de enero de 2000, respectivamente. Si no se especifica el argumento <varname>bitmatrix</varname>, el cálculo utilizará una matriz de bits para acelerar el proceso.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0, '2 days') AS sp) t;
-- POINT(0 0) | 2020-03-01 | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | 2020-03-01 | {[POINT(2 2)@2020-03-02, POINT(3 3)@2020-03-03]}
-- POINT(2 2) | 2020-03-03 | {[POINT(3 3)@2020-03-03, POINT(4 4)@2020-03-04)}
-- ...
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, '2 days', 'Point(1 1 1)', '2020-03-01') AS sp) t;
-- POINT Z(1 1 1) | 2020-03-01 | {[POINT Z(1 1 1)@2020-03-01, POINT Z(3 3 3)@2020-03-03)}
-- POINT Z(3 3 3) | 2020-03-03 | {[POINT Z(3 3 3)@2020-03-03, POINT Z(5 5 5)@2020-03-05)}
-- POINT Z(5 5 5) | 2020-03-05 | {[POINT Z(5 5 5)@2020-03-05, POINT Z(7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1>
		<title>Funciones agregadas</title>

		<para>Las funciones agregadas temporales generalizan las funciones agregadas tradicionales. Su semántica es que calculan el valor de la función en cada instante de la <emphasis>unión</emphasis> de las extensiones temporales de los valores a agregar. En contraste, recuerde que todas las otras funciones que manipulan tipos temporales calculan el valor de la función en cada instante de la <emphasis>intersección</emphasis> de las extensiones temporales de los argumentos.</para>

		<para>Las funciones agregadas temporales son las siguientes:</para>
		<itemizedlist>
			<listitem><para>Para todos los tipos temporales, la función <varname>tcount</varname> generaliza la función traditional <varname>count</varname>. El conteo temporal se puede utilizar para calcular en cada momento el número de objetos disponibles (por ejemplo, el número de coches en un área).</para></listitem>
			<listitem><para>Para todos los tipos temporales, la función <varname>extent</varname> devuelve un cuadro delimitador que engloba un conjunto de valores temporales. Dependiendo del tipo de base, el resultado de esta función puede ser un <varname>period</varname>, un <varname>tbox</varname> o un <varname>stbox</varname>.</para></listitem>
			<listitem><para>Para el tipo booleano temporal, las funciones <varname>tand</varname> y <varname>tor</varname> generalizan las funciones traditionales <varname>and</varname> y <varname>or</varname>.</para></listitem>
			<listitem><para>Para los tipos numéricos temporales hay dos tipos de funciones agregadas temporales. Las funciones <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname> y <varname>tavg</varname> generalizan las funciones traditionales <varname>min</varname>, <varname>max</varname>, <varname>sum</varname> y <varname>avg</varname>. Además, las funciones <varname>wmin</varname>, <varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname> y <varname>wavg</varname> son versiones de ventana (o acumulativas) de las funciones tradicionales que, dado un intervalo de tiempo w, calculan el valor de la función en un instante t considerando los valores durante el intervalo [t-w, t]. Todas las funciones agregadas de ventana están disponibles para enteros temporales, mientras que para flotantes temporales sólo son significativos el mínimo y el máximo de ventana.</para></listitem>
			<listitem><para>Para el tipo texto temporal, las funciones <varname>tmin</varname> y <varname>tmax</varname> generalizan las funciones traditionales <varname>min</varname> y <varname>max</varname>.</para></listitem>
			<listitem><para>Finalmente, para puntos temporales, la función <varname>tcentroid</varname> generaliza la función <varname>ST_Centroid</varname> proporcionada por PostGIS. Por ejemplo, dado un conjunto de objetos que se mueven juntos (es decir, un convoy o una bandada), el centroide temporal producirá un punto temporal que representa en cada instante el centro geométrico (o el centro de masa) de todos los objetos en movimiento.</para></listitem>
		</itemizedlist>

		<para>En los ejemplos que siguen, suponemos que las tablas <varname>Department</varname> y <varname>Trip</varname> contienen las dos tuplas introducidas en la <xref linkend="examples_temporal_types" />.</para>
		<itemizedlist>
			<listitem id="tcount">
				<indexterm><primary><varname>tcount</varname></primary></indexterm>
				<para>Conteo temporal</para>
				<para><varname>tcount(ttype): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcount(NoEmps) FROM Department;
-- {[1@2001-01-01, 2@2001-02-01, 1@2001-08-01, 1@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="extent">
				<indexterm><primary><varname>extent</varname></primary></indexterm>
				<para>Extensión del cuadro delimitador</para>
				<para><varname>extent(temp): {period,tbox,stbox}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT extent(noEmps) FROM Department;
-- TBOX XT((4,12),[2001-01-01,2001-10-01])
SELECT extent(Trip) FROM Trips;
-- STBOX XT(((0,0),(3,3),[2001-01-01 08:00:00+01, 2001-01-01 08:20:00+01)))
</programlisting>
			</listitem>

			<listitem id="tand">
				<indexterm><primary><varname>tand</varname></primary></indexterm>
				<para>Y temporal</para>
				<para><varname>tand(tbool): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tand(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-04-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tor">
				<indexterm><primary><varname>tor</varname></primary></indexterm>
				<para>O temporal</para>
				<para><varname>tor(tbool): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tor(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-08-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmin">
				<indexterm><primary><varname>tmin</varname></primary></indexterm>
				<para>Mínimo temporal</para>
				<para><varname>tmin(ttype): {ttype_seq,ttype_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmin(NoEmps) FROM Department;
-- {[10@2001-01-01, 4@2001-02-01, 6@2001-06-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmax">
				<indexterm><primary><varname>tmax</varname></primary></indexterm>
				<para>Máximo temporal</para>
				<para><varname>tmax(ttype): {ttype_seq,ttype_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmax(NoEmps) FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tsum">
				<indexterm><primary><varname>tsum</varname></primary></indexterm>
				<para>Suma temporal</para>
				<para><varname>tsum(tnumber): {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tsum(NoEmps) FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 16@2001-04-01, 18@2001-06-01, 6@2001-08-01,
   6@2001-10-01)} */
</programlisting>
			</listitem>

			<listitem id="tavg">
				<indexterm><primary><varname>tavg</varname></primary></indexterm>
				<para>Promedio temporal</para>
				<para><varname>tavg(tnumber): {tfloat_seq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tavg(NoEmps) FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8@2001-04-01, 8@2001-06-01), [9@2001-06-01, 9@2001-08-01),
   [6@2001-08-01, 6@2001-10-01) */
</programlisting>
			</listitem>

			<listitem id="wmin">
				<indexterm><primary><varname>wmin</varname></primary></indexterm>
				<para>Mínimo de ventana</para>
				<para><varname>wmin(tnumber,interval): {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmin(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 4@2001-04-01, 6@2001-06-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wmax">
				<indexterm><primary><varname>wmax</varname></primary></indexterm>
				<para>Máximo de ventana</para>
				<para><varname>wmax(tnumber,interval): {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmax(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wcount">
				<indexterm><primary><varname>wcount</varname></primary></indexterm>
				<para>Conteo de ventana</para>
				<para><varname>wcount(tnumber,interval): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wcount(NoEmps, interval '2 days') FROM Department;
/* {[1@2001-01-01, 2@2001-02-01, 3@2001-04-01, 2@2001-04-03, 3@2001-06-01, 2@2001-06-03,
   1@2001-08-03, 1@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wsum">
				<indexterm><primary><varname>wsum</varname></primary></indexterm>
				<para>Suma de ventana</para>
				<para><varname>wsum(tint,interval): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wsum(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 26@2001-04-01, 16@2001-04-03, 22@2001-06-01,
   18@2001-06-03, 6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wavg">
				<indexterm><primary><varname>wavg</varname></primary></indexterm>
				<para>Promedio de ventana</para>
				<para><varname>wavg(tint,interval): {tfloat_discseq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wavg(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8.66666666666667@2001-04-01, 8.66666666666667@2001-04-03),
   [8@2001-04-03, 8@2001-06-01),
   [7.33333333333333@2001-06-01, 7.33333333333333@2001-06-03),
   [9@2001-06-03, 9@2001-08-03), [6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="tcentroid">
				<indexterm><primary><varname>tcentroid</varname></primary></indexterm>
				<para>Centroide temporal</para>
				<para><varname>tcentroid(tgeompoint): tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcentroid(Trip) FROM Trips;
/* {[POINT(0 0)@2001-01-01 08:00:00+00, POINT(1 0)@2001-01-01 08:05:00+00),
   [POINT(0.5 0)@2001-01-01 08:05:00+00, POINT(1.5 0.5)@2001-01-01 08:10:00+00,
   POINT(2 1.5)@2001-01-01 08:15:00+00),
   [POINT(2 2)@2001-01-01 08:15:00+00, POINT(3 3)@2001-01-01 08:20:00+00)} */
</programlisting>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones de utilidad</title>
		<itemizedlist>
			<listitem id="mobilitydb_version">
				<indexterm><primary><varname>mobilitydb_version</varname></primary></indexterm>
				<para>Versión de la extensión MobilityDB</para>
				<para><varname>mobilitydb_version(): text</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT mobilitydb_version();
-- MobilityDB 1.1
</programlisting>
			</listitem>

			<listitem id="mobilitydb_full_version">
				<indexterm><primary><varname>mobilitydb_full_version</varname></primary></indexterm>
				<para>Versión de la extensión MobilityDB y de sus dependencias</para>
				<para><varname>mobilitydb_full_version(): text</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT mobilitydb_full_version();
-- MobilityDB 1.1.0, PostgreSQL 14.2, PostGIS 3.2.1
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="indexing_temporal_types">
		<title>Indexación de tipos temporales</title>
		<para>Se pueden crear índices GiST y SP-GiST para columnas de tabla de tipos temporales. El índice GiST implementa un árbol R, mientras que el índice SP-GiST implementa un árbol cuádruple n-dimensional. Ejemplos de creación de índices son los siguientes:
			<programlisting language="sql" xml:space="preserve">
CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		</para>

		<para>Los índices GiST y SP-GiST almacenan el cuadro delimitador para los tipos temporales. Como se explica en el <xref linkend="temporal_types" />, estos son
			<itemizedlist>
				<listitem>
					<para>el tipo <varname>period</varname> para los tipos <varname>tbool</varname> y <varname>ttext</varname>,</para>
				</listitem>

				<listitem>
					<para>el tipo <varname>tbox</varname> par los tipos <varname>tint</varname> y <varname>tfloat</varname>,</para>
				</listitem>

				<listitem>
					<para>el tipo <varname>stbox</varname> para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Un índice GiST o SP-GiST puede acelerar las consultas que involucran a los siguientes operadores (consulte la <xref linkend="operators_temporal_types" /> para obtener más información):
			<itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, que sólo consideran la dimensión de valores en tipos alfanuméricos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname> y <varname>/&amp;&gt;</varname>, que sólo consideran la dimensión espacial en tipos de puntos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, que sólo consideran la dimensión temporal para todos los tipos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname> y <varname>|=|</varname>, que consideran tantas dimensiones como compartan la columna indexada y el argumento de consulta. Estos operadores trabajan en cuadros delimitadores (es decir, <varname>period</varname>, <varname>tbox</varname> o <varname>stbox</varname>), no los valores completos.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Por ejemplo, dado el índice definido anteriormente en la tabla <varname>Department</varname> y una consulta que implica una condición con el operador <varname>&amp;&amp;</varname> (superposición), si el argumento derecho es un flotante temporal, entonces se consideran tanto el valor como las dimensiones de tiempo para filtrar las tuplas de la relación, mientras que si el argumento derecho es un valor flotante, un rango flotante o un tipo de tiempo, entonces el valor o la dimensión de tiempo se utilizará para filtrar las tuplas de la relación. Además, se puede construir un cuadro delimitador a partir de un valor/rango y/o una marca de tiempo/período, que se puede usar para filtrar las tuplas de la relación. Ejemplos de consultas que utilizan el índice en la tabla <varname>Department</varname> definida anteriormente se dan a continuación.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;
SELECT * FROM Department WHERE NoEmps &amp;&amp; intspan '[1, 5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2001-04-01';
SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2001-04-01, 2001-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tbox(intspan '[1, 5)', period '[2001-04-01, 2001-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tfloat '{[1@2001-01-01, 1@2001-02-01), [5@2001-04-01, 5@2001-05-01)}';
</programlisting>
		</para>

		<para>Del mismo modo, los ejemplos de consultas que utilizan el índice en la tabla <varname>Trips</varname> definida anteriormente se dan a continuación.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;
  stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;
  tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
</programlisting>
		</para>

		<para>Finalmente, se pueden crear índices de árbol B para columnas de tabla de todos los tipos temporales. Para este tipo de índice, la única operación útil es la igualdad. Hay un orden de clasificación de árbol B definido para valores de tipos temporales, con los correspondientes operadores <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname> y <varname>&gt;=</varname>, pero el orden es bastante arbitrario y no suele ser útil en el mundo real. El soporte de árbol B para tipos temporales está destinado principalmente a permitir la clasificación interna en las consultas, en lugar de la creación de índices reales.</para>

		<para>Para acelerar varias de las funciones en el <xref linkend="manipulating_temporal_types" />, se puede agregar en la cláusula <varname>WHERE</varname> de las consultas una comparación de cuadro delimitador que hace uso de los índices disponibles. Por ejemplo, este sería típicamente el caso de las funciones que proyectan los tipos temporales a las dimensiones de valor/espacio y/o tiempo. Esto filtrará las tuplas con un índice como se muestra en la siguiente consulta.
			<programlisting language="sql" xml:space="preserve">
SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))
FROM Trips T
-- Filtro de índice con cuadro delimitador
WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)
</programlisting>
		</para>

		<para>En el caso de los puntos temporales, todas las relaciones espaciales con la semántica posible (ver la <xref linkend="spatial_relationships_temporal_points" />) incluyen automáticamente una comparación de cuadro delimitador que hará uso de cualquier índice que esté disponible en los puntos temporales. Por esta razón, la primera versión de las relaciones se usa típicamente para filtrar las tuplas con la ayuda de un índice al calcular las relaciones temporales como se muestra en la siguiente consulta.
			<programlisting language="sql" xml:space="preserve">
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Filtro de índice con cuadro delimitador
WHERE intersects(T.Trip, R.Geom);
</programlisting>
		</para>
	</sect1>

	<sect1 id="statistics_temporal_types">
		<title>Estadísticas y selectividad para tipos temporales</title>
		<sect2>
			<title>Colecta de estadísticas</title>
			<para>El planificador de PostgreSQL se basa en información estadística sobre el contenido de las tablas para generar el plan de ejecución más eficiente para las consultas. Estas estadísticas incluyen una lista de algunos de los valores más comunes en cada columna y un histograma que muestra la distribución aproximada de datos en cada columna. Para tablas grandes, se toma una muestra aleatoria del contenido de la tabla, en lugar de examinar cada fila. Esto permite analizar tablas grandes en poco tiempo. La información estadística es recopilada por el comando <varname>ANALYZE</varname> y es almacenada en la tabla de catálogo <varname>pg_statistic</varname>. Dado que diferentes tipos de estadísticas pueden ser apropiados para diferentes tipos de datos, la tabla sólo almacena estadísticas muy generales (como el número de valores nulos) en columnas dedicadas. Todo lo demás se almacena en cinco &ldquo;slots&rdquo;, que son pares de columnas de matriz que almacenan las estadísticas de una columna de un tipo arbitrario.</para>

			<para>Las estadísticas recopiladas para tipos de tiempo y tipos temporales se basan en las recopiladas por PostgreSQL para tipos escalares y tipos de rango. Para tipos escalares, como <varname>float</varname>, se recopilan las siguientes estadísticas:
				<orderedlist numeration="arabic">
					<listitem>
						<para>fracción de valores nulos,</para>
					</listitem>
					<listitem>
						<para>ancho promedio, en bytes, de valores no nulos,</para>
					</listitem>
					<listitem>
						<para>número de diferentes valores no nulos,</para>
					</listitem>
					<listitem>
						<para>matriz de los valores más comunes y matriz de sus frecuencias,</para>
					</listitem>
					<listitem>
						<para>histograma de valores, donde se excluyen los valores más comunes,</para>
					</listitem>
					<listitem>
						<para>correlación entre el orden de filas físico y lógico.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Para los tipos de rango, como <varname>tstzrange</varname>, se recopilan tres histogramas adicionales:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>histograma de longitud de rangos no vacíos,</para>
					</listitem>
					<listitem>
						<para>histogramas de límites superior e inferior.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Para geometrías, además de (1)&#x2013;(3), se recopilan las siguientes estadísticas:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>número de dimensiones de los valores, cuadro delimitador N-dimensional, número de filas en la tabla, número de filas en la muestra, número de valores no nulos,</para>
					</listitem>
					<listitem>
						<para>Histograma N-dimensional que divide el cuadro delimitador en varias celdas y mantiene la proporción de valores que se cruzan con cada celda.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Las estadísticas recopiladas para columnas de los tipos de tiempo y de rango <varname>timestampset</varname>, <varname>period</varname>, <varname>periodset</varname>, <varname>intspan</varname> y <varname>floatspan</varname> replican las recopiladas por PostgreSQL para <varname>tstzrange</varname>. Esto es claro para los tipos de rango en MobilityDB, que son versiones más eficientes de los tipos de rango en PostgreSQL. Para los tipos <varname>timestampset</varname> y <varname>periodset</varname>, un valor se convierte en su período delimitador y luego se recopilan las estadísticas del tipo <varname>period</varname>.</para>

			<para>Las estadísticas recopiladas para columnas de los tipos temporales dependen del subtipo temporal y del tipo base. Además de las estadísticas (1)&#x2013;(3) que se recopilan para todos los tipos temporales, las estadísticas se recopilan para la dimensiónes de tiempo y de valor de forma independiente. Más precisamente, se recopilan las siguientes estadísticas para la dimensión de tiempo:
				<itemizedlist>
					<listitem>
						<para>Para columnas de subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para las marcas de tiempo.</para>
					</listitem>

					<listitem>
						<para>Para columnas de otro subtipo, las estadísticas (7)&#x2013;(8) se recopilan para los períodos delimitadores.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>Las siguientes estadísticas se recopilan para la dimensión de valores:
				<itemizedlist>
					<listitem>
						<para>Para columnas de tipos temporales con interpolación escalonada (es decir, <varname>tbool</varname>, <varname>ttext</varname> o <varname>tint</varname>):
							<itemizedlist>
								<listitem>
									<para>Para el subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para los valores.</para>
								</listitem>

								<listitem>
									<para>Para todas los demás subtipos, las estadísticas (7)&#x2013;(8) se recopilan para los valores.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>Para columnas de tipos temporales flotantes (es decir, <varname>tfloat</varname>):
							<itemizedlist>
								<listitem>
									<para>Para el subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para los valores.</para>
								</listitem>
								<listitem>
									<para>Para todas los demás subtipos, las estadísticas (7)&#x2013;(8) se recopilan por los rangos delimitadores de valores.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>Para columnas de tipos de puntos temporales (es decir, <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>) las estadísticas (9)&#x2013;(10) se compilan para los puntos.</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Estimación de la selectividad de los operadores</title>

			<para>Los operadores booleanos en PostgreSQL se pueden asociar con dos funciones de selectividad, que calculan la probabilidad de que un valor de un tipo dado coincida con un criterio dado. Estas funciones de selectividad se basan en las estadísticas recopiladas. Hay dos tipos de funciones de selectividad. Las funciones de selectividad de <emphasis>restricción</emphasis> intentan estimar el porcentaje de filas en una tabla que satisfacen una condición en la cláusula <varname>WHERE</varname> de la forma <varname>column OP constant</varname>. Por otro lado, las funciones de selectividad de <emphasis>unión</emphasis> intentan estimar el porcentaje de filas en una tabla que satisfacen una condición en la cláusula <varname>WHERE</varname> de la forma <varname>table1.column1 OP table2.column2</varname>.</para>

			<para>MobilityDB define 23 clases de operadores booleanos (como<varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), cada uno de los cuales puede tener como argumentos izquierdo o derecho un tipo PostgreSQL (como <varname>integer</varname>, <varname>timestamptz</varname>, etc.) o un tipo MobilityDB (como <varname>period</varname>, <varname>tint</varname>, etc.). Como consecuencia, existe un número muy elevado de operadores con diferentes argumentos a considerar para las funciones de selectividad. El enfoque adoptado fue agrupar estas combinaciones en clases correspondientes a las dimensiones de valor o de tiempo. Las clases corresponden al tipo de estadísticas recopiladas como se explica en la sección anterior.</para>

			<para>MobilityDB estima la selectividad de restricción y de combinación para tipos de tiempo, de rango y temporales.</para>
		</sect2>
	</sect1>
</chapter>
