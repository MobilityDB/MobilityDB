<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="temporal_types_spatial">
	<title>Tipos temporales: Operaciones espaciales</title>
	<para>A continuación, especificamos con el símbolo &Z_support; que la función admite puntos 3D y con el  símbolo &geography_support; que la función está disponible para geografías.</para>

	<sect1 id="tpoint_inout">
		<title>Entrada y salida</title>

		<itemizedlist>
			<listitem id="asText">
				<indexterm><primary><varname>asText</varname></primary></indexterm>
				<para>Obtener la representación de texto conocido (Well-Known Text o WKT) &Z_support; &geography_support;</para>
				<para><varname>asText({tpoint,tpoint[],geo[]}) → {text,text[]}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02)');
-- [POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02)
SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);
-- {"POINT(0 0)","POINT(1 1)"}
</programlisting>
			</listitem>

			<listitem id="asEWKT">
				<indexterm><primary><varname>asEWKT</varname></primary></indexterm>
				<para>Obtener la representación extendida de texto conocido (Extended Well-Known Text o EWKT)</para>
				<para><varname>asEWKT({tpoint,tpoint[],geo[]}) → {text,text[]}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02)');
-- SRID=4326;[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02)
SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);
-- {"SRID=5676;POINT(0 0)","SRID=5676;POINT(1 1)"}
</programlisting>
			</listitem>

			<listitem id="asMFJSON">
				<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>Obtener la representación JSON de características móviles (Moving Features JSON o MF-JSON) &Z_support; &geography_support;</para>
				<para><varname>asMFJSON(tpoint,options=0,flags=0,maxdecdigits=15) → text</varname></para>
				<para>El argumento <varname>options</varname> puede usarse para agregar BBOX y/o CRS en la salida MFJSON:</para>
				<itemizedlist>
					<listitem><para>0: significa que no hay opción (valor por defecto)</para></listitem>
					<listitem><para>1: MFJSON BBOX</para></listitem>
					<listitem><para>2: MFJSON Short CRS (e.g., EPSG:4326)</para></listitem>
					<listitem><para>4: MFJSON Long CRS (e.g., urn:ogc:def:crs:EPSG::4326)</para></listitem>
				</itemizedlist>
				<para>El argumento <varname>flags</varname> puede usarse para personalizar la salida JSON, por ejemplo, para producir una salida JSON fácil de leer (para lectores humanos). Consulte la documentación de la biblioteca <varname>json-c</varname> para conocer los valores posibles. Los valores típicos son los siguientes:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: JSON_C_TO_STRING_SPACED</para></listitem>
					<listitem><para>2: JSON_C_TO_STRING_PRETTY</para></listitem>
				</itemizedlist>
				<para>El argumento <varname>maxdecdigits</varname> puede usarse para establecer el número máximo de decimales en la salida de los valores en punto flotante (por defecto 15).</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asMFJSON(tgeompoint 'Point(1 2)@2001-01-01 18:00:00.15+02');
/* {"type":"MovingPoint","coordinates":[[1,2]],"datetimes":["2001-01-01T17:00:00.15+01"],
   "interpolation":"None"} */
SELECT asMFJSON(tgeompoint 'SRID=4326;
  Point(50.813810 4.384260)@2001-01-01 18:00:00.15+02', 3, 2);
/* {"type":"MovingPoint","crs":{"type":"name","properties":{"name":"EPSG:4326"}},
   "stBoundedBy":{"bbox":[50.81,4.38,50.81,4.38],
   "period":{"begin":"2001-01-01 17:00:00.15+01","end":"2001-01-01 17:00:00.15+01"}},
   "coordinates":[[50.81,4.38]],"datetimes":["2001-01-01T17:00:00.15+01"],
   "interpolation":"None"} */
</programlisting>
			</listitem>

			<listitem id="asBinary">
				<indexterm><primary><varname>asBinary</varname></primary></indexterm>
				<para>Obtener la representación binaria conocida (Well-Known Binary o WKB) &Z_support; &geography_support;</para>
				<para><varname>asBinary(tpoint,endian text='') → bytea</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asBinary(tgeompoint 'Point(1 2 3)@2001-01-01');
-- \x012e0011000000000000f03f00000000000000400000000000000840009c57d3c11c0000
</programlisting>
			</listitem>

			<listitem id="asEWKB">
				<indexterm><primary><varname>asEWKB</varname></primary></indexterm>
				<para>Obtener la representación extendida binaria conocida (Extended Well-Known Binary o EWKB) &Z_support; &geography_support;</para>
				<para><varname>asEWKB(tpoint,endian text='') → bytea</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKB(tgeogpoint 'SRID=7844;Point(1 2 3)@2001-01-01');
-- \x012f0071a41e0000000000000000f03f00000000000000400000000000000840009c57d3c11c0000
</programlisting>
			</listitem>

			<listitem id="asHexEWKB">
				<indexterm><primary><varname>asHexEWKB</varname></primary></indexterm>
				<para>Obtener la representación hexadecimal extendida binaria conocida (Extended Well-Known Binary o EWKB) en formato texto &Z_support; &geography_support;</para>
				<para><varname>asHexEWKB(tpoint,endian text='') → text</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asHexEWKB(tgeompoint 'SRID=3812;Point(1 2 3)@2001-01-01');
-- 012E0051E40E0000000000000000F03F00000000000000400000000000000840009C57D3C11C0000
</programlisting>
			</listitem>

			<listitem id="tgeompointFromText">
				<indexterm><primary><varname>tgeompointFromText</varname></primary></indexterm>
				<indexterm><primary><varname>tgeogpointFromText</varname></primary></indexterm>
				<para>Entrar un punto temporal en una representación de texto conocido (Well-Known Text o WKT) &Z_support; &geography_support;</para>
				<para><varname>tgeompointFromText(text) → tgeompoint</varname></para>
				<para><varname>tgeogpointFromText(text) → tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromText(text '[POINT(1 2)@2001-01-01, POINT(3 4)@2001-01-02]'));
-- [POINT(1 2)@2001-01-01, POINT(3 4)@2001-01-02]
SELECT asEWKT(tgeogpointFromText(text '[POINT(1 2)@2001-01-01, POINT(3 4)@2001-01-02]'));
-- SRID=4326;[POINT(1 2)@2001-01-01, POINT(3 4)@2001-01-02]
</programlisting>
			</listitem>

			<listitem id="tgeompointFromEWKT">
				<indexterm><primary><varname>tgeompointFromEWKT</varname></primary></indexterm>
				<indexterm><primary><varname>tgeogpointFromEWKT</varname></primary></indexterm>
				<para>Entrar un punto temporal en una representación extendida de texto conocido (Extended Well-Known Text o EWKT) &Z_support; &geography_support;</para>
				<para><varname>tgeompointFromEWKT(text) → tgeompoint</varname></para>
				<para><varname>tgeogpointFromEWKT(text) → tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromEWKT(text 'SRID=3812;[POINT(1 2)@2001-01-01,
  POINT(3 4)@2001-01-02]'));
-- SRID=3812;[POINT(1 2)@2001-01-01 00:00:00+01, POINT(3 4)@2001-01-02 00:00:00+01]
SELECT asEWKT(tgeogpointFromEWKT(text 'SRID=7844;[POINT(1 2)@2001-01-01,
	POINT(3 4)@2001-01-02]'));
-- SRID=7844;[POINT(1 2)@2001-01-01, POINT(3 4)@2001-01-02]
</programlisting>
			</listitem>

			<listitem id="tgeompointFromMFJSON">
				<indexterm><primary><varname>tgeompointFromMFJSON</varname></primary></indexterm>
				<indexterm><primary><varname>tgeogpointFromMFJSON</varname></primary></indexterm>
				<para>Entrar un punto temporal en una representación JSON de características móviles (Moving Features) &Z_support; &geography_support;</para>
				<para><varname>tgeompointFromMFJSON(text) → tgeompoint</varname></para>
				<para><varname>tgeogpointFromMFJSON(text) → tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromMFJSON(text '{"type":"MovingGeomPoint","crs":{"type":"name",
  "properties":{"name":"EPSG:4326"}},"coordinates":[[50.81,4.38]],
  "datetimes":["2001-01-01T17:00:00.15+01"],"interpolation":"None"}'));
-- SRID=4326;POINT(50.81 4.38)@2001-01-01 17:00:00.15+01
SELECT asEWKT(tgeogpointFromMFJSON(text '{"type":"MovingGeogPoint","crs":{"type":"name",
  "properties":{"name":"EPSG:4326"}},"coordinates":[[50.81,4.38]],
  "datetimes":["2001-01-01T17:00:00.15+01"],"interpolation":"None"}'));
-- SRID=4326;POINT(50.81 4.38)@2001-01-01 17:00:00.15+01
</programlisting>
			</listitem>

			<listitem id="tgeompointFromBinary">
				<indexterm><primary><varname>tgeompointFromBinary</varname></primary></indexterm>
				<indexterm><primary><varname>tgeogpointFromBinary</varname></primary></indexterm>
				<para>Entrar un punto temporal en una representación binaria conocida (WKB) &Z_support; &geography_support;</para>
				<para><varname>tgeompointFromBinary(bytea) → tgeompoint</varname></para>
				<para><varname>tgeogpointFromBinary(bytea) → tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromBinary(
  '\x012e0011000000000000f03f00000000000000400000000000000840009c57d3c11c0000'));
-- POINT Z (1 2 3)@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tgeompointFromEWKB">
				<indexterm><primary><varname>tgeompointFromEWKB</varname></primary></indexterm>
				<indexterm><primary><varname>tgeogpointFromEWKB</varname></primary></indexterm>
				<para>Entrar un punto temporal en una representación extendida binaria conocida (EWKB) &Z_support; &geography_support;</para>
				<para><varname>tgeompointFromEWKB(bytea) → tgeompoint</varname></para>
				<para><varname>tgeogpointFromEWKB(bytea) → tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeogpointFromEWKB(
  '\x012f0071a41e0000000000000000f03f00000000000000400000000000000840009c57d3c11c0000'));
-- SRID=7844;POINT Z (1 1 1)@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tgeompointFromHexEWKB">
				<indexterm><primary><varname>tgeompointFromHexEWKB</varname></primary></indexterm>
				<indexterm><primary><varname>tgeogpointFromHexEWKB</varname></primary></indexterm>
				<para>Entrar un punto temporal geométrico en una representación hexadecimal extendida binaria conocida (HexEWKB) &Z_support; &geography_support;</para>
				<para><varname>tgeompointFromHexEWKB(text) → tgeompoint</varname></para>
				<para><varname>tgeogpointFromHexEWKB(text) → tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromHexEWKB(
  '012E0051E40E0000000000000000F03F00000000000000400000000000000840009C57D3C11C0000'));
-- SRID=3812;POINT(1 2 3)@2001-01-01
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="tpoint_spatial_srid">
		<title>Sistema de referencia espacial</title>
		<itemizedlist>
			<listitem id="tpoint_SRID">
				<indexterm><primary><varname>SRID</varname></primary></indexterm>
				<para>Obtener el identificador de referencia espacial &Z_support; &geography_support;</para>
				<para><varname>SRID(tpoint) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT SRID(tgeompoint 'Point(0 0)@2001-01-01');
-- 0
</programlisting>
			</listitem>

			<listitem id="tpoint_setSRID">
				<indexterm><primary><varname>setSRID</varname></primary></indexterm>
				<para>Establecer el identificador de referencia espacial &Z_support; &geography_support;</para>
				<para><varname>setSRID(tpoint) → tpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)', 4326));
-- SRID=4326;[POINT(0 0)@2001-01-01 00:00:00+00, POINT(1 1)@2001-01-02 00:00:00+00)
</programlisting>
				</listitem>

			<listitem id="tpoint_transform">
				<indexterm><primary><varname>transform</varname></primary></indexterm>
				<indexterm><primary><varname>transformPipeline</varname></primary></indexterm>
				<para>Transformar a una referencia espacial diferente &Z_support; &geography_support;</para>
				<para><varname>transform(tpoint,to_srid integer) → tpoint</varname></para>
				<para><varname>transform(tpoint,pipeline text,to_srid integer,is_forward bool=true) → tpoint</varname></para>
				<para>La función <varname>transform</varname> especifica la transformación con un SRID de destino. Se genera un error cuando el punto temporal tiene un SRID desconocido (representado por 0).</para>
				<para>La función <varname>transformPipeline</varname> especifica la transformación con una canalización de transformación de coordenadas definida representada con el siguiente formato de cadena: <varname>urn:ogc:def:coordinateOperation:AUTHORITY::CODE</varname>. El SRID del punto temporal de entrada se ignora y el SRID del punto temporal de salida se establecerá en cero a menos que se proporcione un valor a través del parámetro opcional <varname>to_srid</varname>. Como se indica en el último parámetro, la canalización se ejecuta de forma predeterminada en dirección hacia adelante; al establecer el parámetro en falso, la canalización se ejecuta en la dirección inversa.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2001-01-01', 3812));
-- SRID=3812;POINT(648679.018035303 671067.055638114)@2001-01-01 00:00:00+00
</programlisting>
				<programlisting language="sql" xml:space="preserve">
WITH test(tpoint, pipeline) AS (
  SELECT tgeogpoint 'SRID=4326;{Point(4.3525 50.846667 100.0)@2001-01-01,
    Point(-0.1275 51.507222 100.0)@2001-01-02}',
    text 'urn:ogc:def:coordinateOperation:EPSG::16031' )
SELECT asEWKT(transformPipeline(transformPipeline(tpoint, pipeline, 4326),
  pipeline, 4326, false), 6)
FROM test;
/* SRID=4326;{POINT Z (4.3525 50.846667 100)@2001-01-01,
   POINT Z (-0.1275 51.507222 100)@2001-01-02} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="tpoint_spatial_bbox">
		<title>Operaciones de cuadro delimitador</title>

		<itemizedlist>
			<listitem id="tpoint_expandSpace">
				<indexterm><primary><varname>expandSpace</varname></primary></indexterm>
				<para>Obtener el cuadro delimitador espaciotemporal expandido en la dimensión espacial por un valor flotante &Z_support; &geography_support;</para>
				<para><varname>expandSpace({geo,tpoint},float) → stbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT expandSpace(geography 'Linestring(0 0,1 1)', 2);
-- SRID=4326;GEODSTBOX X((-2,-2),(3,3))
SELECT expandSpace(tgeompoint 'Point(0 0)@2001-01-01', 2);
-- STBOX XT(((-2,-2),(2,2)),[2001-01-01,2001-01-01])
</programlisting>
			</listitem>
	</itemizedlist>
	</sect1>

	<sect1 id="tpoint_spatial_accessors">
		<title>Accessores</title>
		<itemizedlist>
			<listitem id="trajectory">
				<indexterm><primary><varname>trajectory</varname></primary></indexterm>
				<para>Obtenir la trayectoria &Z_support; &geography_support;</para>
				<para><varname>trajectory(tpoint) → geo</varname></para>
				<para>Esta función es equivalente a <link linkend="getValues"><varname>getValues</varname></link> para los valores temporales alphanuméricos</para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(trajectory(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04)}'));
-- MULTILINESTRING((0 0,0 1),(0 1,1 1))
SELECT ST_AsText(trajectory(tgeompoint 'Interp=Step;{[Point(0 0)@2001-01-01,
  Point(0 1)@2001-01-02], [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04]}'));
-- MULTIPOINT((0 0),(0 1),(0 1),(1 1))
SELECT ST_AsText(trajectory(tgeompoint '{Point(0 0)@2001-01-01, Point(0 1)@2001-01-02}'));
-- MULTIPOINT((0 0),(0 1))
SELECT ST_AsText(trajectory(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
  [Point(2 1)@2001-01-05, Point(2 2)@2001-01-06)}'));
-- GEOMETRYCOLLECTION(POINT(1 1),MULTILINESTRING((0 0,0 1),(2 1,2 2)))
</programlisting>
			</listitem>

			<listitem id="getX">
				<indexterm><primary><varname>getX</varname></primary></indexterm>
				<indexterm><primary><varname>getY</varname></primary></indexterm>
				<indexterm><primary><varname>getZ</varname></primary></indexterm>
				<para>Obtener los valores de las coordenadas X/Y/Z como un número flotante temporal &Z_support; &geography_support;</para>
				<para><varname>getX(tpoint) → tfloat</varname></para>
				<para><varname>getY(tpoint) → tfloat</varname></para>
				<para><varname>getZ(tpoint) → tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getX(tgeompoint '{Point(1 2)@2001-01-01, Point(3 4)@2001-01-02,
  Point(5 6)@2001-01-03}');
-- {1@2001-01-01, 3@2001-01-02, 5@2001-01-03}
SELECT getX(tgeogpoint 'Interp=Step;[Point(1 2 3)@2001-01-01, Point(4 5 6)@2001-01-02,
  Point(7 8 9)@2001-01-03]');
-- Interp=Step;[1@2001-01-01, 4@2001-01-02, 7@2001-01-03]
SELECT getY(tgeompoint '{Point(1 2)@2001-01-01, Point(3 4)@2001-01-02,
  Point(5 6)@2001-01-03}');
-- {2@2001-01-01, 4@2001-01-02, 6@2001-01-03}
SELECT getY(tgeogpoint 'Interp=Step;[Point(1 2 3)@2001-01-01, Point(4 5 6)@2001-01-02,
  Point(7 8 9)@2001-01-03]');
-- Interp=Step;[2@2001-01-01, 5@2001-01-02, 8@2001-01-03]
SELECT getZ(tgeompoint '{Point(1 2)@2001-01-01, Point(3 4)@2001-01-02,
  Point(5 6)@2001-01-03}');
-- The temporal point must have Z dimension
SELECT getZ(tgeogpoint 'Interp=Step;[Point(1 2 3)@2001-01-01, Point(4 5 6)@2001-01-02,
  Point(7 8 9)@2001-01-03]');
-- Interp=Step;[3@2001-01-01, 6@2001-01-02, 9@2001-01-03]
</programlisting>
			</listitem>

			<listitem id="isSimple">
				<indexterm><primary><varname>isSimple</varname></primary></indexterm>
				<para>Obtener verdadero si el punto temporal no se auto-intersecta espacialmente &Z_support;</para>
				<para><varname>isSimple(tpoint) → boolean</varname></para>
				<para>Nótese que un punto temporal de conjunto de secuencias es simple si cada una de las secuencias que lo componen es simple.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT isSimple(tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(0 0)@2001-01-03]');
-- false
SELECT isSimple(tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02,
  Point(2 0 2)@2001-01-03, Point(0 0 0)@2001-01-04]');
-- false
SELECT isSimple(tgeompoint '{[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02],
  [Point(1 1 1)@2001-01-03, Point(0 0 0)@2001-01-04]}');
-- true
</programlisting>
			</listitem>

			<listitem id="length">
				<indexterm><primary><varname>length</varname></primary></indexterm>
				<para>Obtener la longitud atravesada por el punto temporal &Z_support; &geography_support;</para>
				<para><varname>length(tpoint) → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT length(tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02]');
-- 1.73205080756888
SELECT length(tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02,
  Point(0 0 0)@2001-01-03]');
-- 3.46410161513775
SELECT length(tgeompoint 'Interp=Step;[Point(0 0 0)@2001-01-01,
  Point(1 1 1)@2001-01-02, Point(0 0 0)@2001-01-03]');
-- 0
</programlisting>
			</listitem>

			<listitem id="cumulativeLength">
				<indexterm><primary><varname>cumulativeLength</varname></primary></indexterm>
				<para>Obtener la longitud acumulada atravesada por el punto temporal &Z_support; &geography_support;</para>
				<para><varname>cumulativeLength(tpoint) → tfloat_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(cumulativeLength(tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(1 0)@2001-01-03], [Point(1 0)@2001-01-04, Point(0 0)@2001-01-05]}'), 6);
-- {[0@2001-01-01, 1.414214@2001-01-02, 2.414214@2001-01-03],
  [2.414214@2001-01-04, 3.414214@2001-01-05]}
SELECT cumulativeLength(tgeompoint 'Interp=Step;[Point(0 0 0)@2001-01-01,
  Point(1 1 1)@2001-01-02, Point(0 0 0)@2001-01-03]');
-- Interp=Step;[0@2001-01-01, 0@2001-01-03]
</programlisting>
			</listitem>

			<listitem id="speed">
				<indexterm><primary><varname>speed</varname></primary></indexterm>
				<para>Obtener la velocidad del punto temporal en unidades por segundo &Z_support; &geography_support;</para>
				<para><varname>speed(tpoint) → tfloat_seqset</varname></para>
				<para>El punto temporal debe tener interpolación linear</para>
				<programlisting language="sql" xml:space="preserve">
SELECT speed(tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(1 0)@2001-01-03], [Point(1 0)@2001-01-04, Point(0 0)@2001-01-05]}') * 3600 * 24;
/* Interp=Step;{[1.4142135623731@2001-01-01, 1@2001-01-02, 1@2001-01-03],
   [1@2001-01-04, 1@2001-01-05]} */
SELECT speed(tgeompoint 'Interp=Step;[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(1 0)@2001-01-03]');
-- ERROR:  The temporal value must have linear interpolation
</programlisting>
			</listitem>

			<listitem id="twCentroid">
				<indexterm><primary><varname>twCentroid</varname></primary></indexterm>
				<para>Obtener el centroide ponderado en el tiempo &Z_support;</para>
				<para><varname>twCentroid(tgeompoint) → point</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2001-01-01,
  Point(0 1 1)@2001-01-02, Point(0 1 1)@2001-01-03, Point(0 0 0)@2001-01-04)}'));
-- POINT Z (0 0.666666666666667 0.666666666666667)
</programlisting>
			</listitem>

			<listitem id="direction">
				<indexterm><primary><varname>direction</varname></primary></indexterm>
				<para>Obtener la dirección, es decir, el acimut entre las ubicaciones inicial y final &Z_support; &geography_support;</para>
				<para><varname>direction(tpoint) → float</varname></para>
				<para>El resultado se expresa en radianes. Es NULL si solo hay una ubicación o si las ubicaciones inicial y final son iguales.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(degrees(direction(tgeompoint '[Point(0 0)@2001-01-01,
  Point(-1 -1)@2001-01-02, Point(1 1)@2001-01-03]'))::numeric, 6);
-- 45.000000
SELECT direction(tgeompoint '{[Point(0 0 0)@2001-01-01,
  Point(0 1 1)@2001-01-02, Point(0 1 1)@2001-01-03, Point(0 0 0)@2001-01-04)}');
-- NULL
</programlisting>
			</listitem>

			<listitem id="azimuth">
				<indexterm><primary><varname>azimuth</varname></primary></indexterm>
				<para>Obtener el acimut temporal &Z_support; &geography_support;</para>
				<para><varname>azimuth(tpoint) → tfloat</varname></para>
				<para>El resultado se expresa en radianes. El azimut es indefinido cuando dos localizaciones sucesivas son iguales y en este caso se añade una brecha de tempo.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(degrees(azimuth(tgeompoint '[Point(0 0 0)@2001-01-01,
  Point(1 1 1)@2001-01-02, Point(1 1 1)@2001-01-03, Point(0 0 0)@2001-01-04)')));
-- Interp=Step;{[45@2001-01-01, 45@2001-01-02], [225@2001-01-03, 225@2001-01-04)}
</programlisting>
			</listitem>

			<listitem id="angularDifference">
				<indexterm><primary><varname>angularDifference</varname></primary></indexterm>
				<para>Obtener la diferencia angular temporal &geography_support;</para>
				<para><varname>angularDifference(tpoint) → tfloat</varname></para>
				<para>El resultado se expresa en grados.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(angularDifference(tgeompoint '[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03]'), 3);
-- {0@2001-01-01, 180@2001-01-02, 0@2001-01-03}
SELECT round(degrees(angularDifference(tgeompoint '{[Point(1 1)@2001-01-01,
  Point(2 2)@2001-01-02], [Point(2 2)@2001-01-03, Point(1 1)@2001-01-04]}')), 3);
-- {0@2001-01-01, 0@2001-01-02, 0@2001-01-03, 0@2001-01-04}
</programlisting>
			</listitem>

			<listitem id="bearing">
				<indexterm><primary><varname>bearing</varname></primary></indexterm>
				<para>Obtener el rumbo temporal &Z_support; &geography_support;</para>
				<para><varname>bearing({tpoint, point}, {tpoint, point}) → tfloat</varname></para>
				<para>Nótese que esta función no acepta dos puntos geográficos temporales.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT degrees(bearing(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]',
  geometry 'Point(2 2)'));
-- [45@2001-01-01, 0@2001-01-02, 225@2001-01-03]
SELECT round(degrees(bearing(tgeompoint '[Point(0 0)@2001-01-01, Point(2 0)@2001-01-03]',
  tgeompoint '[Point(2 1)@2001-01-01, Point(0 1)@2001-01-03]')), 3);
--  [63.435@2001-01-01, 0@2001-01-02, 296.565@2001-01-03]
SELECT round(degrees(bearing(tgeompoint '[Point(2 1)@2001-01-01, Point(0 1)@2001-01-03]',
  tgeompoint '[Point(0 0)@2001-01-01, Point(2 0)@2001-01-03]')), 3);
-- [243.435@2001-01-01, 116.565@2001-01-03]
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="tpoint_spatial_transformatios">
		<title>Transformaciones</title>
		<itemizedlist>
			<listitem id="tpoint_round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Redondear los valores de las coordenadas a un número de decimales &Z_support; &geography_support;</para>
				<para><varname>round(tpoint,integer=0) → tpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(round(tgeompoint '{Point(1.12345 1.12345 1.12345)@2001-01-01,
  Point(2 2 2)@2001-01-02, Point(1.12345 1.12345 1.12345)@2001-01-03}', 2));
/* {POINT Z (1.12 1.12 1.12)@2001-01-01, POINT Z (2 2 2)@2001-01-02,
   POINT Z (1.12 1.12 1.12)@2001-01-03} */
SELECT asText(round(tgeogpoint 'Point(1.12345 1.12345)@2001-01-01', 2));
-- POINT(1.12 1.12)@2001-01-01
</programlisting>
			</listitem>

			<listitem id="makeSimple">
				<indexterm><primary><varname>makeSimple</varname></primary></indexterm>
				<para>Obtener una matriz de fragmentos del punto temporal que son simples &Z_support;</para>
				<para><varname>makeSimple(tpoint) → tgeompoint[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(0 0)@2001-01-03]'));
/* {"[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02)",
   "[POINT(1 1)@2001-01-02, POINT(0 0)@2001-01-03]"} */
SELECT asText(makeSimple(tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02,
  Point(2 0 2)@2001-01-03, Point(0 0 0)@2001-01-04]'));
/* {"[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02, POINT Z (2 0 2)@2001-01-03,
   POINT Z (0 0 0)@2001-01-04]"} */
SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(0 1)@2001-01-03, Point(1 0)@2001-01-04]'));
/* {"[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02, POINT(0 1)@2001-01-03)",
   "[POINT(0 1)@2001-01-03, POINT(1 0)@2001-01-04]"} */
SELECT asText(makeSimple(tgeompoint '{[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02],
  [Point(1 1 1)@2001-01-03, Point(0 0 0)@2001-01-04]}'));
/* {"{[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02],
   [POINT Z (1 1 1)@2001-01-03, POINT Z (0 0 0)@2001-01-04]}"} */
</programlisting>
			</listitem>

			<listitem id="geoMeasure">
				<indexterm><primary><varname>geoMeasure</varname></primary></indexterm>
				<para>Construir una geometría/geografía con medida M a partir de un punto temporal y un número flotante temporal &Z_support; &geography_support;</para>
				<para><varname>geoMeasure(tpoint,tfloat,segmentize=false) → geo</varname></para>
				<para>El último argumento <varname>segmentize</varname> establece si el valor resultado ya sea es un <varname>Linestring M</varname> o un <varname>MultiLinestring M</varname> donde cada componente es un segmento de dos puntos.</para>

				<programlisting language="sql" xml:space="preserve">
SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2001-01-01,
  Point(2 2 2)@2001-01-02}', '{5@2001-01-01, 5@2001-01-02}'));
-- MULTIPOINT ZM (1 1 1 5,2 2 2 5)
SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02],
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04]}',
  '{[5@2001-01-01, 5@2001-01-02],[7@2001-01-03, 7@2001-01-04]}'));
-- GEOMETRYCOLLECTION M (POINT M (1 1 7),LINESTRING M (1 1 5,2 2 5))
SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2001-01-01,
  Point(2 2)@2001-01-02, Point(1 1)@2001-01-03]',
  '[5@2001-01-01, 7@2001-01-02, 5@2001-01-03]', true));
-- MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))
</programlisting>
				<para>Una visualización típica de los datos de movilidad es mostrar en un mapa la trayectoria del objeto móvil utilizando diferentes colores según la velocidad. La <xref linkend="figspeed" /> muestra el resultado de la consulta a continuación usando una rampa de color en QGIS.</para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(t) AS (
  SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-05,
    Point(2 0)@2001-01-08, Point(3 1)@2001-01-10, Point(4 0)@2001-01-11]'
)
SELECT ST_AsText(geoMeasure(t, round(speed(t) * 3600 * 24, 2), true))
FROM Temp;
/* MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),
  (3 1 1.41,4 0 1.41)) */
</programlisting>
				<para>La siguiente expresión se usa en QGIS para lograr esto. La función <varname>scale_linear</varname> transforma el valor M de cada segmento componente al rango [0, 1]. Este valor luego se pasa a la función <varname>ramp_color</varname>.</para>
				<programlisting language="sql" xml:space="preserve">
ramp_color(
  'RdYlBu',
  scale_linear(
    m(start_point(geometry_n($geometry,@geometry_part_num))),
      0, 2, 0, 1)
	)
</programlisting>
				<figure id="figspeed" float="start">
					<title>Visualización de la velocidad de un objeto móvil usando una rampa de color en QGIS.</title>
					<mediaobject>
						<imageobject><imagedata scale='30' fileref='../images/speed.png'/></imageobject>
					</mediaobject>
				</figure>
			</listitem>

			<listitem id="asMVTGeom">
				<indexterm><primary><varname>asMVTGeom</varname></primary></indexterm>
				<para>Transformar un punto geométrico temporal en el espacio de coordenadas de un Mapbox Vector Tile &Z_support;</para>
				<para><varname>asMVTGeom(tpoint,bounds,extent=4096,buffer=256,clip=true) → (geom,times)</varname></para>
				<para>El resultado es un par compuesto de un valor <varname>geometry</varname> y una matriz de valores de marca de tiempo asociados codificados como época de Unix. Los parámetros son los siguientes:</para>
				<itemizedlist>
					<listitem><para><varname>tpoint</varname> es el punto temporal para transformar</para></listitem>
					<listitem><para><varname>bounds</varname> es un <varname>stbox</varname> que define los límites geométricos del contenido del mosaico sin búfer</para></listitem>
					<listitem><para><varname>extent</varname> es la extensión del mosaico en el espacio de coordenadas del mosaico</para></listitem>
					<listitem><para><varname>buffer</varname> es la distancia del búfer en el espacio de coordenadas de mosaico</para></listitem>
					<listitem><para><varname>clip</varname> es un booleano que determina si las geometrías resultantes y las marcas de tiempo deben recortarse o no</para></listitem>
				</itemizedlist>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((mvt).geom), (mvt).times
FROM (SELECT asMVTGeom(tgeompoint '[Point(0 0)@2001-01-01, Point(100 100)@2001-01-02]',
  stbox 'STBOX X((40,40),(60,60))') AS mvt ) AS t;
-- LINESTRING(-256 4352,4352 -256) | {946714680,946734120}
SELECT ST_AsText((mvt).geom), (mvt).times
FROM (SELECT asMVTGeom(tgeompoint '[Point(0 0)@2001-01-01, Point(100 100)@2001-01-02]',
  stbox 'STBOX X((40,40),(60,60))', clip:=false) AS mvt ) AS t;
-- LINESTRING(-8192 12288,12288 -8192) | {946681200,946767600}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="tpoint_spatial_distance">
		<title>Operaciones de distancia</title>

		<itemizedlist>
			<listitem id="smallest_distance">
				<indexterm><primary><varname>|=|</varname></primary></indexterm>
				<para>Obtener la distancia más pequeña que haya existido &Z_support; &geography_support;</para>
				<para><varname>{geo,tpoint} |=| {geo,tpoint} → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[Point(0 0)@2001-01-02, Point(1 1)@2001-01-04, Point(0 0)@2001-01-06)'
  |=| geometry 'Linestring(2 2,2 1,3 1)';
-- 1
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03, Point(0 0)@2001-01-05)'
  |=| tgeompoint '[Point(2 0)@2001-01-02, Point(1 1)@2001-01-04, Point(2 2)@2001-01-06)';
-- 0.5
SELECT tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
  Point(0 0 0)@2001-01-05)' |=| tgeompoint '[Point(2 0 0)@2001-01-02,
  Point(1 1 1)@2001-01-04, Point(2 2 2)@2001-01-06)';
-- 0.5
SELECT tgeompoint 'Interp=Step;(Point(1 1)@2001-01-01, Point(3 1)@2001-01-03]' |=|
  geometry 'Linestring(1 3,2 2,3 3)';
-- 1.4142135623731
</programlisting>
				<para>El operador <varname>|=|</varname> se puede utilizar para realizar una búsqueda de vecino más cercano utilizando un índice GiST o SP-GIST (ver la <xref linkend="temporal_types_indexing" />). Esta función corresponde a la función <varname>ST_DistanceCPA</varname> proporcionada por PostGIS, aunque este última requiere que ambos argumentos sean una trayectoria.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_DistanceCPA(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'::geometry);
-- 0.5
</programlisting>
			</listitem>

			<listitem id="nearestApproachInstant">
				<indexterm><primary><varname>nearestApproachInstant</varname></primary></indexterm>
				<para>Obtener el instante del primer punto temporal en el que los dos argumentos están a la distancia más cercana &Z_support; &geography_support;</para>
				<para><varname>nearestApproachInstant({geo,tpoint},{geo,tpoint}) → tpoint</varname></para>
				<para>La función sólo devuelve el primer instante que encuentre si hay más de uno. El instante resultante puede tener un límite exclusivo.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2001-01-01,
  Point(3 1)@2001-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- POINT(2 1)@2001-01-02
SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Step;(Point(1 1)@2001-01-01,
  Point(3 1)@2001-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- POINT(1 1)@2001-01-01
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2001-01-01,
  Point(2 2)@2001-01-03]', tgeompoint '(Point(1 1)@2001-01-01, Point(4 1)@2001-01-03]'));
-- POINT(1 1)@2001-01-01
SELECT asText(nearestApproachInstant(tgeompoint '[Point(0 0 0)@2001-01-01,
  Point(1 1 1)@2001-01-03, Point(0 0 0)@2001-01-05)', tgeompoint
  '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04, Point(2 2 2)@2001-01-06)'));
-- POINT Z (0.75 0.75 0.75)@2001-01-03 12:00:00+00
</programlisting>
				<para>La función <varname>nearestApproachInstant</varname> generaliza the la función PostGIS <varname>ST_ClosestPointOfApproach</varname>. Primero, la última función requiere que ambos argumentos sean trayectorias. Segundo, la función <varname>nearestApproachInstant</varname> devuelve tanto el punto como la marca de tiempo del punto de aproximación más cercano, mientras que la función PostGIS sólo proporciona la marca de tiempo como se muestra a continuación.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT to_timestamp(ST_ClosestPointOfApproach(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'::geometry));
-- 2001-01-03 12:00:00+00
</programlisting>
			</listitem>

			<listitem id="shortestLine">
				<indexterm><primary><varname>shortestLine</varname></primary></indexterm>
				<para>Obtener la línea que conecta el punto de aproximación más cercano &Z_support; &geography_support;</para>
				<para><varname>shortestLine({geo,tpoint},{geo,tpoint}) → geo</varname></para>
				<para>La función sólo devolverá la primera línea que encuentre si hay más de una.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2001-01-01,
  Point(3 1)@2001-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- LINESTRING(2 1,2 2)
SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Step;(Point(1 1)@2001-01-01,
  Point(3 1)@2001-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- LINESTRING(1 1,2 2)
SELECT ST_AsText(shortestLine(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)',
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'));
-- LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)
</programlisting>
				<para>La función <varname>shortestLine</varname> se puede utilizar para obtener el resultado proporcionado por la función PostGIS <varname>ST_CPAWithin</varname> cuando ambos argumentos son trayectorias como se muestra a continuación.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_Length(shortestLine(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)',
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)')) &lt;= 0.5;
-- true
SELECT ST_CPAWithin(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'::geometry, 0.5);
-- true
</programlisting>
			</listitem>
		</itemizedlist>

		<para>El operador de distancia temporal, denotado <varname>&lt;-&gt;</varname>, calcula la distancia en cada instante de la intersección de las extensiones temporales de sus argumentos y da como resultado un número flotante temporal. Calcular la distancia temporal es útil en muchas aplicaciones de movilidad. Por ejemplo, un grupo en movimiento (también conocido como convoy o bandada) se define como un conjunto de objetos que se mueven cerca unos de otros durante un intervalo de tiempo prolongado. Esto requiere calcular la distancia temporal entre dos objetos en movimiento.</para>

		<para>El operador de distancia temporal acepta una geometría/geografía restringida a un punto o un punto temporal como argumentos. Observe que los tipos temporales sólo consideran la interpolación lineal entre valores, mientras que la distancia es una raíz de una función cuadrática. Por lo tanto, el operador de distancia temporal proporciona una aproximación lineal del valor de distancia real para los puntos de secuencia temporal. En este caso, los argumentos se sincronizan en la dimensión de tiempo y para cada uno de los segmentos de línea que componen los argumentos, se calcula la distancia espacial entre el punto inicial, el punto final y el punto de aproximación más cercano, como se muestra en los ejemplos a continuación.</para>

		<itemizedlist>
			<listitem id="distance">
				<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
				<para>Obtener la distancia temporal &Z_support; &geography_support;</para>
				<para><varname>{point,tpoint} &lt;-&gt; {point,tpoint} → tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03)' &lt;-&gt;
  geometry 'Point(0 1)';
-- [1@2001-01-01, 0.707106781186548@2001-01-02, 1@2001-01-03)
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03)' &lt;-&gt;
  tgeompoint '[Point(0 1)@2001-01-01, Point(1 0)@2001-01-03)';
-- [1@2001-01-01, 0@2001-01-02, 1@2001-01-03)
SELECT tgeompoint '[Point(0 1)@2001-01-01, Point(0 0)@2001-01-03)' &lt;-&gt;
  tgeompoint '[Point(0 0)@2001-01-01, Point(1 0)@2001-01-03)';
-- [1@2001-01-01, 0.707106781186548@2001-01-02, 1@2001-01-03)
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)' &lt;-&gt;
  tgeompoint '[Point(0 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- [1@2001-01-01,1@2001-01-02)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="tpoint_spatial_rel">
		<title>Relaciones espaciales</title>

		<para>Las relaciones topológicas como <varname>ST_Intersects</varname> y las relaciones de distancia como <varname>ST_DWithin</varname> pueden ser generalizadas a los puntos temporales. Los argumentos de estas funciones generalizadas son un punto temporal y un tipo base (es decir, un <varname>geometry</varname> o un <varname>geography</varname>) o dos puntos temporales. Además, ambos argumentos deben ser del mismo tipo base, es decir, estas funciones no permiten merzclar un punto de geometría temporal (o una geometría) y un punto de geografía temporal (o una geografía).</para>

		<para>Hay tres versiones de las relaciones espaciales:</para>
		<itemizedlist>
			<listitem>
				<para>Las relaciones <emphasis>alguna vez</emphasis> determinan determinan si la relación topológica o de distancia se satisface alguna vez (ver <xref linkend="ever_always_comparison" />) y resultan en un <varname>boolean</varname>. Ejemplos son las funciones <varname>eIntersects</varname> y <varname>eDwithin</varname>.</para>
			</listitem>

			<listitem>
				<para>Las relaciones <emphasis>siempre</emphasis> determinan determinan si la relación topológica o de distancia se satisface siempre (ver <xref linkend="ever_always_comparison" />) y resultan en un <varname>boolean</varname>. Ejemplos son las funciones <varname>aIntersects</varname> y <varname>aDwithin</varname>.</para>
			</listitem>

			<listitem>
				<para>Las relaciones <emphasis>temporales</emphasis> calculan la función topológica o de distancia en cada instante y dan como resultado un <varname>tbool</varname>. Ejemplos son las funciones <varname>tIntersects</varname> y <varname>tDwithin</varname>.</para>
			</listitem>
		</itemizedlist>

		<para>
			Por ejemplo, la siguiente consulta
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT eIntersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(0 2)@2001-01-01, Point(4 2)@2001-01-05)');
-- t
</programlisting>
		<para>
			determina si el punto temporal se cruza alguna vez con la geometría. En este caso, la consulta es equivalente a la siguiente
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT ST_Intersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  geometry 'Linestring(0 2,4 2)');
</programlisting>
		<para>
			donde la segunda geometría se obtiene aplicando la función <varname>trajectory</varname> al punto temporal. Por otro lado, la consulta
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tIntersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(0 2)@2001-01-01, Point(4 2)@2001-01-05)');
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-04], (f@2001-01-04, f@2001-01-05)}
</programlisting>
		<para>
			calcula en cada instante si el punto temporal se cruza con la geometría. Del mismo modo, la siguiente consulta
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT eDwithin(tgeompoint '[Point(3 1)@2001-01-01, Point(5 1)@2001-01-03)',
  tgeompoint '[Point(3 1)@2001-01-01, Point(1 1)@2001-01-03)', 2);
-- t
</programlisting>
		<para>
			determina si la distancia entre los puntos temporales es alguna vez menor o igual a 2, mientras que la siguiente consulta
			</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tDwithin(tgeompoint '[Point(3 1)@2001-01-01, Point(5 1)@2001-01-03)',
  tgeompoint '[Point(3 1)@2001-01-01, Point(1 1)@2001-01-03)', 2);
-- {[t@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
</programlisting>
		<para>
			calcula en cada instante si la distancia entre los puntos temporales es menor o igual a 2.
		</para>

		<para>
			Las relaciones alguna vez o siempre se utilizan normalmente en combinación con un índice espacio-temporal al calcular las relaciones temporales. Por ejemplo, la siguiente consulta
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT T.TripId, R.RegionId, tIntersects(T.Trip, R.Geom)
FROM Trips T, Regions R
WHERE eIntersects(T.Trip, R.Geom)
</programlisting>
		<para>
			que verifica si un viaje <varname>T</varname> (que es un punto temporal) se cruza con una región <varname>R</varname> (que es una geometría) beneficiará de un índice espacio-temporal en la columna <varname>T.Trip</varname> dado que la función <varname>intersects</varname> realiza automáticamente la comparación del cuadro delimitador <varname>T.Trip &amp;&amp; R.Geom</varname>. Esto se explica más adelante en este documento.
		</para>

		<para>No todas las relaciones espaciales disponibles en PostGIS tienen una generalización significativa para los puntos temporales. Se define una versión generalizada de las siguientes relaciones para los puntos geométricos temporales: <varname>eIntersects</varname>, <varname>eDisjoint</varname>, <varname>eDwithin</varname>, <varname>eContains</varname>, y <varname>eTouches</varname>, mientras que para los puntos geográficos temporales solo se definen las tres primeras. Además, no todas las combinaciones de parámetros son significativas para una función generalizada dada. Por ejemplo, mientras que <varname>tContains(geometry,tpoint)</varname> es significativo, <varname>tContains(tpoint,geometry)</varname> es significativo solo cuando la geometría es un solo punto, y <varname>tContains(tpoint,tpoint)</varname> es equivalente a <varname>tIntersects(tpoint, geometry)</varname>. Por esta razón, solo se define la primera combinación de parámetros para <varname>eContains</varname>, <varname>aContains</varname> y <varname>tContains</varname>.</para>

		<para>Finalmente, cabe destacar que las relaciónes temporales permiten mezclar geometrías 2D/3D pero en ese caso, el cálculo sólo se realiza en 2D.</para>

		<sect2>
			<title>Relaciones espaciales alguna vez o siempre</title>
			<para>Presentamos a continuación las relaciones espaciales alguna vez o siempre. Estas relaciones incluyen automáticamente una comparación de cuadro delimitador que hace uso de cualquier índice espacial que esté disponible en los argumentos.</para>

			<itemizedlist>
				<listitem id="eContains">
					<indexterm><primary><varname>eContains</varname></primary></indexterm>
					<indexterm><primary><varname>aContains</varname></primary></indexterm>
					<para>Contiene alguna vez</para>
					<para><varname>eContains(geo,tgeompoint) → boolean</varname></para>
					<para><varname>aContains(geo,tgeompoint) → boolean</varname></para>
					<para>Esta función devuelve verdadero si el punto temporal está alguna vez en el interior de la geometría. Recuerde que una geometría no contiene cosas en su borde y, por lo tanto, los polígonos y las líneas no contienen líneas y puntos que se encuentran en su borde. Consulte la documentación de la función <ulink url="https://postgis.net/docs/ST_Contains.html">ST_Contains</ulink> en PostGIS.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT eContains(geometry 'Linestring(1 1,3 3)',
  tgeompoint '[Point(4 2)@2001-01-01, Point(2 4)@2001-01-02]');
-- false
SELECT eContains(geometry 'Linestring(1 1,3 3,1 1)',
  tgeompoint '[Point(4 2)@2001-01-01, Point(2 4)@2001-01-03]');
-- true
SELECT eContains(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
 tgeompoint '[Point(0 1)@2001-01-01, Point(4 1)@2001-01-02]');
-- false
SELECT eContains(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(1 4)@2001-01-01, Point(4 1)@2001-01-04]');
-- true
</programlisting>
				</listitem>

				<listitem id="eDisjoint">
					<indexterm><primary><varname>eDisjoint</varname></primary></indexterm>
					<indexterm><primary><varname>aDisjoint</varname></primary></indexterm>
					<para>Está disjunto alguna vez &Z_support; &geography_support;</para>
					<para><varname>eDisjoint({geo,tgeompoint},{geo,tgeompoint}) → boolean</varname></para>
					<para><varname>aDisjoint({geo,tgeompoint},{geo,tgeompoint}) → boolean</varname></para>
						<programlisting language="sql" xml:space="preserve">
SELECT eDisjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03)');
-- false
SELECT eDisjoint(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2001-01-01, Point(1 1 0)@2001-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="eDwithin">
					<indexterm><primary><varname>eDwithin</varname></primary></indexterm>
					<indexterm><primary><varname>aDwithin</varname></primary></indexterm>
					<para>Está alguna vez a distancia de &Z_support; &geography_support;</para>
					<para><varname>eDwithin({geo,tpoint},{geo,tpoint},float) → boolean</varname></para>
					<para><varname>aDwithin({geo,tpoint},{geo,tpoint},float) → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT eDwithin(geometry 'Point(1 1 1)',
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 0)@2001-01-02]', 1);
-- true
SELECT eDwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 2 2)@2001-01-01,Point(2 2 2)@2001-01-02]', 1);
-- false
</programlisting>
				</listitem>

				<listitem id="eIntersects">
					<indexterm><primary><varname>eIntersects</varname></primary></indexterm>
					<indexterm><primary><varname>aIntersects</varname></primary></indexterm>
					<para>Intersecta alguna vez &Z_support; &geography_support;</para>
					<para><varname>eIntersects({geo,tpoint},{geo,tpoint}) → boolean</varname></para>
					<para><varname>aIntersects({geo,tpoint},{geo,tpoint}) → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT eIntersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2001-01-01, Point(1 1 1)@2001-01-03)');
-- false
SELECT eIntersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2001-01-01, Point(1 1 1)@2001-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="eTouches">
					<indexterm><primary><varname>eTouches</varname></primary></indexterm>
					<indexterm><primary><varname>aTouches</varname></primary></indexterm>
					<para>Toca alguna vez</para>
						<para><varname>eTouches({geo,tgeompoint},{geo,tgeompoint}) → boolean</varname></para>
						<para><varname>aTouches({geo,tgeompoint},{geo,tgeompoint}) → boolean</varname></para>
						<programlisting language="sql" xml:space="preserve">
SELECT eTouches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-03)');
-- true
</programlisting>
			</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Relaciones espaciales temporales</title>

			<para>Presentamos a continuación las relaciones espaciales temporales. Un requisito común con respecto ellas es restringir el resultado de la relación a los instantes en que el valor del resultado es verdadero o falso. Por ejemplo, la siguiente consulta calcula para cada viaje el tiempo dedicado viajando en el municipio de Bruselas.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT TripId, duration(atValue(tIntersects(T.trip, M.geom), True))
FROM Trips T, Municipality M
WHERE M.Name = "Brussels" AND atValue(tIntersects(T.trip, M.geom), True) IS NOT NULL;
</programlisting>
			<para>Para simplificar la escritura de consultas, las relaciones espaciales temporales tienen un último parámetro opcional, que si se proporciona aplica la función <varname>atValue</varname> (ver <xref linkend="temporal_types_restrictions" />) al resultado de la relación. De esta forma, la consulta anterior se puede escribir de la siguiente manera.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT TripId, duration(tIntersects(T.trip, M.geom, True))
FROM Trips T, Municipality M
WHERE M.Name = "Brussels" AND tIntersects(T.trip, M.geom, True) IS NOT NULL;
</programlisting>

			<itemizedlist>
				<listitem id="tContains">
					<indexterm><primary><varname>tContains</varname></primary></indexterm>
					<para>Contiene temporal</para>
					<para><varname>tContains(geometry,tgeompoint,atValue boolean=NULL) → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tContains(geometry 'Linestring(1 1,3 3)',
  tgeompoint '[Point(4 2)@2001-01-01, Point(2 4)@2001-01-02]');
-- {[f@2001-01-01, f@2001-01-02]}
SELECT tContains(geometry 'Linestring(1 1,3 3,1 1)',
  tgeompoint '[Point(4 2)@2001-01-01, Point(2 4)@2001-01-03]');
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03]}
SELECT tContains(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(0 1)@2001-01-01, Point(4 1)@2001-01-02]');
-- {[f@2001-01-01, f@2001-01-02]}
SELECT tContains(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(1 4)@2001-01-01, Point(4 1)@2001-01-04]');
-- {[f@2001-01-01, f@2001-01-02], (t@2001-01-02, f@2001-01-03, f@2001-01-04]}
</programlisting>
				</listitem>

				<listitem id="tDisjoint">
					<indexterm><primary><varname>tDisjoint</varname></primary></indexterm>
					<para>Disjunto temporal &Z_support; &geography_support;</para>
					<para><varname>tDisjoint({geo,tpoint},{geo,tpoint},atValue boolean=NULL) → tbool</varname></para>
					<para>La función solo admite 3D o geografías para dos puntos temporales</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tDisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)');
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-03], (t@2001-01-03, t@2001-01-04]}
SELECT tDisjoint(tgeompoint '[Point(0 3)@2001-01-01, Point(3 0)@2001-01-05)',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-05)');
-- {[t@2001-01-01, f@2001-01-03], (t@2001-01-03, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="tDwithin">
					<indexterm><primary><varname>tDwithin</varname></primary></indexterm>
					<para>Está a distancia de temporal &Z_support;</para>
					<para><varname>tDwithin({geompoint,tgeompoint},{geompoint,tgeompoint},float,atValue boolean=NULL)</varname></para>
					<para><varname>  → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tDwithin(geometry 'Point(1 1)',
  tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)', sqrt(2));
--  {[t@2001-01-01, t@2001-01-03)}
SELECT tDwithin(tgeompoint '[Point(1 0)@2001-01-01, Point(1 4)@2001-01-05]',
  tgeompoint 'Interp=Step;[Point(1 2)@2001-01-01, Point(1 3)@2001-01-05]', 1);
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-04], (f@2001-01-04, t@2001-01-05]}
</programlisting>
				</listitem>

				<listitem id="tIntersects">
					<indexterm><primary><varname>tIntersects</varname></primary></indexterm>
					<para>Intersección temporal &Z_support; &geography_support;</para>
					<para><varname>tIntersects({geo,tpoint},{geo,tpoint},atValue boolean=NULL) → tbool</varname></para>
					<para>La función solo admite 3D o geografías para dos puntos temporales</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tIntersects(geometry 'MultiPoint(1 1,2 2)',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)');
/* {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, t@2001-01-03],
   (f@2001-01-03, f@2001-01-04]} */
SELECT tIntersects(tgeompoint '[Point(0 3)@2001-01-01, Point(3 0)@2001-01-05)',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-05)');
-- {[f@2001-01-01, t@2001-01-03], (f@2001-01-03, f@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="tTouches">
					<indexterm><primary><varname>tTouches</varname></primary></indexterm>
					<para>Toca temporal</para>
					<para><varname>tTouches({geo,tgeompoint},{geo,tgeompoint},atValue boolean=NULL) → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tTouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 0)@2001-01-04)');
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}
</programlisting>
				</listitem>
			</itemizedlist>

		</sect2>
	</sect1>
</chapter>

