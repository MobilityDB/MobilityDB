<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="time_span_types">
	<title>Tipos de rango y de tiempo</title>

	<para>
		MobilityDB tiene tres tipos de rango, a saber, <varname>intspan</varname>, <varname>floatspan</varname> y <varname>period</varname>, para representar, respectivamente, rangos de <varname>integer</varname> , <varname>float</varname> y <varname>timestamptz</varname> (marca de tiempo con zona horaria). Además, MobilityDB tiene dos tipos de tiempo adicionales, a saber, <varname>timestampset</varname> y <varname>periodset</varname>.
	</para>

	<para>
		Los tipos de rango en MobilityDB corresponden a los tipos de rango en PostgreSQL, donde <varname>intspan</varname> y <varname>period</varname> corresponden a <varname>int4range</varname> y <varname>tstzrange</varname>. Sin embargo, los tipos de rango en MobilityDB tienen una implementación más eficiente que los tipos de rango en PostgreSQL. En particular, los tipos de rango en MobilityDB son de longitud fija mientras que los tipos de rango en PostgreSQL son de longitud variable. Además, se permiten rangos vacíos y límites infinitos en valores de rango en PostgreSQL, mientras que esto no está permitido para valores de rango en MobilityDB.
	</para>

	<sect1 id ="functions_operations_time_types">
		<title>Funciones y operadores para tipos de rango y de tiempo</title>

		<para>
			A continuación presentamos las funciones y operadores para tipos de rango y de tiempo. Estas funciones y operadores son polimórficos, es decir, sus argumentos pueden ser de varios tipos y el tipo de resultado puede depender del tipo de los argumentos. Para expresar esto en la firma de los operadores, utilizamos la siguiente notación:
		</para>
		<itemizedlist>
			<listitem>
				<para><varname>span</varname> representa cualquier tipo de rango, es decir, <varname>intspan</varname>, <varname>floatspan</varname> o <varname>period</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>numspan</varname> representa cualquier tipo de rango numérico, es decir, <varname>intspan</varname> o <varname>floatspan</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>element</varname> representa cualquier tipo de base de un tipo de rango, es decir, <varname>integer</varname>, <varname>float</varname>, o <varname>timestamptz</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>number</varname> representa cualquier tipo de base de un tipo de rango numérico, es decir, <varname>integer</varname> o <varname>float</varname>,</para>
			</listitem>
			<listitem>
				<para><varname>time</varname> representa cualquier tipo de tiempo, es decir, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname> o <varname>periodset</varname>,</para>
			</listitem>
			<listitem>
				<para>Un conjunto de tipos como <varname>{period,timestampset,periodset}</varname> representa cualquiera de los tipos enumerados,</para>
			</listitem>
			<listitem>
				<para><varname>type[]</varname> representa una matriz de <varname>type</varname>.</para>
			</listitem>
		</itemizedlist>

		<para>
			Como ejemplo, la firma del operador contiene (<varname>@&gt;</varname>) es como sigue:
		</para>
		<programlisting language="sql" xml:space="preserve">
{timestampset,period,periodset} @&gt; time
</programlisting>
		<para>
			A continuación, por concisión, la parte de tiempo de las marcas de tiempo se omite en los ejemplos. Recuerde que en ese caso PostgreSQL asume el tiempo <varname>00:00:00</varname>.
		</para>

		<sect2>
			<title>Funciones de entrada/salida</title>
			<para>
				MobilityDB generaliza los formatos de entrada/salida Well-Known Text (WKT) y Well-Known Binary (WKB) del Open Geospatial Consortium para todos los tipos temporales. De esta forma, las aplicaciones pueden intercambiar datos entre ellas utilizando un formato de intercambio estandarizado. El formato WKT es legible por humanos, mientras que el formato WKB es más compacto y más eficiente que el formato WKT. El formato WKB se puede generar como una cadena binaria o como una cadena de caracteres codificada en ASCII hexadecimal.
			</para>

			<para>
				Un valor de un tipo de rango tiene dos límites, el <emphasis>límite inferior</emphasis> y el <emphasis>límite superior</emphasis>, que son valores del <emphasis>tipo de base</emphasis> subyacente. Por ejemplo, un valor del tipo <varname>period</varname> tiene dos límites, que son valores de <varname>timestamptz</varname>. Los límites pueden ser inclusivos o exclusivos. Un límite inclusivo significa que el instante límite está incluido en el rango, mientras que un límite exclusivo significa que el instante límite no está incluido en el rango. En el formato textual de un valor de un rango, los límites inferiores inclusivos y exclusivos están representados, respectivamente, por &ldquo;<varname>[</varname>&rdquo; y &ldquo;<varname>(</varname>&rdquo;. Asimismo, los límites superiores inclusivos y exclusivos se representan, respectivamente, por &ldquo;<varname>]</varname>&rdquo; y &ldquo;<varname>)</varname>&rdquo;. En un valor de un rango, el límite inferior debe ser menor o igual que el límite superior. Un valor de rango con límites iguales e inclusivos se llama <emphasis>rango instantáneo</emphasis> y corresponde a un valor del tipo de base. Ejemplos de valores de rango son como sigue:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)';
SELECT floatspan '[1.5, 3.5]';
SELECT period '[2001-01-01 08:00:00, 2001-01-03 09:30:00)';
-- Rangos instantáneos
SELECT intspan '[1, 1]';
SELECT floatspan '[1.5, 1.5]';
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:00:00]';
-- Rango erróneo: límites inválidos
SELECT period '[2001-01-01 08:10:00, 2001-01-01 08:00:00]';
-- Rango erróneo: rango vacío
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:00:00)';
		</programlisting>

			<para>
				El tipo <varname>timestampset</varname> representa un conjunto de valores <varname>timestamptz</varname> diferentes. Un valor de <varname>timestampset</varname> debe contener al menos un elemento, en cuyo caso corresponde a un valor de <varname>timestamptz</varname>. Los elementos que componen un valor de <varname>timestampset</varname> deben estar ordenados. Ejemplos de valores de <varname>timestampset</varname> son como sigue:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT timestampset '{2001-01-01 08:00:00, 2001-01-03 09:30:00}';
-- Conjunto unitario de marcas de tiempo
SELECT timestampset '{2001-01-01 08:00:00}';
-- Conjunto de marcas de tiempo erróneo: elementos desordenados
SELECT timestampset '{2001-01-01 08:10:00, 2001-01-01 08:00:00}';
-- Conjunto de marcas de tiempo erróneo: elementos duplicados
SELECT timestampset '{2001-01-01 08:00:00, 2001-01-01 08:00:00}';
</programlisting>

			<para>
				Finalmente, el tipo <varname>periodset</varname> representa un conjunto de valores disjuntos de <varname>period</varname>. Un valor de <varname>periodset</varname> debe contener al menos un elemento, en cuyo caso corresponde a un valor de <varname>period</varname>. Los elementos que componen un valor de <varname>periodset</varname> deben estar ordenados. Ejemplos de valores de <varname>periodset</varname> son come sigue:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:20:00, 2001-01-01 08:40:00]}';
-- Conjunto unitario de períodos
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Conjunto de períodos erróneo: elementos desordenados
SELECT periodset '{[2001-01-01 08:20:00, 2001-01-01 08:40:00],
  [2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Conjunto de períodos erróneo: elementos superpuestos
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:05:00, 2001-01-01 08:15:00]}';
</programlisting>

			<para>
				Los valores del tipo <varname>periodset</varname> son convertidos en <emphasis>forma normal</emphasis> de modo que los valores equivalentes tengan representaciones idénticas. Para ello, los valores de períodos consecutivos que son adyacentes se fusionan cuando es posible. Un ejemplo de transformación a forma normal es el siguiente:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00),
  [2001-01-01 08:10:00, 2001-01-01 08:10:00], (2001-01-01 08:10:00, 2001-01-01 08:20:00]}';
-- {[2001-01-01 08:00:00+00,2001-01-01 08:20:00+00]}
</programlisting>

			<para>
				Damos a continuación las funciones de entrada/salida de tipos de rango y de tiempo en formato binario conocido.
			</para>

			<itemizedlist>
				<listitem id="spantime_asBinary">
					<indexterm><primary><varname>asBinary</varname></primary></indexterm>
					<para>Obtener la representación binaria conocida (Well-Known Binary o WKB)</para>
					<para><varname>asBinary({span,timestampset,periodset}): bytea</varname></para>
					<para><varname>asBinary({span,timestampset,periodset},endian text): bytea</varname></para>
					<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asBinary(intspan '[1, 2]');
-- \x010800010100000003000000
SELECT asBinary(intspan '[1, 2]', 'XDR');
-- \x000008010000000100000003
SELECT asBinary(floatspan '[1.5, 2.5)');
-- \x01060001000000000000f83f0000000000000440
SELECT asBinary(period '[2001-01-01, 2001-01-03]');
-- \x010a000300fce0136a58010000bc8f4f92580100
SELECT asBinary(timestampset '{2001-01-01, 2001-01-03}');
-- \x010200000000fce0136a58010000bc8f4f92580100
SELECT asBinary(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}');
-- \x01020000000300fce0136a58010000bc8f4f9258010003001c676da6580100007c3e8bba580100
</programlisting>
				</listitem>

				<listitem id="spantime_asHexWKB">
					<indexterm><primary><varname>asHexWKB</varname></primary></indexterm>
					<para>Obtener la representación hexadecimal binaria conocida (HexWKB) en formato texto</para>
					<para><varname>asHexWKB({span,timestampset,periodset}): text</varname></para>
					<para><varname>asHexWKB({span,timestampset,periodset},endian text): text</varname></para>
					<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza NDR.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asHexWKB(intspan '[1, 2]');
-- 010800010100000003000000
SELECT asHexWKB(intspan '[1, 2]', 'XDR');
-- 000008010000000100000003
SELECT asHexWKB(floatspan '[1.5, 2.5)');
-- 01060001000000000000F83F0000000000000440
SELECT asHexWKB(period '[2001-01-01, 2001-01-03]');
-- 010A000300FCE0136A58010000BC8F4F92580100
SELECT asHexWKB(timestampset '{2001-01-01, 2001-01-03}');
-- 010200000000FCE0136A58010000BC8F4F92580100
SELECT asHexWKB(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}');
-- 01020000000300FCE0136A58010000BC8F4F9258010003001C676DA6580100007C3E8BBA580100
</programlisting>
				</listitem>

				<listitem id="intspanFromBinary">
					<indexterm><primary><varname>intspanFromBinary</varname></primary></indexterm>
					<para>Entrar un rango de enteros en una representación binaria conocida (WKB)</para>
					<para><varname>intspanFromBinary(bytea): intspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanFromBinary('\x010800010100000003000000');
-- [1, 3)
</programlisting>
				</listitem>

				<listitem id="floatspanFromBinary">
					<indexterm><primary><varname>floatspanFromBinary</varname></primary></indexterm>
					<para>Entrar un rango de flotantes en una representación binaria conocida (WKB)</para>
					<para><varname>floatspanFromBinary(bytea): floatspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspanFromBinary('\x01060001000000000000f83f0000000000000440');
-- [1.5, 2.5)
</programlisting>
				</listitem>

				<listitem id="periodFromBinary">
					<indexterm><primary><varname>periodFromBinary</varname></primary></indexterm>
					<para>Entrar un período en una representación binaria conocida (WKB)</para>
					<para><varname>periodFromBinary(bytea): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodFromBinary('\x010a000300fce0136a58010000bc8f4f92580100');
-- [2001-01-01, 2001-01-03]
</programlisting>
				</listitem>

				<listitem id="timestampsetFromBinary">
					<indexterm><primary><varname>timestampsetFromBinary</varname></primary></indexterm>
					<para>Entrar un conjunto de marcas de tiempo en una representación binaria conocida (WKB)</para>
					<para><varname>timestampsetFromBinary(bytea): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampsetFromBinary('\x010200000000fce0136a58010000bc8f4f92580100');
-- {2001-01-01, 2001-01-03}
</programlisting>
				</listitem>

				<listitem id="periodsetFromBinary">
					<indexterm><primary><varname>periodsetFromBinary</varname></primary></indexterm>
					<para>Entrar un conjunto de períodos en una representación binaria conocida (WKB)</para>
					<para><varname>periodsetFromBinary(bytea): periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodsetFromBinary(
  '\x01020000000300fce0136a58010000bc8f4f9258010003001c676da6580100007c3e8bba580100');
-- {[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}
</programlisting>
				</listitem>

				<listitem id="intspanFromHexWKB">
					<indexterm><primary><varname>intspanFromHexWKB</varname></primary></indexterm>
					<para>Entrar un rango de enteros en una representación hexadecimal binaria conocida (HexWKB)</para>
					<para><varname>intspanFromHexWKB(text): intspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanFromHexWKB('010800010100000003000000');
-- [1, 3)
</programlisting>
				</listitem>

				<listitem id="floatspanFromHexWKB">
					<indexterm><primary><varname>floatspanFromHexWKB</varname></primary></indexterm>
					<para>Entrar un rango de flotantes en una representación hexadecimal binaria conocida (HexWKB)</para>
					<para><varname>floatspanFromHexWKB(text): floatspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspanFromHexWKB('01060001000000000000F83F0000000000000440');
-- [1.5, 2.5)
</programlisting>
				</listitem>

				<listitem id="periodFromHexWKB">
					<indexterm><primary><varname>periodFromHexWKB</varname></primary></indexterm>
					<para>Entrar un período en una representación hexadecimal binaria conocida (HexWKB)</para>
					<para><varname>periodFromHexWKB(text): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodFromHexWKB('010A000300FCE0136A58010000BC8F4F92580100');
-- [2001-01-01, 2001-01-03]
</programlisting>
				</listitem>

				<listitem id="timestampsetFromHexWKB">
					<indexterm><primary><varname>timestampsetFromHexWKB</varname></primary></indexterm>
					<para>Entrar un conjunto de marcas de tiempo en una representación hexadecimal binaria conocida (HexWKB)</para>
					<para><varname>timestampsetFromHexWKB(text): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampsetFromHexWKB('010200000000FCE0136A58010000BC8F4F92580100');
-- {2001-01-01, 2001-01-03}
</programlisting>
				</listitem>

				<listitem id="periodsetFromHexWKB">
					<indexterm><primary><varname>periodsetFromHexWKB</varname></primary></indexterm>
					<para>Entrar un conjunto de períodos en una representación hexadecimal binaria conocida (HexWKB)</para>
					<para><varname>periodsetFromHexWKB(text): periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodsetFromHexWKB(
  '01020000000300FCE0136A58010000BC8F4F9258010003001C676DA6580100007C3E8BBA580100');
-- {[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones de constructor</title>

			<para>Los tipos de rango tienen una función constructora que acepta cuatro argumentos, donde los dos últimos son opcionales. Los primeros dos argumentos especifican, respectivamente, el límite inferior y el superior, y los dos últimos argumentos son valores booleanos que indican, respectivamente, si los límites inferior y el superior son inclusivos o no. Se supone que los dos últimos argumentos son verdaderos si no se especifican. Nótese que los intervalos de enteros siempre se transforman en <emphasis>normal form</emphasis>, es decir, con límite inferior inclusivo y límite superior exclusivo.
			</para>
			<itemizedlist>
				<listitem id="period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Constructor para tipos de rango</para>
					<para><varname>intspan(integer,integer,left_inc=true,right_inc=false): intspan</varname></para>
					<para><varname>floatspan(float,float,left_inc=true,right_inc=false): floatspan</varname></para>
					<para><varname>period(timestamptz,timestamptz,left_inc=true,right_inc=false): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
-- Rango de flotantes definido con dos argumentos
SELECT floatspan(20.5, 25);
-- [20.5, 25)
-- Rango de enteros definido con cuatro argumentos
SELECT SELECT intspan (20, 25, false, true);
-- [21, 26)
-- Período definido con cuatro argumentos
SELECT period('2001-01-01 08:00:00', '2001-01-03 09:30:00', false, true);
-- (2001-01-01 08:00:00+01, 2001-01-03 09:30:00+01]
</programlisting>
				</listitem>
			</itemizedlist>

			<para>El tipo <varname>timestampset</varname> tiene una función constructora que acepta un solo argumento que es una matriz de valores de <varname>timestamptz</varname>.
			</para>
			<itemizedlist>
				<listitem id="timestampset">
					<indexterm><primary><varname>timestampset</varname></primary></indexterm>
					<para>Constructor para <varname>timestampset</varname></para>
					<para><varname>timestampset(timestamptz[]): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampset(ARRAY[timestamptz '2001-01-01 08:00:00', '2001-01-03 09:30:00']);
-- {2001-01-01 08:00:00+00, 2001-01-03 09:30:00+00}
</programlisting>
				</listitem>
			</itemizedlist>

			<para>El tipo <varname>periodset</varname> tiene una función constructora que acepta un solo argumento que es una matriz de valores de <varname>period</varname>.
			</para>
			<itemizedlist>
				<listitem id="periodset">
					<indexterm><primary><varname>periodset</varname></primary></indexterm>
					<para>Constructor para <varname>periodset</varname></para>
					<para><varname>periodset(period[]): periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodset(ARRAY[period '[2001-01-01 08:00:00, 2001-01-01 08:10:00]',
-- '[2001-01-01 08:20:00, 2001-01-01 08:40:00]']);
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Conversión de tipos</title>
			<para>Los valores de los tipos de tiempo, los tipos de intervalo de MobilityDB y los tipos de intervalo de PostgreSQL se pueden convertir entre sí utilizando la función <varname>CAST</varname> o utilizando la notación <varname>::</varname>. Sin embargo, como se indicó antes, no se permiten rangos vacíos o rangos con límites infinitos en MobilityDB.
			</para>

			<itemizedlist>
				<listitem id="timestamptz_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convertir un <varname>timestamptz</varname>a otro tipo de tiempo</para>
					<para><varname>timestamptz::timestampset</varname></para>
					<para><varname>timestamptz::period</varname></para>
					<para><varname>timestamptz::periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS timestampset);
-- {2001-01-01 08:00:00+01}
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS period);
-- [2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01]
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS periodset);
-- {[2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01]}
</programlisting>
				</listitem>
				<listitem id="timestampset_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convertir un <varname>timestampset</varname> a un <varname>periodset</varname></para>
					<para><varname>timestampset::periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT CAST(timestampset '{2001-01-01 08:00:00, 2001-01-01 08:15:00,
  2001-01-01 08:25:00}' AS periodset);
/* {[2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01],
   [2001-01-01 08:15:00+01, 2001-01-01 08:15:00+01],
   [2001-01-01 08:25:00+01, 2001-01-01 08:25:00+01]} */
</programlisting>
				</listitem>
				<listitem id="period_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convertir un <varname>period</varname> a otro tipo de tiempo</para>
					<para><varname>period::periodset</varname></para>
					<para><varname>period::tstzrange</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::periodset;
-- {[2001-01-01 08:00:00+01, 2001-01-01 08:30:00+01)}
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::tstzrange;
-- ["2001-01-01 08:00:00+01","2001-01-01 08:30:00+01")
</programlisting>
				</listitem>
				<listitem id="intspan_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convertir un <varname>intspan</varname> en un <varname>int4range</varname></para>
					<para><varname>intspan::int4range</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[10, 20)'::int4range;
-- [10,20)
</programlisting>
				</listitem>
				<listitem id="tstzrange_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convertir un <varname>tstzrange</varname> a un <varname>period</varname></para>
					<para><varname>tstzrange::period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tstzrange '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::period;
-- [2001-01-01 08:00:00+01, 2001-01-01 08:30:00+01)
</programlisting>
				</listitem>
				<listitem id="int4range_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Convertir un <varname>int4range</varname> a un <varname>intspan</varname></para>
					<para><varname>int4range::intspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT int4range '[10, 20)'::intspan;
-- [10,20)
SELECT int4range 'empty'::intspan;
-- ERROR:  Range cannot be empty
SELECT int4range '[10,)'::intspan;
-- ERROR:  Range bounds cannot be infinite
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones de accesor</title>

			<itemizedlist>
				<listitem id="time_memSize">
					<indexterm><primary><varname>memSize</varname></primary></indexterm>
					<para>Obtener el tamaño de la memoria en bytes</para>
					<para><varname>memSize({timestampset,periodset}): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT memSize(timestampset '{2001-01-01, 2001-01-02, 2001-01-03}');
-- 104
SELECT memSize(periodset '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04],
  [2001-01-05, 2001-01-06]}');
-- 136
</programlisting>
				</listitem>

				<listitem id="lower">
					<indexterm><primary><varname>lower</varname></primary></indexterm>
					<para>Obtener el límite inferior</para>
					<para><varname>lower(span): element</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT lower(intspan '[20, 25)');
-- 20
SELECT lower(period '[2011-01-01, 2011-01-05)');
-- 2011-01-01
</programlisting>
				</listitem>

				<listitem id="upper">
					<indexterm><primary><varname>upper</varname></primary></indexterm>
					<para>Obtener el límite superior</para>
					<para><varname>upper(span): element</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT upper(floatspan '[20.5, 25.3)');
-- 25.3
SELECT upper(period '[2011-01-01, 2011-01-05)');
-- 2011-01-05
</programlisting>
				</listitem>

				<listitem id="lower_inc">
					<indexterm><primary><varname>lower_inc</varname></primary></indexterm>
					<para>¿Es el límite inferior inclusivo?</para>
					<para><varname>lower_inc(span): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT lower(intspan '[20, 25)');
-- true
SELECT lower_inc(period '[2011-01-01, 2011-01-05)');
-- true
</programlisting>
				</listitem>

				<listitem id="upper_inc">
					<indexterm><primary><varname>upper_inc</varname></primary></indexterm>
					<para>¿Es el límite superior inclusivo?</para>
					<para><varname>upper_inc(span): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT upper(floatspan '[20.5, 25.3]');
-- true
SELECT upper_inc(period '[2011-01-01, 2011-01-05)');
-- false
</programlisting>
				</listitem>

				<listitem id="time_duration">
					<indexterm><primary><varname>duration</varname></primary></indexterm>
					<para>Obtener el intervalo de tiempo</para>
					<para><varname>duration({period,periodset}): interval</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT duration(period '[2001-01-01, 2001-01-03)');
-- 2 days
SELECT duration(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- 3 days
</programlisting>
				</listitem>

				<listitem id="time_timespan">
					<indexterm><primary><varname>timespan</varname></primary></indexterm>
					<para>Obtener el intervalo de tiempo ignorando las posibles brechas de tiempo</para>
					<para><varname>timespan({timestampset,period,periodset}): interval</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timespan(timestampset '{2001-01-01, 2001-01-03}');
-- 2 days
SELECT timespan(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- 4 days
</programlisting>
				</listitem>

				<listitem id="time_period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Obtener el período en el que se define el conjunto de marcas de tiempo o el conjunto de períodos ignorando las posibles brechas de tiempo</para>
					<para><varname>period({timestampset,periodset}): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}');
-- [2001-01-01, 2001-01-05]
SELECT period(periodset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</programlisting>
				</listitem>

				<listitem id="time_numTimestamps">
					<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
					<para>Obtener el número de marcas de tiempo diferentes</para>
					<para><varname>numTimestamps({timestampset,periodset}): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT numTimestamps(timestampset '{2001-01-01, 2001-01-03, 2001-01-04}');
-- 3
SELECT numTimestamps(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="time_startTimestamp">
					<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
					<para>Obtener la marca de tiempo inicial</para>
					<para><varname>startTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT startTimestamp(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-01
</programlisting>
				</listitem>

				<listitem id="time_endTimestamp">
					<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
					<para>Obtener la marca de tiempo final</para>
					<para><varname>endTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT endTimestamp(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-05
</programlisting>
				</listitem>

				<listitem id="time_timestampN">
					<indexterm><primary><varname>timestampN</varname></primary></indexterm>
					<para>Obtener la enésima marca de tiempo diferente</para>
					<para><varname>timestampN({timestampset,periodset},integer): timestamptz</varname></para>
					<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampN(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}', 3);
-- 2001-01-04
</programlisting>
				</listitem>

				<listitem id="time_timestamps">
					<indexterm><primary><varname>timestamps</varname></primary></indexterm>
					<para>Obtener las marcas de tiempo diferentes</para>
					<para><varname>timestamps({timestampset,periodset}): timestampset</varname></para>
					<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestamps(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- {"2001-01-01", "2001-01-03", "2001-01-05"}
</programlisting>
				</listitem>

				<listitem id="numPeriods">
					<indexterm><primary><varname>numPeriods</varname></primary></indexterm>
					<para>Obtener el número de períodos</para>
					<para><varname>numPeriods(periodset): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT numPeriods(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="startPeriod">
					<indexterm><primary><varname>startPeriod</varname></primary></indexterm>
					<para>Obtener el período inicial</para>
					<para><varname>startPeriod(periodset): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT startPeriod(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- [2001-01-01,2001-01-03)
</programlisting>
				</listitem>

				<listitem id="endPeriod">
					<indexterm><primary><varname>endPeriod</varname></primary></indexterm>
					<para>Obtener el período final</para>
					<para><varname>endPeriod(periodset): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT endPeriod(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- [2001-01-05,2001-01-06)
</programlisting>
				</listitem>

				<listitem id="periodN">
					<indexterm><primary><varname>periodN</varname></primary></indexterm>
					<para>Obtener el enésimo período</para>
					<para><varname>periodN(periodset,integer): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodN(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}', 2);
-- [2001-01-04,2001-01-04]
</programlisting>
				</listitem>

				<listitem id="periods">
					<indexterm><primary><varname>periods</varname></primary></indexterm>
					<para>Obtener los períodos</para>
					<para><varname>periods(periodset): period[]</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periods(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- {"[2001-01-01,2001-01-03)", "[2001-01-04,2001-01-04]", "[2001-01-05,2001-01-06)"}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id ="modification_time_tyes">
			<title>Funciones de modificación</title>

			<itemizedlist>
				<listitem id="time_shift">
					<indexterm><primary><varname>shift</varname></primary></indexterm>
					<para>Desplazar el valor de tiempo con un intervalo</para>
					<para><varname>shift({timestampset,period,periodset}): {timestampset,period,periodset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);
-- {2001-01-02, 2001-01-04, 2001-01-06}
SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);
-- [2001-01-02, 2001-01-04]
SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day'::interval);
-- {[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}
</programlisting>
				</listitem>

			<listitem id="time_tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Escalear el valor de tiempo con un intervalo. Si el lapso de tiempo del valor de tiempo es cero (por ejemplo, para un conjunto de marcas de tiempo único), el resultado es el valor de tiempo. El intervalo dado debe ser estrictamente mayor que cero.</para>
				<para><varname>tscale({timestampset,period,periodset},interval): {timestampset,period,periodset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tscale(timestampset '{2001-01-01}', '1 day');
-- {2001-01-01}
SELECT tscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '2 days');
-- {2001-01-01, 2001-01-02, 2001-01-03}
SELECT tscale(period '[2001-01-01, 2001-01-03]', '1 day');
-- [2001-01-01, 2001-01-02]
SELECT tscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}', '1 day');
-- {[2001-01-01 00:00:00, 2001-01-01 12:00:00],
  [2001-01-01 18:00:00, 2001-01-02 00:00:00]}
SELECT tscale(timestampset '{2001-01-01}', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem id="time_shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Desplazar y escalear el valor de tiempo con los dos intervalos. Esta función combina en un solo paso las funciones <link linkend="time_shift"><varname>shift</varname></link> y <link linkend="time_tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale({timestampset,period,periodset},interval,interval):</varname></para>
				<para><varname>  {timestampset,period,periodset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shiftTscale(timestampset '{2001-01-01}', '1 day', '1 day');
-- {2001-01-02}
SELECT shiftTscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day','2 days');
-- {2001-01-02, 2001-01-03, 2001-01-04}
SELECT shiftTscale(period '[2001-01-01, 2001-01-03]', '1 day', '1 day');
-- [2001-01-02, 2001-01-03]
SELECT shiftTscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day', '1 day');
/* {[2001-01-02 00:00:00, 2001-01-02 12:00:00],
   [2001-01-02 18:00:00, 2001-01-03 00:00:00]} */
</programlisting>
			</listitem>

				<listitem id="floatspan_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Redondear los límites de un rango flotante a un número de decimales</para>
					<para><varname>round(floatspan,integer): floatspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT round(floatspan '[1.123456789,2.123456789)', 3);
-- [1.123,2.123)
SELECT round(floatspan '[1.123456789, inf)', 3);
-- [1.123,Infinity)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_comp_operators">
			<title>Operadores de comparación</title>

			<para>Los operadores de comparación (<varname>=</varname>, <varname>&lt;</varname>, etc.) requieren que los argumentos izquierdo y derecho sean del mismo tipo. Exceptuando la igualdad y la no igualdad, los otros operadores de comparación no son útiles en el mundo real, pero permiten construir índices de árbol B en tipos de rango o de tiempo. Para los valores de rango, los operadores comparan primero el límite inferior y luego el límite superior. Para los valores de conjunto de marcas de tiempo y conjunto de períodos, los operadores comparan primero los períodos delimitadores y, si son iguales, comparan los primeros N instantes o períodos, donde N es el mínimo del número de instantes o períodos que componen ambos valores.</para>

			<para>Los operadores de comparación disponibles para los tipos de rango y de tiempo se dan a continuación. Recuerde que los rangos de enteros siempre se representan por su forma canónica.</para>

			<itemizedlist>
				<listitem id="time_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>¿Son iguales los valores?</para>
					<para><varname>{numspan,time} = {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1,3]' = intspan '[1,4)';
-- true
SELECT period '[2001-01-01, 2001-01-04)' = period '[2001-01-01, 2001-01-04)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>¿Son diferentes los valores?</para>
					<para><varname>{numspan,time} &lt;&gt; {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2001-01-01, 2001-01-04)' &lt;&gt; period '[2001-01-03, 2001-01-05)';
-- true
SELECT timestampset '{2001-01-01, 2001-01-04}' &lt;&gt; timestampset '{2001-01-01, 2001-01-05}';
-- false
</programlisting>
				</listitem>

				<listitem id="time_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>¿Es el primer valor menor que el segundo?</para>
					<para><varname>{numspan,time} &lt; {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[3, 4]' &lt; floatspan '(3, 4]';
-- true
SELECT period '[2001-01-01, 2001-01-04)' &lt; period '[2001-01-01, 2001-01-04]';
-- true
SELECT timestampset '{2001-01-01, 2001-01-04}' &lt; timestampset '{2001-01-01, 2001-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>¿Es el primer valor mayor que el segundo?</para>
					<para><varname>{numspan,time}&gt; {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[3, 4]' &gt; floatspan '[3, 4)';
-- true
SELECT period '[2001-01-03, 2001-01-04)' &gt; period '[2001-01-02, 2001-01-05)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>¿Es el primer valor menor o igual que el segundo?</para>
					<para><varname>{numspan,time} &lt;= {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodset '{[2001-01-01, 2001-01-04)}' &lt;=
  periodset '{[2001-01-01, 2001-01-05), [2001-01-06, 2001-01-07)}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>¿Es el primer valor mayor o igual que el segundo?</para>
					<para><varname>{numspan,time} &gt;= {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2001-01-03, 2001-01-05)' &gt;= period '[2001-01-03, 2001-01-04)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_set_operators">
			<title>Operadores de conjuntos</title>

			<para>Los tipos de rango y de tiempo tienen operadores de conjuntos asociados, a saber, unión, diferencia e intersección, que se representan, respectivamente, por <varname>+</varname>, <varname>-</varname> y <varname>* </varname>. Estos operadores se comportan de manera diferente con los rangos numéricos, es decir, <varname>intspan</varname> y <varname>floatspan</varname>, y con el tipo <varname>period</varname>, ya que los períodos no contiguos se pueden representar mediante el tipo <varname>periodset</varname>, mientras que los rango numéricos no contiguos no se pueden representar. Por lo tanto, cuando un operador de unión o diferencia en un rango numérico produce un rango no contiguo, se genera un error, lo que no ocurre con los períodos. Los operadores de conjunto para los tipos de rango y tiempo se dan a continuación.</para>

			<itemizedlist>
				<listitem id="time_union">
					<indexterm><primary><varname>+</varname></primary></indexterm>
					<para>Unión de valores de rango o de tiempo</para>
					<para><varname>numspan + numspan: numspan</varname></para>
					<para><varname>time + time: time</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)' + intspan '[3, 5)';
-- [1, 5)
SELECT floatspan '[1, 3)' + floatspan '[4, 5)';
-- ERROR: The union of the two spans would not be contiguous
SELECT period '[2011-01-01, 2011-01-03)' + period '[2011-01-04, 2011-01-05)';
-- {[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}
SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +
  timestampset '{2011-01-03, 2011-01-06}';
-- {2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}
SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +
  period '[2011-01-03, 2011-01-04)';
-- {[2011-01-01, 2011-01-05)}
</programlisting>
				</listitem>

				<listitem id="time_difference">
					<indexterm><primary><varname>-</varname></primary></indexterm>
					<para>Diferencia de valores de rango o de tiempo</para>
					<para><varname>numspan - numspan: numspan</varname></para>
					<para><varname>time - time: time</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 5]' - intspan '[3, 6]';
-- [1, 3)
SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';
-- [2011-01-01, 2011-01-03)
SELECT floatspan '[1, 5]' - floatspan '[3, 4]';
-- ERROR:  result of span difference would not be contiguous
SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'
-- {[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}
SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -
  periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05],
  [2011-01-08, 2011-01-09]}';
/* {[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],
   [2011-01-07,2011-01-08), (2011-01-09,2011-01-10]} */
</programlisting>
				</listitem>

				<listitem id="time_intersection">
					<indexterm><primary><varname>*</varname></primary></indexterm>
					<para>Intersección de valores de rango o de tiempo</para>
					<para><varname>numspan * numspan: numspan</varname></para>
					<para><varname>time * time: time</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 5)' * intspan '[3, 6)';
-- [3, 5)
SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';
-- {2011-01-03}
SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';
-- [2011-01-03, 2011-01-05)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_topo_operators">
			<title>Operadores topológicos</title>
			<para>A continuación se presentan los operadores topológicos disponibles para los tipos de tiempo.</para>

			<itemizedlist>
				<listitem id="time_overlaps">
					<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
					<para>¿Se superponen los valores (tienen valores en común)?</para>
					<para><varname>{numrange,number} &amp;&amp; {numrange,number}: boolean</varname></para>
					<para><varname>{timestampset,period,periodset} &amp;&amp; {timestampset,period,periodset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)' &amp;&amp; intspan '[2, 4)';
-- true
SELECT floatspan '[1, 3)' &amp;&amp; floatspan '[3, 4)';
-- false
SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_contains">
					<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
					<para>¿Contiene el primer valor el segundo?</para>
					<para><varname>numrange @&gt; {numrange,number}: boolean</varname></para>
					<para><varname>{timestampset,period,periodset} @&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[1, 5]' @&gt; floatspan '[2, 5)';
-- true
SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';
-- true
</programlisting>
				</listitem>

				<listitem id="time_containedby">
					<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
					<para>¿Está el primer valor contenido en el segundo?</para>
					<para><varname> {numrange,number}&lt;@ numrange: boolean</varname></para>
					<para><varname>time &lt;@ {timestampset,period,periodset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[2, 5]' &lt;@ floatspan '[1, 5)';
-- false
SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_adjacent">
					<indexterm><primary><varname>-|-</varname></primary></indexterm>
					<para>¿Es el primer valor adyacente al segundo?</para>
					<para><varname>{numrange,number} -|- {numrange,number}: boolean</varname></para>
					<para><varname>time -|- time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[2, 6)' -|- intspan '[6, 7)';
-- true
SELECT floatspan '[2, 5)' -|- floatspan '(5, 6)';
-- false
SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';
-- true
SELECT periodset '{[2001-01-01, 2001-01-02]}' -|- period '[2001-01-02, 2001-01-03)';
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_relpos_operators">
			<title>Operadores de posición relativa</title>

			<para>Los operadores de posición relativa disponibles para los tipos de rango y de tiempo se dan a continuación.</para>

			<itemizedlist>
				<listitem id="span_left">
					<indexterm><primary><varname>&lt;&lt;</varname></primary></indexterm>
					<para>¿Está el primer valor estrictamente a la izquierda del segundo?</para>
					<para><varname>{number,span} &lt;&lt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &lt;&lt; 20;
-- true
SELECT floatspan '[15, 20)' &lt;&lt; floatspan '(15, 20)';
-- false
</programlisting>
				</listitem>

				<listitem id="span_right">
					<indexterm><primary><varname>&gt;&gt;</varname></primary></indexterm>
					<para>¿Está el primer valor estrictamente a la derecha del segundo?</para>
					<para><varname>{number,span} &gt;&gt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &gt;&gt; 10;
-- true
SELECT floatspan '[15, 20)' &gt;&gt; floatspan '[5, 10]';
-- true
</programlisting>
				</listitem>

				<listitem id="span_overleft">
					<indexterm><primary><varname>&amp;&lt;</varname></primary></indexterm>
					<para>¿No está el primer valor a la derecha del segundo?</para>
					<para><varname>{number,span} &amp;&lt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&lt; 18;
-- false
SELECT floatspan '[15, 20)' &amp;&lt; floatspan '[10, 20]';
-- true
</programlisting>
				</listitem>

				<listitem id="span_overright">
					<indexterm><primary><varname>&amp;&gt;</varname></primary></indexterm>
					<para>¿No está el primer valor a la izquierda del segundo?</para>
					<para><varname>{number,span} &amp;&gt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&gt; 30;
-- true
SELECT floatspan '[1, 6]' &amp;&gt; floatspan '(1, 3)';
-- false
</programlisting>
				</listitem>

				<listitem id="time_before">
					<indexterm><primary><varname>&lt;&lt;#</varname></primary></indexterm>
					<para>¿Es el primer valor estrictamente anterior al segundo?</para>
					<para><varname>time &lt;&lt;# time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_after">
					<indexterm><primary><varname>#&gt;&gt;</varname></primary></indexterm>
					<para>¿Es el primer valor estrictamente posterior al segundo?</para>
					<para><varname>time #&gt;&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt;
  periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_overbefore">
					<indexterm><primary><varname>&amp;&lt;#</varname></primary></indexterm>
					<para>¿No es el primer valor posterior al segundo?</para>
					<para><varname>time &amp;&lt;# time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';
-- false
</programlisting>
				</listitem>

				<listitem id="time_overafter">
					<indexterm><primary><varname>#&amp;&gt;</varname></primary></indexterm>
					<para>¿No es el primer valor anterior al segundo?</para>
					<para><varname>time #&amp;&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Operador de distancia</title>

			<para>El operador de distancia <varname>&lt;-&gt;</varname> para los tipos de rango o de tiempo considera el lapso o período delimitador y devuelve un valor <varname>float</varname> que es la distancia más pequeña entre los dos valores. En el caso de períodos devuelve el número de segundos entre los dos valores de tiempo. El operador de distancia también se puede usar para búsquedas de vecinos más cercanos utilizando un índice GiST o SP-GiST (ver <xref linkend="indexing_time_types" />).</para>

			<itemizedlist>
				<listitem id="smallest_distance_time">
					<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
					<para>Obtener la distancia mínima</para>
					<para><varname>{number,span} &lt;-&gt; {number,span}: float</varname></para>
					<para><varname>time &lt;-&gt; time: float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 3 &lt;-&gt; intspan '(5, 7]';
-- 3
SELECT floatspan '[1, 3]' &lt;-&gt; floatspan '(5.5, 7]';
-- 2.5
SELECT period '[2001-01-02, 2001-01-06)' &lt;-&gt; timestamptz '2001-01-07';
-- 86400
SELECT timestampset '{2001-01-01, 2001-01-03, 2001-01-05}' &lt;-&gt;
  timestampset '{2001-01-02, 2001-01-04}';
--  0
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones agregadas</title>

			<para>Las funciones agregadas temporales generalizan las funciones agregadas tradicionales. Su semántica es que calculan el valor de la función en cada instante de la <emphasis>unión</emphasis> de las extensiones temporales de los valores a agregar. En contraste, recuerde que todas las otras funciones que manipulan tipos de tiempo calculan el valor de la función en cada instante de la <emphasis>intersección</emphasis> de las extensiones temporales de los argumentos.</para>

			<para>Las funciones agregadas temporales son las siguientes:</para>
			<itemizedlist>
				<listitem><para>La función <varname>tcount</varname> generaliza la función tradicional <varname>count</varname>. El conteo temporal se puede utilizar para calcular en cada momento el número de objetos disponibles (por ejemplo, el número of períodos). La función <varname>tcount</varname> devuelve un entero temporal (ver el <xref linkend="temporal_types" />).</para></listitem>
				<listitem><para>La función <varname>extent</varname> devuelve el rango o período delimitador que engloba un conjunto de valores de rango o de tiempo.</para></listitem>
			</itemizedlist>

			<para>La unión es una operación a muy útil para los tipos de tiempo. Como hemos visto en la <xref linkend="time_set_operators" />, podemos calcular la unión de dos valores de tiempo usando el operador <varname>+</varname>. Sin embargo, también es muy útil tener una versión agregada del operador de unión para combinar un número arbitrario de valores. La función <varname>tunion</varname> se puede utilizar para este propósito.
			</para>

			<itemizedlist>
				<listitem id="time_tcount">
					<indexterm><primary><varname>tcount</varname></primary></indexterm>
					<para>Conteo temporal</para>
					<para><varname>tcount({timestampset,period,periodset}): {tint_seq,tint_seqset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tcount(ts) FROM times;
-- {2@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-04, 1@2000-01-05, 1@2000-01-06}

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT tcount(ps) FROM periods;
/* {[2@2000-01-01, 3@2000-01-02], (2@2000-01-02, 3@2000-01-03, 3@2000-01-04],
   (1@2000-01-04, 2@2000-01-05, 2@2000-01-06]} */
</programlisting>
				</listitem>

				<listitem id="time_extent">
					<indexterm><primary><varname>extent</varname></primary></indexterm>
					<para>Rango o período delimitador</para>
					<para><varname>extent(span): span</varname></para>
					<para><varname>extent({timestampset,period,periodset}): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH spans(r) AS (
  SELECT floatspan '[1, 4)' UNION
  SELECT floatspan '(5, 8)' UNION
  SELECT floatspan '(7, 9)'
)
SELECT extent(r) FROM spans;
-- [1,9)

WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT extent(ts) FROM times;
-- [2000-01-01, 2000-01-06]

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT extent(ps) FROM periods;
-- [2000-01-01, 2000-01-06]
</programlisting>
				</listitem>

				<listitem id="tunion">
					<indexterm><primary><varname>tunion</varname></primary></indexterm>
					<para>Unión temporal</para>
					<para><varname>tunion({timestampset,period,periodset}): {timestampset,periodset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tunion(ts) FROM times;
-- {2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05, 2000-01-06}
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-03], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-07, 2000-01-08]}'
)
SELECT tunion(ps) FROM periods;
-- {[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06], [2000-01-07, 2000-01-08]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id ="indexing_time_types">
		<title>Indexación de tipos de tiempo y de rango</title>

		<para>Se pueden crear índices GiST y SP-GiST en columnas de tablas de los tipos <varname>intspan</varname>, <varname>floatspan</varname>, <varname>period</varname>, <varname>timestampset</varname> y <varname>periodset</varname>. El índice GiST implementa un árbol R, mientras que el índice SP-GiST implementa un árbol cuádruple. Un ejemplo de creación de un índice GiST en una columna <varname>During</varname> de tipo <varname>period</varname> en una tabla <varname>Reservation</varname> es como sigue:
			<programlisting language="sql" xml:space="preserve">
CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,
  During period);
CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);
</programlisting>
		</para>
		<para>Un índice GiST o SP-GiST puede acelerar las consultas que involucran a los siguientes operadores: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname> y <varname>&lt;-&gt;</varname>.</para>
		<para>Además, se pueden crear índices de árbol B para columnas de tabla de un tipo de rango o de tiempo. Para estos tipos de índices, básicamente la única operación útil es la igualdad. Hay un orden de clasificación de árbol B definido para valores de tipos de rango o de tiempo con los correspondientes operadores <varname>&lt;</varname> y <varname>&gt;</varname>, pero el orden es bastante arbitrario y no suele ser útil en el mundo real. El soporte del árbol B está destinado principalmente a permitir la clasificación interna en las consultas, en lugar de la creación de índices reales.</para>
	</sect1>
</chapter>
