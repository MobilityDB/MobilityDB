<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="temporal_types_analytics">
	<title>Tipos temporales: Operaciones de análisis</title>

	<sect1 id="temporal_types_simplification">
		<title>Simplificación</title>
		<itemizedlist>
			<listitem id="minDistSimplify">
				<indexterm><primary><varname>minDistSimplify</varname></primary></indexterm>
				<para>Simplificar un flotante o un punto temporal asegurándose de que los valores consecutivos estén al menos separados por una cierta distancia. &Z_support; &geography_support;</para>
				<para><varname>minDistSimplify({tfloat,tpoint},mindist float) → {tfloat,tpoint}</varname></para>
				<para>En el caso de puntos temporales la distancia se especifica en las unidades del sistema de coordenadas. Observe que la simplificación se aplica sólo a secuencias temporales o conjuntos de secuencias con interpolación lineal. En todos los demás casos, se devuelve una copia del punto temporal dado.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minDistSimplify(tfloat '[1@2000-01-01,2@2000-01-02,3@2000-01-04,4@2000-01-05]', 1);
-- [1@2000-01-01, 3@2000-01-04]
SELECT asText(minDistSimplify(tgeompoint '[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02, Point(3 3 3)@2000-01-04, Point(5 5 5)@2000-01-05)', sqrt(3)));
-- [POINT Z (1 1 1)@2000-01-01, POINT Z (3 3 3)@2000-01-04, POINT Z (5 5 5)@2000-01-05)
SELECT asText(minDistSimplify(tgeompoint '[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02, Point(3 3 3)@2000-01-04, Point(4 4 4)@2000-01-05)', sqrt(3)));
-- [POINT Z (1 1 1)@2000-01-01, POINT Z (3 3 3)@2000-01-04]
</programlisting>
			</listitem>

			<listitem id="minTimeDeltaSimplify">
				<indexterm><primary><varname>minTimeDeltaSimplify</varname></primary></indexterm>
				<para>Simplificar un flotante o un punto temporal asegurándose de que los valores consecutivos estén al menos separados por un cierto intervalo de tiempo. &Z_support; &geography_support;</para>
				<para><varname>minTimeDeltaSimplify({tfloat,tpoint},mint interval) → {tfloat,tpoint}</varname></para>
				<para>Observe que la simplificación se aplica sólo a secuencias temporales o conjuntos de secuencias con interpolación lineal. En todos los demás casos, se devuelve una copia del punto temporal dado.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minTimeDeltaSimplify(tfloat '[1@2000-01-01, 2@2000-01-02, 3@2000-01-04,
  4@2000-01-05]', '1 day');
-- [1@2000-01-01, 3@2000-01-04]
SELECT asText(minTimeDeltaSimplify(tgeogpoint '[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02, Point(3 3 3)@2000-01-04, Point(5 5 5)@2000-01-05)', '1 day'));
-- [POINT Z (1 1 1)@2000-01-01, POINT Z (3 3 3)@2000-01-04]
</programlisting>
			</listitem>

			<listitem id="DouglasPeuckerSimplify">
				<indexterm><primary><varname>maxDistSimplify</varname></primary></indexterm>
				<indexterm><primary><varname>DouglasPeuckerSimplify</varname></primary></indexterm>
				<para>Simplificar un flotante o un punto temporal usando el <ulink url="https://es.wikipedia.org/wiki/Algoritmo_de_Ramer%E2%80%93Douglas%E2%80%93Peucker">algoritmo de Douglas-Peucker</ulink> &Z_support;</para>
				<para><varname>maxDistSimplify({tfloat,tgeompoint},maxdist float,syncdist=true) →</varname></para>
				<para><varname>  {tfloat,tgeompoint}</varname></para>
				<para><varname>DouglasPeuckerSimplify({tfloat,tgeompoint},maxdist float,syncdist=true) →</varname></para>
				<para><varname>  {tfloat,tgeompoint}</varname></para>
				<para>La diferencia entre las dos funciones es que <varname>maxDistSimplify</varname> usa una versión del algoritmo de un solo recorrido, mientras que <varname>DouglasPeuckerSimplify</varname> usa el algoritmo recursivo estándar.</para>
				<para>La función elimina los valores or los puntos cuya distancia es menor que la distancia pasada como segundo argumento. En el caso de puntos temporales la distancia se especifica en las unidades del sistema de coordenadas. El tercer argumento se aplica solo a puntos temporales y especifica si se utiliza la distancia espacial o la distancia  sincronizada. Observe que la simplificación se aplica sólo a secuencias temporales o conjuntos de secuencias con interpolación lineal. En todos los demás casos, se devuelve una copia del punto temporal dado.</para>
				<programlisting language="sql" xml:space="preserve">
-- Only synchronous distance for temporal floats
SELECT maxDistSimplify(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 3@2000-01-04,
  1@2000-01-05]', 1, false);
-- [1@2000-01-01, 1@2000-01-03, 3@2000-01-04, 1@2000-01-05]
-- Synchronous distance by default for temporal points
SELECT asText(maxDistSimplify(tgeompoint '[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(3 1)@2000-01-03, Point(3 3)@2000-01-05, Point(5 1)@2000-01-06]', 2));
-- [POINT(1 1)@2000-01-01, POINT(3 3)@2000-01-05, POINT(5 1)@2000-01-06]
-- Spatial distance
SELECT asText(maxDistSimplify(tgeompoint '[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(3 1)@2000-01-03, Point(3 3)@2000-01-05, Point(5 1)@2000-01-06]', 2, false));
-- [POINT(1 1)@2000-01-01, POINT(5 1)@2000-01-06]
</programlisting>
				<programlisting language="sql" xml:space="preserve">
-- Spatial vs synchronized distance
SELECT asText(DouglasPeuckerSimplify(tgeompoint '[Point(1 1)@2000-01-01, Point(6 1)@2000-01-06,
  Point(7 4)@2000-01-07]', 2.3, false));
-- [POINT(1 1)@2000-01-01, POINT(7 4)@2000-01-07]
SELECT asText(DouglasPeuckerSimplify(tgeompoint '[Point(1 1)@2000-01-01, Point(6 1)@2000-01-06,
  Point(7 4)@2000-01-07]', 2.3, true));
-- [POINT(1 1)@2000-01-01, POINT(6 1)@2000-01-06, POINT(7 4)@2000-01-07]
</programlisting>
				<para>La diferencia entre la distancia espacial y la distancia sincronizada se ilustra en los dos últimos ejemplos anteriores y en la <xref linkend="dist_vs_sed" />. En el primer ejemplo, que usa la distancia espacial, se elimina el segundo instante ya que la distancia perperdicular entre <varname>POINT(2 2)</varname> y la línea definida por <varname>POINT(1 1)</varname> y <varname>POINT(7 4)</varname> es igual a 2.23. Por el contrario, en el segundo ejemplo se mantiene el segundo instante dado que la proyección de <varname>Point(6 2)</varname> en la marca de tiempo <varname >2000-01-06</varname> sobre el segmento de línea temporal da como resultado <varname>Point(6 3.5)</varname> y la distancia entre el punto original y su proyección es 2.5.</para>
				<figure id="dist_vs_sed" float="start">
					<title>Diferencia entre la distancia espacial la distancia sincronizada.</title>
					<mediaobject>
						<imageobject><imagedata scale='100' fileref='../images/dist_vs_sed.pdf' /></imageobject>
						<imageobject><imagedata scale='100' fileref='../images/dist_vs_sed.svg' /></imageobject>
						<imageobject><imagedata scale='100' fileref='../images/dist_vs_sed.png' /></imageobject>
					</mediaobject>
				</figure>
				<para>Un uso típico de la función <varname>DouglasPeuckerSimplify</varname> es reducir el tamaño de un conjunto de datos, en particular con fines de visualización. Si la visualización es estática, se debe preferir la distancia espacial; si la visualización es dinámica o animada, se debe preferir la distancia sincronizada.</para>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_types_similarity">
		<title>Similaridad</title>
		<itemizedlist>
			<listitem id="hausdorffDistance">
				<indexterm><primary><varname>hausdorffDistance</varname></primary></indexterm>
				<para>Obtener la <ulink url="https://en.wikipedia.org/wiki/Hausdorff_distance">distancia de Hausdorff</ulink> discreta entre dos valores temporales &Z_support; &geography_support;</para>
				<para><varname>hausdorffDistance({tnumber, tgeo}, {tnumber, tgeo}) → float</varname></para>
				<para>Esta función tiene una complejidad cuadrática en el número de instantes de los valores temporales. Por lo tanto, la función requerirá un tiempo considerable para valores temporales con gran número de instantes.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT hausdorffDistance(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 0.5
SELECT round(hausdorffDistance(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 1.414214
</programlisting>
			</listitem>

			<listitem id="frechetDistance">
				<indexterm><primary><varname>frechetDistance</varname></primary></indexterm>
				<para>Obtener la <ulink url="https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance">distancia de Fréchet</ulink> discreta entre dos valores temporales &Z_support; &geography_support;</para>
				<para><varname>frechetDistance({tnumber, tgeo}, {tnumber, tgeo}) → float</varname></para>
				<para>Esta función tiene una complejidad de espacio lineal ya que solo dos filas de la matriz de distancia son asignadas en la memoria. Sin embargo, su complejidad de tiempo es cuadrática en el número de instantes de los valores temporales. Por lo tanto, la función requerirá un tiempo considerable para valores temporales con gran número de instantes.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistance(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 0.5
SELECT round(frechetDistance(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 1.414214
</programlisting>
			</listitem>

			<listitem id="frechetDistancePath">
				<indexterm><primary><varname>frechetDistancePath</varname></primary></indexterm>
				<para>Obtener las parejas de correspondencia entre dos valores temporales con respecto a la distancia de Fréchet discreta &Z_support; &geography_support; &SRF;</para>
				<para><varname>frechetDistancePath({tnumber, tgeo}, {tnumber, tgeo}) → {(i,j)}</varname></para>
				<para>Esta función requiere ubicar en memoria una matriz de distancias cuyo tamaño es cuadrático en el número de instantes de los valores temporales. Por tanto, la función fallará para valores temporales con gran número de instantes dependiendo de la memoria disponible.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistancePath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT frechetDistancePath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarp">
				<indexterm><primary><varname>dynamicTimeWarp</varname></primary></indexterm>
				<para>Obtener la distancia de distorsión de tiempo dinámica (<ulink url="https://en.wikipedia.org/wiki/Dynamic_time_warping">Dynamic Time Warp</ulink> o DTW) entre dos valores temporales &Z_support; &geography_support;</para>
				<para><varname>dynamicTimeWarp({tnumber, tgeo}, {tnumber, tgeo}) → float</varname></para>
				<para>Esta función tiene una complejidad de espacio lineal ya que solo dos filas de la matriz de distancia son asignadas en la memoria. Sin embargo, su complejidad de tiempo es cuadrática en el número de instantes de los valores temporales. Por lo tanto, la función requerirá un tiempo considerable para valores temporales con gran número de instantes.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarp(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 2
SELECT round(dynamicTimeWarp(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 3.380776
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarpPath">
				<indexterm><primary><varname>dynamicTimeWarpPath</varname></primary></indexterm>
				<para>Obtener las parejas de correspondencia entre dos valores temporales con respecto a la distancia de distorsión de tiempo dinámica (Dynamic Time Warp o DTW) &Z_support; &geography_support; &SRF;</para>
				<para><varname>dynamicTimeWarpPath({tnumber, tgeo}, {tnumber, tgeo}) → {(int,int)}</varname></para>
				<para><varname>frechetDistancePath({tnumber, tgeo}, {tnumber, tgeo}) → {(int,int)}</varname></para>
				<para>Esta función requiere ubicar en memoria una matriz de distancias cuyo tamaño es cuadrático en el número de instantes de los valores temporales. Por tanto, la función fallará para valores temporales con gran número de instantes dependiendo de la memoria disponible.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarpPath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT dynamicTimeWarpPath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_types_tiling">
		<title>Mosaicos multidimensionales</title>
		<para>Los mosaicos multidimensionales es el mecanismo que se utiliza para dividir el dominio de valores temporales en intervalos o mosaicos de un número variable de dimensiones. En el caso de una sola dimensión, el dominio se puede dividir por valor o por tiempo utilizando intervalos del mismo ancho o la misma duración, respectivamente. Para los números temporales, el dominio se puede dividir en mosaicos bidimensionales del mismo ancho para la dimensión de valor y la misma duración para la dimensión de tiempo. Para los puntos temporales, el dominio se puede dividir en el espacio en mosaicos bidimensionales o tridimensionales, dependiendo del número de dimensiones de las coordenadas espaciales. Finalmente, para los puntos temporales, el dominio se puede dividir por espacio y por tiempo usando mosaicos tridimensionales o tetradimensionales. Además, los valores temporales también se pueden fragmentar de acuerdo con una malla multidimensional definida sobre el dominio subyacente.</para>

		<para>Los mosaicos multidimensionales se pueden utilizar para diversos fines. Por ejemplo, se pueden utilizar para calcular histogramas multidimensionales, donde los valores temporales se agregan de acuerdo con la partición subyacente del dominio. Por otro lado, el mosaico multidimensional se puede utilizar para distribuir un conjunto de datos en un grupo de servidores, donde cada servidor contiene una partición del conjunto de datos. La ventaja de este mecanismo de partición es que conserva la proximidad en el espacio y el tiempo, a diferencia de los mecanismos de partición tradicionales basados ​​en hash utilizados en entornos de big data.</para>

		<figure id="tiling" float="start">
			<title>Mosaicos multidimensionales para números flotantes temporales.</title>
			<mediaobject>
				<imageobject role="html"><imagedata format="SVG" fileref='../images/tiling.svg'/></imageobject>
				<imageobject role="dblatex"><imagedata scale='75' format="PDF" fileref='../images/tiling.pdf'/></imageobject>
				<imageobject role="dbtoepub"><imagedata scale='75' format="PDF" fileref='../images/tiling.pdf'/></imageobject>
			</mediaobject>
		</figure>

		<para>
			La <xref linkend="tiling" /> ilustra un mosaico multidimensional para números flotantes temporales. El dominio bidimensional se divide en mosaicos que tienen el mismo tamaño para la dimensión de valor y la misma duración para la dimensión de tiempo. Suponga que este esquema de mosaicos se usa para distribuir un conjunto de datos en un clúster de seis servidores, como sugiere el patrón gris en la figura. En este caso, los valores se fragmentan para que cada servidor reciba los datos de mosaicos contiguos. Esto implica en particular que cuatro nodos recibirán un fragmento del número flotante temporal que se muestra en la figura. Una ventaja de esta distribución de datos basada en mosaicos multidimensionales es que reduce los datos que deben intercambiarse entre nodos cuando se procesan consultas, un proceso que generalmente se denomina <emphasis>reshuffling</emphasis>.
		</para>

		<para>Muchas de las funciones de esta sección son <emphasis>funciones de retorno de conjuntos</emphasis> (también conocidas como <emphasis>funciones de tabla</emphasis>) ya que normalmente devuelven más de un valor. En este caso, las funciones están marcadas con el símbolo &SRF;.</para>

		<sect2 id="bucket_functions">
			<title>Operaciones de intervalos</title>

			<itemizedlist>
				<listitem id="bucketList">
					<indexterm><primary><varname>bucketList</varname></primary></indexterm>
					<para>Obtener un conjunto de parejas que cubre el rango o el período con intervalos de la misma amplitud o duración alineados con el origen &SRF;.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en 0 para los rangos y en lunes 3 de enero de 2000 para los períodos. Los índices empiezan en 1. </para>
					<para><varname>bucketList(bounds unitspan,width number,origin number=0) → {(index,span)}</varname></para>
					<para><varname>bucketList(bounds tstzspan,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  {(index,span)}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(intspan '[15, 25]', 2) AS bl) t;
-- 1 | [14,16)
-- 2 | [16,18)
-- 3 | [18,20)
-- ...
SELECT bucketList(floatspan '[-10, -1]', 2.5, -7);
-- (1,"[-12, -9.5)")
-- (2,"[-9.5, -7)")
-- (3,"[-7, -4.5)")
-- ...
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(tstzspan '[2000-01-15, 2000-01-25]','2 days') AS bl) t;
-- 1 | [2000-01-15, 2000-01-17)
-- 2 | [2000-01-17, 2000-01-19)
-- 3 | [2000-01-19, 2000-01-21)
-- ...
SELECT bucketList(tstzspan '[2000-01-15, 2000-01-25]', '2 days', '2000-01-02');
-- (1,"[2000-01-14, 2000-01-16)")
-- (2,"[2000-01-16, 2000-01-18)")
-- (3,"[2000-01-18, 2000-01-20)")
-- ...
</programlisting>
				</listitem>

				<listitem id="valueBucket">
					<indexterm><primary><varname>valueBucket</varname></primary></indexterm>
					<para> Obtener el valor inicial del intervalo que contiene el número de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en 0.</para>
					<para><varname>valueBucket(value number,width number, origin number=0) → number</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT valueBucket(3, 2);
-- 2
SELECT valueBucket(3.5, 2.5, 1.5);
-- 1.5
</programlisting>
				</listitem>

				<listitem id="spanBucket">
					<indexterm><primary><varname>spanBucket</varname></primary></indexterm>
					<para>Obtener el rango en el espacio de intervalos que contiene el número de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en 0.</para>
					<para><varname>spanBucket(value number,width number,origin number=0) → span</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT spanBucket(2, 2);
-- [2,4)
SELECT spanBucket(2, 2, 1);
-- [1,3)
SELECT spanBucket(2, 2.5);
-- [0,2.5)
SELECT spanBucket(2, 2.5, 1.5);
-- [1.5,4)
</programlisting>
				</listitem>

				<listitem id="timeBucket">
					<indexterm><primary><varname>timeBucket</varname></primary></indexterm>
					<para> Obtener el valor inicial del intervalo que contiene la marca de tiempo de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en lunes 3 de enero de 2000.</para>
					<para><varname>timeBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  timestamptz</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days');
-- 2020-04-29 01:00:00+02
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days', timestamptz '2020-01-01');
-- 2020-04-30 01:00:00+02
</programlisting>
				</listitem>

				<listitem id="periodBucket">
					<indexterm><primary><varname>periodBucket</varname></primary></indexterm>
					<para>Obtener el período en el espacio de intervalos que contiene la marca de tiempo de entrada.</para>
					<para>Si el origen no se especifica, su valor se establece por defecto en lunes 3 de enero de 2000.</para>
					<para><varname>periodBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodBucket('2000-01-04', interval '1 week');
-- [2000-01-03,2000-01-10)
SELECT periodBucket('2000-01-04', interval '1 week', '2000-01-07');
-- [1999-12-31,2000-01-07)
</programlisting>
				</listitem>

			</itemizedlist>
		</sect2>

		<sect2 id="tile_functions">
			<title>Operaciones de mosaicos</title>

			<itemizedlist>
				<listitem id="tileList">
					<indexterm><primary><varname>tileList</varname></primary></indexterm>
					<para>Obtener un conjunto de parejas <varname>(index, tile)</varname> que cubre el cuadro delimitador con mosaicos multidimensionales del mismo tamaño y duración &Z_support; &SRF;</para>
					<para>Si el origen de las dimensiones de valores y/o de tiempo no se especifican, su valor se establece por defecto en 0 o <varname>'Point (0 0 0)'</varname> para la dimensión de valores (según el tipo de cuadro delimitador) y en el lunes 3 de enero de 2000 para la dimensión de tiempo.</para>
					<para><varname>tileList(bounds tbox,size float,duration interval,vorigin float=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03') → {(index,box)}</varname></para>
					<para><varname>tileList(bounds stbox,size float,sorigin geometry='Point(0 0 0)') → {(index,box)}</varname></para>
					<para><varname>tileList(bounds stbox,size float,duration interval,sorigin geometry='Point(0 0 0)',</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03') → {(index,box)}</varname></para>
					<para>En el caso de una malla espacio-temporal, el SRID de las coordenadas de los mosaicos está determinado por el del cuadro de entrada y el tamaño se da en las unidades del SRID. Si se especifica el origen de las coordenadas espaciales, que debe ser un punto, su dimensionalidad y SRID deben ser iguales al del cuadro delimitador, de lo contrario se genera un error.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (gr).index, (gr).tile
FROM (SELECT tileList(tfloat '[15@2000-01-15, 25@2000-01-25]'::tbox, 2.0, '2 days')
  AS gr) t;
-- 1 | TBOX XT([14,16),[2000-01-15,2000-01-17))
-- 2 | TBOX XT([16,18),[2000-01-15,2000-01-17))
-- 3 | TBOX XT([18,20),[2000-01-15,2000-01-17),)
-- ...
SELECT tileList(tfloat '[15@2000-01-15, 25@2000-01-25]'::tbox, 2.0, '2 days', 11.5);
-- (1,"TBOX XT([13.5,15.5),[2000-01-15,2000-01-17))")
-- (2,"TBOX XT([15.5,17.5),[2000-01-15,2000-01-17))")
-- (3,"TBOX XT([17.5,19.5),[2000-01-15,2000-01-17))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0);
-- (1,"STBOX X((2,2),(4,4))")
-- (2,"STBOX X((4,2),(6,4))")
-- (3,"STBOX X((6,2),(8,4))")
-- ...
SELECT tileList(tgeompoint 'SRID=3812;[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3)');
-- (1,"SRID=3812;STBOX X((3,3),(5,5))")
-- (2,"SRID=3812;STBOX X((5,3),(7,5))")
-- (3,"SRID=3812;STBOX X((7,3),(9,5))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3 3)');
-- (1,"STBOX Z((3,3,3),(5,5,5))")
-- (2,"STBOX Z((5,3,3),(7,5,5))")
-- (3,"STBOX Z((7,3,3),(9,5,5))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, interval '2 days');
-- (1,"STBOX XT(((2,2),(4,4)),[2000-01-15,2000-01-17))")
-- (2,"STBOX XT(((4,2),(6,4)),[2000-01-15,2000-01-17))")
-- (3,"STBOX XT(((6,2),(8,4)),[2000-01-15,2000-01-17))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, '2 days', 'Point(3 3 3)', '2000-01-15');
-- (1,"STBOX ZT(((3,3,3),(5,5,5)),[2000-01-15,2000-01-17))")
-- (2,"STBOX ZT(((5,3,3),(7,5,5)),[2000-01-15,2000-01-17))")
-- (3,"STBOX ZT(((7,3,3),(9,5,5)),[2000-01-15,2000-01-17))")
-- ...
</programlisting>
				</listitem>

				<listitem id="tile">
					<indexterm><primary><varname>tile</varname></primary></indexterm>
					<para>Obtener el mosaico de la malla multidimensional que contiene el valor y la marca de tiempo. &Z_support;</para>
					<para>Si el origen de las dimensiones de valores y/o de tiempo no se especifican, su valor se establece por defecto en 0 o <varname>'Point(0 0 0)'</varname> para la dimensión de valores y en el lunes 3 de enero de 2000 para la dimensión de tiempo, respectivamente.</para>
					<para><varname>tile(value float,time timestamptz,size float,duration interval,</varname></para>
					<para><varname>  vorigin float=0.0,torigin timestamptz='2000-01-03') → tbox</varname></para>
					<para><varname>tile(point geometry,size float,sorigin geometry='Point(0 0 0)') → stbox</varname></para>
					<para><varname>tile(point geometry,time timestamptz,size float,duration interval,sorigin</varname></para>
					<para><varname>  geometry='Point(0 0 0)',torigin timestamptz='2000-01-03') → stbox</varname></para>
					<para>En el caso de una malla espacio-temporal, el SRID de las coordenadas de los mosaicos está determinado por el punto de entrada y la amplitud espacial se da en las unidades del SRID. Si se especifica el origen de las coordenadas espaciales, que debe ser un punto, su dimensionalidad y SRID deben ser iguales al del cuadro delimitador, de lo contrario se genera un error.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tile(15, '2000-01-15', 2, interval '2 days');
-- TBOX XT([14,16),[2000-01-15,2000-01-17))
SELECT tile(15, '2000-01-15', 2, interval '2 days', 1, '2000-01-02');
-- TBOX XT([15,17),[2000-01-14,2000-01-16))
SELECT tile(geometry 'Point(1 1 1)', 2.0);
-- STBOX Z((0,0,0),(2,2,2))
SELECT tile(geometry 'Point(1 1)', '2000-01-01', 2.0, interval '2 days');
-- STBOX XT((0,0),(2,2),[2000-01-01,2000-01-03))
SELECT tile(geometry 'Point(1 1)', '2000-01-01', 2.0, '2 days', 'Point(1 1)',
  '2000-01-02');
-- STBOX XT(((1,1),(3,3)),[1999-12-31,2000-01-02))
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="split_functions">
			<title>Operaciones de fragmentación</title>
			<para>Estas operaciones fragmentan un valor temporal con respecto a una secuencia de intervalos (ver la <xref linkend="bucket_functions" />) o una mosaico multidimensional (ver la <xref linkend="tile_functions" />).</para>
			<itemizedlist>
				<listitem id="valueSplit">
					<indexterm><primary><varname>valueSplit</varname></primary></indexterm>
					<para>Fragmentar el número temporal con respecto a intervalos de valores &SRF;</para>
					<para><varname>valueSplit(value tnumber,width number,origin number=0) → {(number,tnumber)}</varname></para>
					<para>Si el origen de los valores no se especifica, su valor se establece por defecto en 0.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).tnumber
FROM (SELECT valueSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05, 10@2001-01-10]',
  2) AS sp) t;
--  0 | {[1@2001-01-01 00:00:00+01, 1@2001-01-02 00:00:00+01)}
--  2 | {[2@2001-01-02 00:00:00+01, 2@2001-01-05 00:00:00+01)}
--  4 | {[5@2001-01-05 00:00:00+01, 5@2001-01-10 00:00:00+01)}
-- 10 | {[10@2001-01-10 00:00:00+01]}
SELECT valueSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 2.0, 1.0);
-- (1,"{[1@2001-01-01 00:00:00+01, 3@2001-01-03 00:00:00+01)}")
-- (3,"{[3@2001-01-03 00:00:00+01, 5@2001-01-05 00:00:00+01)}")
-- (5,"{[5@2001-01-05 00:00:00+01, 7@2001-01-07 00:00:00+01)}")
-- (7,"{[7@2001-01-07 00:00:00+01, 9@2001-01-09 00:00:00+01)}")
-- (9,"{[9@2001-01-09 00:00:00+01, 10@2001-01-10 00:00:00+01)}")
</programlisting>
				</listitem>

				<listitem id="timeSplit">
					<indexterm><primary><varname>timeSplit</varname></primary></indexterm>
					<para>Fragmentar el valor temporal con respecto a intervalos de tiempo &Z_support; &SRF;</para>
					<para><varname>timeSplit(value ttype,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  {(time,temp)}</varname></para>
					<para>Si el origen del tiempo no se especifica, su valor se establece por defecto en el lunes 3 de enero de 2000.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time, (ts).temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', '2 days') AS ts) t;
-- 2011-12-31 | [1@2001-01-01, 2@2001-01-02)
-- 2001-01-02 | [2@2001-01-02, 4@2001-01-04)
-- 2001-01-04 | [4@2001-01-04, 6@2001-01-06)
-- ...
SELECT (ts).time, astext((ts).temp) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-10]',
  '2 days', '2001-01-01') AS ts) AS t;
-- 2001-01-01 | [POINT Z (1 1 1)@2001-01-01, POINT Z (3 3 3)@2001-01-03)
-- 2001-01-03 | [POINT Z (3 3 3)@2001-01-03, POINT Z (5 5 5)@2001-01-05)
-- 2001-01-05 | [POINT Z (5 5 5)@2001-01-05, POINT Z (7 7 7)@2001-01-07)
-- ...
</programlisting>
					<para>Observe que se puede fragmentar un valor temporal en intervalos de tiempo cíclicos (en lugar de lineales). Los siguientes dos ejemplos muestran cómo fragmentar un valor temporal por hora y por día de la semana.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time::time as hour, merge((ts).temp) as temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-03]', '1 hour') AS ts) t
GROUP BY hour ORDER BY hour;
/* 00:00:00 | {[1@2001-01-01 00:00:00+01, 1.1875@2001-01-01 01:00:00+01),
               [5.5@2001-01-02 00:00:00+01, 5.6875@2001-01-02 01:00:00+01)} */
/* 01:00:00 | {[1.1875@2001-01-01 01:00:00+01, 1.375@2001-01-01 02:00:00+01),
               [5.6875@2001-01-02 01:00:00+01, 5.875@2001-01-02 02:00:00+01)} */
/* 02:00:00 | {[1.375@2001-01-01 02:00:00+01, 1.5625@2001-01-01 03:00:00+01),
               [5.875@2001-01-02 02:00:00+01, 6.0625@2001-01-02 03:00:00+01)} */
/* 03:00:00 | {[1.5625@2001-01-01 03:00:00+01, 1.75@2001-01-01 04:00:00+01),
               [6.0625@2001-01-02 03:00:00+01, 6.25@2001-01-02 04:00:00+01)} */
/* ... */
SELECT EXTRACT(DOW FROM (ts).time) as dow_no, TO_CHAR((ts).time, 'Dy') as dow,
  asText(round(merge((ts).temp), 2)) as temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-14)',
  '1 hour') AS ts) t
GROUP BY dow, dow_no ORDER BY dow_no;
/* 0 | Sun | {[POINT(1 1)@2001-01-01, POINT(1.69 1.69)@2001-01-02),
              [POINT(5.85 5.85)@2001-01-08, POINT(6.54 6.54)@2001-01-09)} */
/* 1 | Mon | {[POINT(1.69 1.69)@2001-01-02, POINT(2.38 2.38)@2001-01-03),
              [POINT(6.54 6.54)@2001-01-09, POINT(7.23 7.23)@2001-01-10)} */
/* 2 | Tue | {[POINT(2.38 2.38)@2001-01-03, POINT(3.08 3.08)@2001-01-04),
              [POINT(7.23 7.23)@2001-01-10, POINT(7.92 7.92)@2001-01-11)} */
/* ... */
</programlisting>
				</listitem>

				<listitem id="valueTimeSplit">
					<indexterm><primary><varname>valueTimeSplit</varname></primary></indexterm>
					<para>Fragmentar el número temporal con respecto a los mosaicos de una malla de valores y de tiempo &SRF;</para>
					<para><varname>valueTimeSplit(value tumber,width number,duration interval,vorigin number=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03') → {(number,time,tnumber)}</varname></para>
					<para>Si el origen de los valores y/o el tiempo no se especifican, su valor se establece por defecto en 0 y en el lunes 3 de enero de 2000, respectivamente.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05,
  10@2001-01-10]', 5, '5 days') AS sp) t;
-- 0 | 2011-12-31 | [1@2001-01-01, 2@2001-01-02, 2@2001-01-05)
-- 5 | 2001-01-05 | [5@2001-01-05, 5@2001-01-10)
-- 10 | 2001-01-10 | [10@2001-01-10]
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 5.0, '5 days', 1.0,
  '2001-01-01') AS sp) t;
-- 1 | 2001-01-01 | [1@2001-01-01, 6@2001-01-06)
-- 6 | 2001-01-06 | [6@2001-01-06, 10@2001-01-10)
</programlisting>
				</listitem>

				<listitem id="spaceSplit">
					<indexterm><primary><varname>spaceSplit</varname></primary></indexterm>
					<para>Fragmentar el punto temporal con respecto a los mosaicos de una malla espacial &SRF;</para>
					<para><varname>spaceSplit(value tgeompoint,width float,origin geometry='Point(0 0 0)',</varname></para>
					<para><varname>  bitmatrix=true) → {(point,tpoint)}</varname></para>
					<para>Si el origen del espacio no se especifica, su valor se establece por defecto en <varname>'Point(0 0 0)'</varname>. Si no se especifica el argumento <varname>bitmatrix</varname>, el cálculo utilizará una matriz de bits para acelerar el proceso.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0) AS sp) t;
-- POINT(0 0) | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | {[POINT(2 2)@2020-03-02, POINT(4 4)@2020-03-04)}
-- POINT(4 4) | {[POINT(4 4)@2020-03-04, POINT(6 6)@2020-03-06)}
-- ...
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, 'Point(1 1 1)') AS sp) t;
-- POINT Z (1 1 1) | {[POINT Z (1 1 1)@2020-03-01, POINT Z (3 3 3)@2020-03-03)}
-- POINT Z (3 3 3) | {[POINT Z (3 3 3)@2020-03-03, POINT Z (5 5 5)@2020-03-05)}
-- POINT Z (5 5 5) | {[POINT Z (5 5 5)@2020-03-05, POINT Z (7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
				<listitem id="spaceTimeSplit">
					<indexterm><primary><varname>spaceTimeSplit</varname></primary></indexterm>
					<para>Fragmentar el punto temporal con respecto a los mosaicos de una malla espacio-temporal &SRF;</para>
					<para><varname>spaceTimeSplit(value tgeompoint,size float,duration interval,sorigin </varname></para>
					<para><varname>  geometry='Point(0 0 0)',torigin timestamptz='2000-01-03', bitmatrix=true) → </varname></para>
					<para><varname>  {(point,time,tpoint)}</varname></para>
					<para>Si el origen del espacio y/o el tiempo no se especifica, su valor se establece por defecto en <varname>'Point(0 0 0)'</varname> y en el lunes 3 de enero de 2000, respectivamente. Si no se especifica el argumento <varname>bitmatrix</varname>, el cálculo utilizará una matriz de bits para acelerar el proceso.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0, '2 days') AS sp) t;
-- POINT(0 0) | 2020-03-01 | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | 2020-03-01 | {[POINT(2 2)@2020-03-02, POINT(3 3)@2020-03-03]}
-- POINT(2 2) | 2020-03-03 | {[POINT(3 3)@2020-03-03, POINT(4 4)@2020-03-04)}
-- ...
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, '2 days', 'Point(1 1 1)', '2020-03-01') AS sp) t;
-- POINT Z(1 1 1) | 2020-03-01 | {[POINT Z(1 1 1)@2020-03-01, POINT Z(3 3 3)@2020-03-03)}
-- POINT Z(3 3 3) | 2020-03-03 | {[POINT Z(3 3 3)@2020-03-03, POINT Z(5 5 5)@2020-03-05)}
-- POINT Z(5 5 5) | 2020-03-05 | {[POINT Z(5 5 5)@2020-03-05, POINT Z(7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id="temporal_types_aggregations">
		<title>Agregaciones</title>

		<para>Las funciones agregadas temporales generalizan las funciones agregadas tradicionales. Su semántica es que calculan el valor de la función en cada instante de la <emphasis>unión</emphasis> de las extensiones temporales de los valores a agregar. En contraste, recuerde que todas las otras funciones que manipulan tipos temporales calculan el valor de la función en cada instante de la <emphasis>intersección</emphasis> de las extensiones temporales de los argumentos.</para>

		<para>Las funciones agregadas temporales son las siguientes:</para>
		<itemizedlist>
			<listitem><para>Para todos los tipos temporales, la función <varname>tcount</varname> generaliza la función traditional <varname>count</varname>. El conteo temporal se puede utilizar para calcular en cada momento el número de objetos disponibles (por ejemplo, el número de coches en un área).</para></listitem>
			<listitem><para>Para todos los tipos temporales, la función <varname>extent</varname> devuelve un cuadro delimitador que engloba un conjunto de valores temporales. Dependiendo del tipo de base, el resultado de esta función puede ser un <varname>tstzspan</varname>, un <varname>tbox</varname> o un <varname>stbox</varname>.</para></listitem>
			<listitem><para>Para el tipo booleano temporal, las funciones <varname>tand</varname> y <varname>tor</varname> generalizan las funciones traditionales <varname>and</varname> y <varname>or</varname>.</para></listitem>
			<listitem><para>Para los tipos numéricos temporales hay dos tipos de funciones agregadas temporales. Las funciones <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname> y <varname>tavg</varname> generalizan las funciones traditionales <varname>min</varname>, <varname>max</varname>, <varname>sum</varname> y <varname>avg</varname>. Además, las funciones <varname>wmin</varname>, <varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname> y <varname>wavg</varname> son versiones de ventana (o acumulativas) de las funciones tradicionales que, dado un intervalo de tiempo w, calculan el valor de la función en un instante t considerando los valores durante el intervalo [t-w, t]. Todas las funciones agregadas de ventana están disponibles para enteros temporales, mientras que para flotantes temporales sólo son significativos el mínimo y el máximo de ventana.</para></listitem>
			<listitem><para>Para el tipo texto temporal, las funciones <varname>tmin</varname> y <varname>tmax</varname> generalizan las funciones traditionales <varname>min</varname> y <varname>max</varname>.</para></listitem>
			<listitem><para>Finalmente, para puntos temporales, la función <varname>tcentroid</varname> generaliza la función <varname>ST_Centroid</varname> proporcionada por PostGIS. Por ejemplo, dado un conjunto de objetos que se mueven juntos (es decir, un convoy o una bandada), el centroide temporal producirá un punto temporal que representa en cada instante el centro geométrico (o el centro de masa) de todos los objetos en movimiento.</para></listitem>
		</itemizedlist>

		<para>En los ejemplos que siguen, suponemos que las tablas <varname>Department</varname> y <varname>Trip</varname> contienen las dos tuplas introducidas en la <xref linkend="temporal_types_examples" />.</para>
		<itemizedlist>
			<listitem id="tcount">
				<indexterm><primary><varname>tcount</varname></primary></indexterm>
				<para>Conteo temporal</para>
				<para><varname>tcount(ttype) → {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcount(NoEmps) FROM Department;
-- {[1@2001-01-01, 2@2001-02-01, 1@2001-08-01, 1@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="extent">
				<indexterm><primary><varname>extent</varname></primary></indexterm>
				<para>Extensión del cuadro delimitador</para>
				<para><varname>extent(temp) → {tstzspan,tbox,stbox}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT extent(noEmps) FROM Department;
-- TBOX XT((4,12),[2001-01-01,2001-10-01])
SELECT extent(Trip) FROM Trips;
-- STBOX XT(((0,0),(3,3),[2001-01-01 08:00:00+01, 2001-01-01 08:20:00+01)))
</programlisting>
			</listitem>

			<listitem id="tand">
				<indexterm><primary><varname>tand</varname></primary></indexterm>
				<para>Y temporal</para>
				<para><varname>tand(tbool) → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tand(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-04-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tor">
				<indexterm><primary><varname>tor</varname></primary></indexterm>
				<para>O temporal</para>
				<para><varname>tor(tbool) → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tor(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-08-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmin">
				<indexterm><primary><varname>tmin</varname></primary></indexterm>
				<para>Mínimo temporal</para>
				<para><varname>tmin(ttype) → tmin(ttype)</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmin(NoEmps) FROM Department;
-- {[10@2001-01-01, 4@2001-02-01, 6@2001-06-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmax">
				<indexterm><primary><varname>tmax</varname></primary></indexterm>
				<para>Máximo temporal</para>
				<para><varname>tmax(ttype) → tmin(ttype)</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmax(NoEmps) FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tsum">
				<indexterm><primary><varname>tsum</varname></primary></indexterm>
				<para>Suma temporal</para>
				<para><varname>tsum(tnumber) → {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tsum(NoEmps) FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 16@2001-04-01, 18@2001-06-01, 6@2001-08-01,
   6@2001-10-01)} */
</programlisting>
			</listitem>

			<listitem id="tavg">
				<indexterm><primary><varname>tavg</varname></primary></indexterm>
				<para>Promedio temporal</para>
				<para><varname>tavg(tnumber) → {tfloat_seq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tavg(NoEmps) FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8@2001-04-01, 8@2001-06-01), [9@2001-06-01, 9@2001-08-01),
   [6@2001-08-01, 6@2001-10-01) */
</programlisting>
			</listitem>

			<listitem id="wmin">
				<indexterm><primary><varname>wmin</varname></primary></indexterm>
				<para>Mínimo de ventana</para>
				<para><varname>wmin(tnumber,interval) → {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmin(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 4@2001-04-01, 6@2001-06-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wmax">
				<indexterm><primary><varname>wmax</varname></primary></indexterm>
				<para>Máximo de ventana</para>
				<para><varname>wmax(tnumber,interval) → {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmax(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wcount">
				<indexterm><primary><varname>wcount</varname></primary></indexterm>
				<para>Conteo de ventana</para>
				<para><varname>wcount(tnumber,interval) → {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wcount(NoEmps, interval '2 days') FROM Department;
/* {[1@2001-01-01, 2@2001-02-01, 3@2001-04-01, 2@2001-04-03, 3@2001-06-01, 2@2001-06-03,
   1@2001-08-03, 1@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wsum">
				<indexterm><primary><varname>wsum</varname></primary></indexterm>
				<para>Suma de ventana</para>
				<para><varname>wsum(tint,interval) → {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wsum(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 26@2001-04-01, 16@2001-04-03, 22@2001-06-01,
   18@2001-06-03, 6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wavg">
				<indexterm><primary><varname>wavg</varname></primary></indexterm>
				<para>Promedio de ventana</para>
				<para><varname>wavg(tint,interval) → {tfloat_discseq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wavg(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8.66666666666667@2001-04-01, 8.66666666666667@2001-04-03),
   [8@2001-04-03, 8@2001-06-01),
   [7.33333333333333@2001-06-01, 7.33333333333333@2001-06-03),
   [9@2001-06-03, 9@2001-08-03), [6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="tcentroid">
				<indexterm><primary><varname>tcentroid</varname></primary></indexterm>
				<para>Centroide temporal</para>
				<para><varname>tcentroid(tgeompoint) → tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcentroid(Trip) FROM Trips;
/* {[POINT(0 0)@2001-01-01 08:00:00+00, POINT(1 0)@2001-01-01 08:05:00+00),
   [POINT(0.5 0)@2001-01-01 08:05:00+00, POINT(1.5 0.5)@2001-01-01 08:10:00+00,
   POINT(2 1.5)@2001-01-01 08:15:00+00),
   [POINT(2 2)@2001-01-01 08:15:00+00, POINT(3 3)@2001-01-01 08:20:00+00)} */
</programlisting>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1 id="temporal_types_indexing">
		<title>Indexación</title>
		<para>Se pueden crear índices GiST y SP-GiST para columnas de tabla de tipos temporales. El índice GiST implementa un árbol R, mientras que el índice SP-GiST implementa un árbol cuádruple n-dimensional. Ejemplos de creación de índices son los siguientes:
			<programlisting language="sql" xml:space="preserve">
CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		</para>

		<para>Los índices GiST y SP-GiST almacenan el cuadro delimitador para los tipos temporales. Como se explica en el <xref linkend="temporal_types" />, estos son
			<itemizedlist>
				<listitem>
					<para>el tipo <varname>tstzspan</varname> para los tipos <varname>tbool</varname> y <varname>ttext</varname>,</para>
				</listitem>

				<listitem>
					<para>el tipo <varname>tbox</varname> par los tipos <varname>tint</varname> y <varname>tfloat</varname>,</para>
				</listitem>

				<listitem>
					<para>el tipo <varname>stbox</varname> para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Un índice GiST o SP-GiST puede acelerar las consultas que involucran a los siguientes operadores (consulte la <xref linkend="temporal_types_bbox" /> para obtener más información):
			<itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, que sólo consideran la dimensión de valores en tipos alfanuméricos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname> y <varname>/&amp;&gt;</varname>, que sólo consideran la dimensión espacial en tipos de puntos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, que sólo consideran la dimensión temporal para todos los tipos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname> y <varname>|=|</varname>, que consideran tantas dimensiones como compartan la columna indexada y el argumento de consulta. Estos operadores trabajan en cuadros delimitadores (es decir, <varname>tstzspan</varname>, <varname>tbox</varname> o <varname>stbox</varname>), no los valores completos.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Por ejemplo, dado el índice definido anteriormente en la tabla <varname>Department</varname> y una consulta que implica una condición con el operador <varname>&amp;&amp;</varname> (superposición), si el argumento derecho es un flotante temporal, entonces se consideran tanto el valor como las dimensiones de tiempo para filtrar las tuplas de la relación, mientras que si el argumento derecho es un valor flotante, un rango flotante o un tipo de tiempo, entonces el valor o la dimensión de tiempo se utilizará para filtrar las tuplas de la relación. Además, se puede construir un cuadro delimitador a partir de un valor/rango y/o una marca de tiempo/período, que se puede usar para filtrar las tuplas de la relación. Ejemplos de consultas que utilizan el índice en la tabla <varname>Department</varname> definida anteriormente se dan a continuación.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Department WHERE NoEmps &amp;&amp; intspan '[1, 5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; tstzspan '[2001-04-01, 2001-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tbox(intspan '[1, 5)', tstzspan '[2001-04-01, 2001-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tfloat '{[1@2001-01-01, 1@2001-02-01), [5@2001-04-01, 5@2001-05-01)}';
</programlisting>
		</para>

		<para>Del mismo modo, los ejemplos de consultas que utilizan el índice en la tabla <varname>Trips</varname> definida anteriormente se dan a continuación.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; tstzspan '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;
  stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', tstzspan '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;
  tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
</programlisting>
		</para>

		<para>Finalmente, se pueden crear índices de árbol B para columnas de tabla de todos los tipos temporales. Para este tipo de índice, la única operación útil es la igualdad. Hay un orden de clasificación de árbol B definido para valores de tipos temporales, con los correspondientes operadores <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname> y <varname>&gt;=</varname>, pero el orden es bastante arbitrario y no suele ser útil en el mundo real. El soporte de árbol B para tipos temporales está destinado principalmente a permitir la clasificación interna en las consultas, en lugar de la creación de índices reales.</para>

		<para>Para acelerar algunas de las funciones de los tipos temporales, se puede agregar en la cláusula <varname>WHERE</varname> de las consultas una comparación de cuadro delimitador que hace uso de los índices disponibles. Por ejemplo, este sería típicamente el caso de las funciones que proyectan los tipos temporales a las dimensiones de valor/espacio y/o tiempo. Esto filtrará las tuplas con un índice como se muestra en la siguiente consulta.
			<programlisting language="sql" xml:space="preserve">
SELECT atTime(T.Trip, tstzspan '[2001-01-01, 2001-01-02)')
FROM Trips T
-- Filtro de índice con cuadro delimitador
WHERE T.Trip &amp;&amp; tstzspan '[2001-01-01, 2001-01-02)';
</programlisting>
		</para>

		<para>En el caso de los puntos temporales, todas las relaciones espaciales con la semántica posible (ver la <xref linkend="tpoint_spatial_rel" />) incluyen automáticamente una comparación de cuadro delimitador que hará uso de cualquier índice que esté disponible en los puntos temporales. Por esta razón, la primera versión de las relaciones se usa típicamente para filtrar las tuplas con la ayuda de un índice al calcular las relaciones temporales como se muestra en la siguiente consulta.
			<programlisting language="sql" xml:space="preserve">
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Filtro de índice con cuadro delimitador
WHERE intersects(T.Trip, R.Geom);
</programlisting>
		</para>
	</sect1>

	<sect1 id="temporal_types_statistics">
		<title>Estadísticas y selectividad</title>
		<sect2>
			<title>Colecta de estadísticas</title>
			<para>El planificador de PostgreSQL se basa en información estadística sobre el contenido de las tablas para generar el plan de ejecución más eficiente para las consultas. Estas estadísticas incluyen una lista de algunos de los valores más comunes en cada columna y un histograma que muestra la distribución aproximada de datos en cada columna. Para tablas grandes, se toma una muestra aleatoria del contenido de la tabla, en lugar de examinar cada fila. Esto permite analizar tablas grandes en poco tiempo. La información estadística es recopilada por el comando <varname>ANALYZE</varname> y es almacenada en la tabla de catálogo <varname>pg_statistic</varname>. Dado que diferentes tipos de estadísticas pueden ser apropiados para diferentes tipos de datos, la tabla sólo almacena estadísticas muy generales (como el número de valores nulos) en columnas dedicadas. Todo lo demás se almacena en cinco &ldquo;slots&rdquo;, que son pares de columnas de matriz que almacenan las estadísticas de una columna de un tipo arbitrario.</para>

			<para>Las estadísticas recopiladas para tipos de tiempo y tipos temporales se basan en las recopiladas por PostgreSQL para tipos escalares y tipos de rango. Para tipos escalares, como <varname>float</varname>, se recopilan las siguientes estadísticas:
				<orderedlist numeration="arabic">
					<listitem>
						<para>fracción de valores nulos,</para>
					</listitem>
					<listitem>
						<para>ancho promedio, en bytes, de valores no nulos,</para>
					</listitem>
					<listitem>
						<para>número de diferentes valores no nulos,</para>
					</listitem>
					<listitem>
						<para>matriz de los valores más comunes y matriz de sus frecuencias,</para>
					</listitem>
					<listitem>
						<para>histograma de valores, donde se excluyen los valores más comunes,</para>
					</listitem>
					<listitem>
						<para>correlación entre el orden de filas físico y lógico.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Para los tipos de rango, como <varname>tstzrange</varname>, se recopilan tres histogramas adicionales:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>histograma de longitud de rangos no vacíos,</para>
					</listitem>
					<listitem>
						<para>histogramas de límites superior e inferior.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Para geometrías, además de (1)&#x2013;(3), se recopilan las siguientes estadísticas:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>número de dimensiones de los valores, cuadro delimitador N-dimensional, número de filas en la tabla, número de filas en la muestra, número de valores no nulos,</para>
					</listitem>
					<listitem>
						<para>Histograma N-dimensional que divide el cuadro delimitador en varias celdas y mantiene la proporción de valores que se cruzan con cada celda.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Las estadísticas recopiladas para columnas de los tipos de tiempo y de rango <varname>tstzset</varname>, <varname>tstzspan</varname>, <varname>tstzspanset</varname>, <varname>intspan</varname> y <varname>floatspan</varname> replican las recopiladas por PostgreSQL para <varname>tstzrange</varname>. Esto es claro para los tipos de rango en MobilityDB, que son versiones más eficientes de los tipos de rango en PostgreSQL. Para los tipos <varname>tstzset</varname> y <varname>tstzspanset</varname>, un valor se convierte en su período delimitador y luego se recopilan las estadísticas del tipo <varname>tstzspan</varname>.</para>

			<para>Las estadísticas recopiladas para columnas de los tipos temporales dependen del subtipo temporal y del tipo base. Además de las estadísticas (1)&#x2013;(3) que se recopilan para todos los tipos temporales, las estadísticas se recopilan para la dimensiónes de tiempo y de valor de forma independiente. Más precisamente, se recopilan las siguientes estadísticas para la dimensión de tiempo:
				<itemizedlist>
					<listitem>
						<para>Para columnas de subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para las marcas de tiempo.</para>
					</listitem>

					<listitem>
						<para>Para columnas de otro subtipo, las estadísticas (7)&#x2013;(8) se recopilan para los períodos delimitadores.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>Las siguientes estadísticas se recopilan para la dimensión de valores:
				<itemizedlist>
					<listitem>
						<para>Para columnas de tipos temporales con interpolación escalonada (es decir, <varname>tbool</varname>, <varname>ttext</varname> o <varname>tint</varname>):
							<itemizedlist>
								<listitem>
									<para>Para el subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para los valores.</para>
								</listitem>

								<listitem>
									<para>Para todas los demás subtipos, las estadísticas (7)&#x2013;(8) se recopilan para los valores.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>Para columnas de tipos temporales flotantes (es decir, <varname>tfloat</varname>):
							<itemizedlist>
								<listitem>
									<para>Para el subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para los valores.</para>
								</listitem>
								<listitem>
									<para>Para todas los demás subtipos, las estadísticas (7)&#x2013;(8) se recopilan por los rangos delimitadores de valores.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>Para columnas de tipos de puntos temporales (es decir, <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>) las estadísticas (9)&#x2013;(10) se compilan para los puntos.</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Estimación de la selectividad</title>

			<para>Los operadores booleanos en PostgreSQL se pueden asociar con dos funciones de selectividad, que calculan la probabilidad de que un valor de un tipo dado coincida con un criterio dado. Estas funciones de selectividad se basan en las estadísticas recopiladas. Hay dos tipos de funciones de selectividad. Las funciones de selectividad de <emphasis>restricción</emphasis> intentan estimar el porcentaje de filas en una tabla que satisfacen una condición en la cláusula <varname>WHERE</varname> de la forma <varname>column OP constant</varname>. Por otro lado, las funciones de selectividad de <emphasis>unión</emphasis> intentan estimar el porcentaje de filas en una tabla que satisfacen una condición en la cláusula <varname>WHERE</varname> de la forma <varname>table1.column1 OP table2.column2</varname>.</para>

			<para>MobilityDB define 23 clases de operadores booleanos (como<varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), cada uno de los cuales puede tener como argumentos izquierdo o derecho un tipo PostgreSQL (como <varname>integer</varname>, <varname>timestamptz</varname>, etc.) o un tipo MobilityDB (como <varname>tstzspan</varname>, <varname>tint</varname>, etc.). Como consecuencia, existe un número muy elevado de operadores con diferentes argumentos a considerar para las funciones de selectividad. El enfoque adoptado fue agrupar estas combinaciones en clases correspondientes a las dimensiones de valor o de tiempo. Las clases corresponden al tipo de estadísticas recopiladas como se explica en la sección anterior.</para>

			<para>MobilityDB estima la selectividad de restricción y de combinación para tipos de tiempo, de rango y temporales.</para>
		</sect2>
	</sect1>

</chapter>
