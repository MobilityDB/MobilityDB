# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Esteban Zimanyi <estebanzimanyi@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2021-07-31 21:52+0000\n"
"PO-Revision-Date: 2021-08-02 14:46+0000\n"
"Last-Translator: Esteban Zimanyi <estebanzimanyi@gmail.com>, 2021\n"
"Language-Team: Spanish (https://www.transifex.com/mobilitydb/teams/114013/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: title
#: time_types_range_types.xml:12
#, no-c-format
msgid "Time Types and Range Types"
msgstr "Tipos de tiempo y tipos de rango"

#. Tag: para
#: time_types_range_types.xml:14
#, no-c-format
msgid ""
"Temporal types are based on four time types: the "
"<varname>timestamptz</varname> type provided by PostgreSQL and three new "
"types which are <varname>period</varname>, <varname>timestampset</varname>, "
"and <varname>periodset</varname>."
msgstr ""
"Los tipos temporales se basan en cuatro tipos de tiempo: el tipo "
"<varname>timestamptz</varname> proporcionado por PostgreSQL y tres nuevos "
"tipos que son <varname>period</varname>, <varname>timestampset</varname> y "
"<varname>periodset</varname>."

#. Tag: para
#: time_types_range_types.xml:18
#, no-c-format
msgid ""
"The <varname>period</varname> type is a specialized version of the "
"<varname>tstzrange</varname> (short for timestamp with time zone range) type"
" provided by PostgreSQL. Type <varname>period</varname> has similar "
"functionality as type <varname>tstzrange</varname> but has a more efficient "
"implementation, in particular it is of fixed length while the "
"<varname>tstzrange</varname> type is of variable length. Furthermore, empty "
"periods and infinite bounds are not allowed in <varname>period</varname> "
"values, while they are allowed in <varname>tstzrange</varname> values."
msgstr ""
"El tipo <varname>period</varname> es una versión especializada del tipo "
"<varname>tstzrange</varname> (abreviatura de rango de marcas de tiempo con "
"zona horaria) proporcionado por PostgreSQL. El tipo "
"<varname>period</varname> tiene una funcionalidad similar al tipo "
"<varname>tstzrange</varname> pero tiene una implementación más eficiente, en"
" particular es de longitud fija mientras que el tipo "
"<varname>tstzrange</varname> es de longitud variable. Además, los períodos "
"vacíos y los límites infinitos no están permitidos en valores de "
"<varname>period</varname>, mientras están permitidos en valores de "
"<varname>tstzrange</varname>."

#. Tag: para
#: time_types_range_types.xml:22
#, no-c-format
msgid ""
"A value of the <varname>period</varname> type has two bounds, the lower "
"bound and the upper bound, which are <varname>timestamptz</varname> values. "
"The bounds can be inclusive or exclusive. An inclusive bound means that the "
"boundary instant is included in the period, while an exclusive bound means "
"that the boundary instant is not included in the period. In the text form of"
" a <varname>period</varname> value, inclusive and exclusive lower bounds are"
" represented, respectively, by &ldquo;<varname>[</varname>&rdquo; and "
"&ldquo;<varname>(</varname>&rdquo;. Likewise, inclusive and exclusive upper "
"bounds are represented, respectively, by &ldquo;<varname>]</varname>&rdquo; "
"and &ldquo;<varname>)</varname>&rdquo;. In a <varname>period</varname> "
"value, the lower bound must be less than or equal to the upper bound. A "
"<varname>period</varname> value with equal and inclusive bounds is called an"
" <emphasis>instantaneous period</emphasis> and corresponds to a "
"<varname>timestamptz</varname> value. Examples of <varname>period</varname> "
"values are as follows:"
msgstr ""
"Un valor del tipo <varname>period</varname> tiene dos límites, el límite "
"inferior y el límite superior, que son valores de "
"<varname>timestamptz</varname>. Los límites pueden ser inclusivos o "
"exclusivos. Un límite inclusivo significa que el instante límite está "
"incluido en el período, mientras que un límite exclusivo significa que el "
"instante límite no está incluido en el período. En el formato textual de un "
"valor de <varname>period</varname>, los límites inferiores inclusivos y "
"exclusivos están representados, respectivamente, por "
"&ldquo;<varname>[</varname>&rdquo; y &ldquo;<varname>(</varname>&rdquo;. "
"Asimismo, los límites superiores inclusivos y exclusivos se representan, "
"respectivamente, por &ldquo;<varname>]</varname>&rdquo; y "
"&ldquo;<varname>)</varname>&rdquo;. En un valor de "
"<varname>period</varname>, el límite inferior debe ser menor o igual que el "
"límite superior. Un valor de <varname>period</varname> con límites iguales e"
" inclusivos se llama <emphasis>período instantáneo</emphasis> y corresponde "
"a un valor de <varname>timestamptz</varname>. Ejemplos de valores de "
"<varname>period</varname> son como sigue:"

#. Tag: programlisting
#: time_types_range_types.xml:25
#, no-c-format
msgid ""
"SELECT period '[2012-01-01 08:00:00, 2012-01-03 09:30:00)';\n"
"-- Instant period\n"
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00]';\n"
"-- Erroneous period: invalid bounds\n"
"SELECT period '[2012-01-01 08:10:00, 2012-01-01 08:00:00]';\n"
"-- Erroneous period: empty period\n"
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00)';"
msgstr ""
"SELECT period '[2012-01-01 08:00:00, 2012-01-03 09:30:00)';\n"
"-- Período instantáneo\n"
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00]';\n"
"-- Período erróneo: límites inválidos\n"
"SELECT period '[2012-01-01 08:10:00, 2012-01-01 08:00:00]';\n"
"-- Período erróneo: período vacío\n"
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00)';"

#. Tag: para
#: time_types_range_types.xml:27
#, no-c-format
msgid ""
"The <varname>timestampset</varname> type represents a set of different "
"<varname>timestamptz</varname> values. A <varname>timestampset</varname> "
"value must contain at least one element, in which case it corresponds to a "
"<varname>timestamptz</varname> value. The elements composing a "
"<varname>timestampset</varname> value must be ordered. Examples of "
"<varname>timestampset</varname> values are as follows:"
msgstr ""
"El tipo <varname>timestampset</varname> representa un conjunto de valores "
"<varname>timestamptz</varname> diferentes. Un valor de "
"<varname>timestampset</varname> debe contener al menos un elemento, en cuyo "
"caso corresponde a un valor de <varname>timestamptz</varname>. Los elementos"
" que componen un valor de <varname>timestampset</varname> deben estar "
"ordenados. Ejemplos de valores de <varname>timestampset</varname> son como "
"sigue:"

#. Tag: programlisting
#: time_types_range_types.xml:30
#, no-c-format
msgid ""
"SELECT timestampset '{2012-01-01 08:00:00, 2012-01-03 09:30:00}';\n"
"-- Singleton timestampset\n"
"SELECT timestampset '{2012-01-01 08:00:00}';\n"
"-- Erroneous timestampset: unordered elements\n"
"SELECT timestampset '{2012-01-01 08:10:00, 2012-01-01 08:00:00}';\n"
"-- Erroneous timestampset: duplicate elements\n"
"SELECT timestampset '{2012-01-01 08:00:00, 2012-01-01 08:00:00}';"
msgstr ""
"SELECT timestampset '{2012-01-01 08:00:00, 2012-01-03 09:30:00}';\n"
"-- Conjunto unitario de marcas de tiempo\n"
"SELECT timestampset '{2012-01-01 08:00:00}';\n"
"-- Conjunto de marcas de tiempo erróneo: elementos desordenados\n"
"SELECT timestampset '{2012-01-01 08:10:00, 2012-01-01 08:00:00}';\n"
"-- Conjunto de marcas de tiempo erróneo: elementos duplicados\n"
"SELECT timestampset '{2012-01-01 08:00:00, 2012-01-01 08:00:00}';"

#. Tag: para
#: time_types_range_types.xml:32
#, no-c-format
msgid ""
"Finally, the <varname>periodset</varname> type represents a set of disjoint "
"<varname>period</varname> values. A <varname>periodset</varname> value must "
"contain at least one element, in which case it corresponds to a "
"<varname>period</varname> value. The elements composing a "
"<varname>periodset</varname> value must be ordered. Examples of "
"<varname>periodset</varname> values are as follows:"
msgstr ""
"Finalmente, el tipo <varname>periodset</varname> representa un conjunto de "
"valores disjuntos de <varname>period</varname>. Un valor de "
"<varname>periodset</varname> debe contener al menos un elemento, en cuyo "
"caso corresponde a un valor de <varname>period</varname>. Los elementos que "
"componen un valor de <varname>periodset</varname> deben estar ordenados. "
"Ejemplos de valores de <varname>periodset</varname> son come sigue:"

#. Tag: programlisting
#: time_types_range_types.xml:35
#, no-c-format
msgid ""
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],\n"
"  [2012-01-01 08:20:00, 2012-01-01 08:40:00]}';\n"
"-- Singleton periodset\n"
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';\n"
"-- Erroneous periodset: unordered elements\n"
"SELECT periodset '{[2012-01-01 08:20:00, 2012-01-01 08:40:00],\n"
"  [2012-01-01 08:00:00, 2012-01-01 08:10:00]}';\n"
"-- Erroneous periodset: overlapping elements\n"
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],\n"
"  [2012-01-01 08:05:00, 2012-01-01 08:15:00]}';"
msgstr ""
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],\n"
"  [2012-01-01 08:20:00, 2012-01-01 08:40:00]}';\n"
"-- Conjunto unitario de períodos\n"
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';\n"
"-- Conjunto de períodos erróneo: elementos desordenados\n"
"SELECT periodset '{[2012-01-01 08:20:00, 2012-01-01 08:40:00],\n"
"  [2012-01-01 08:00:00, 2012-01-01 08:10:00]}';\n"
"-- Conjunto de períodos erróneo: elementos superpuestos\n"
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],\n"
"  [2012-01-01 08:05:00, 2012-01-01 08:15:00]}';"

#. Tag: para
#: time_types_range_types.xml:37
#, no-c-format
msgid ""
"Values of the <varname>periodset</varname> type are converted into "
"<emphasis>normal form</emphasis> so that equivalent values have identical "
"representations. For this, consecutive adjacent period values are merged "
"when possible. An example of transformation into normal form is as follows:"
msgstr ""
"Los valores del tipo <varname>periodset</varname> son convertidos en "
"<emphasis>forma normal</emphasis> de modo que los valores equivalentes "
"tengan representaciones idénticas. Para ello, los valores de períodos "
"consecutivos que son adyacentes se fusionan cuando es posible. Un ejemplo de"
" transformación a forma normal es el siguiente:"

#. Tag: programlisting
#: time_types_range_types.xml:40
#, no-c-format
msgid ""
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00),\n"
"  [2012-01-01 08:10:00, 2012-01-01 08:10:00], (2012-01-01 08:10:00, 2012-01-01 08:20:00]}';\n"
"-- \"{[2012-01-01 08:00:00+00,2012-01-01 08:20:00+00]}\""
msgstr ""
"SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00),\n"
"  [2012-01-01 08:10:00, 2012-01-01 08:10:00], (2012-01-01 08:10:00, 2012-01-01 08:20:00]}';\n"
"-- \"{[2012-01-01 08:00:00+00,2012-01-01 08:20:00+00]}\""

#. Tag: para
#: time_types_range_types.xml:42
#, no-c-format
msgid ""
"Besides the built-in range types provided by PostgreSQL, MobilityDB defines "
"two additional range types: <varname>intrange</varname> (another name for "
"<varname>int4range</varname>) and <varname>floatrange</varname>."
msgstr ""
"Además de los tipos de rango nativos proporcionados por PostgreSQL, "
"MobilityDB define dos tipos de rango adicionales: "
"<varname>intrange</varname> (otro nombre para <varname>int4range</varname>) "
"y <varname>floatrange</varname>."

#. Tag: title
#: time_types_range_types.xml:47
#, no-c-format
msgid "Functions and Operators for Time Types and Range Types"
msgstr "Funciones y operadores para tipos de tiempo y de rango"

#. Tag: para
#: time_types_range_types.xml:49
#, no-c-format
msgid ""
"We present next the functions and operators for time and range types. These "
"functions and operators are polymorphic, that is, their arguments may be of "
"several types, and the result type may depend on the type of the arguments. "
"To express this in the signature of the operators, we use the following "
"notation:"
msgstr ""
"A continuación presentamos las funciones y operadores para tipos de tiempo y"
" de rango. Estas funciones y operadores son polimórficos, es decir, sus "
"argumentos pueden ser de varios tipos y el tipo de resultado puede depender "
"del tipo de los argumentos. Para expresar esto en la firma de los "
"operadores, utilizamos la siguiente notación:"

#. Tag: para
#: time_types_range_types.xml:54
#, no-c-format
msgid ""
"A set of types such as <varname>{period,timestampset,periodset}</varname> "
"represents any of the types listed,"
msgstr ""
"Un conjunto de tipos como <varname>{period,timestampset,periodset}</varname>"
" representa cualquiera de los tipos enumerados,"

#. Tag: para
#: time_types_range_types.xml:57
#, no-c-format
msgid ""
"<varname>time</varname> represents any time type, that is, "
"<varname>timestamptz</varname>, <varname>period</varname>, "
"<varname>timestampset</varname>, or <varname>periodset</varname>,"
msgstr ""
"<varname>time</varname> representa cualquier tipo de tiempo, es decir, "
"<varname>timestamptz</varname>, <varname>period</varname>, "
"<varname>timestampset</varname> o <varname>periodset</varname>,"

#. Tag: para
#: time_types_range_types.xml:60
#, no-c-format
msgid ""
"<varname>number</varname> represents any number type, that is, "
"<varname>integer</varname> or <varname>float</varname>,"
msgstr ""
"<varname>number</varname> representa cualquier tipo de número, es decir, "
"<varname>integer</varname> o <varname>float</varname>,"

#. Tag: para
#: time_types_range_types.xml:63
#, no-c-format
msgid ""
"<varname>range</varname> represents any number range type, that is, "
"<varname>intrange</varname> or <varname>floatrange</varname>."
msgstr ""
"<varname>range</varname> representa cualquier rango de números, es decir, "
"<varname>intrange</varname> o <varname>floatrange</varname>."

#. Tag: para
#: time_types_range_types.xml:66
#, no-c-format
msgid ""
"<varname>type[]</varname> represents an array of <varname>type</varname>."
msgstr ""
"<varname>type[]</varname> representa una matriz de <varname>type</varname>."

#. Tag: para
#: time_types_range_types.xml:70
#, no-c-format
msgid ""
"As an example, the signature of the contains operator "
"(<varname>@&gt;</varname>) is as follows:"
msgstr ""
"Como ejemplo, la firma del operador contiene (<varname>@&gt;</varname>) es "
"como sigue:"

#. Tag: programlisting
#: time_types_range_types.xml:73
#, no-c-format
msgid "{timestampset, period, periodset} @&gt; time: boolean"
msgstr "{timestampset,period,periodset} @&gt; time"

#. Tag: para
#: time_types_range_types.xml:74
#, no-c-format
msgid ""
"In the following, for conciseness, the time part of the timestamps is "
"omitted in the examples. Recall that in that case PostgreSQL assumes the "
"time <varname>00:00:00</varname>."
msgstr ""
"A continuación, por concisión, la parte de tiempo de las marcas de tiempo se"
" omite en los ejemplos. Recuerde que en ese caso PostgreSQL asume el tiempo "
"<varname>00:00:00</varname>."

#. Tag: title
#: time_types_range_types.xml:79
#, no-c-format
msgid "Constructor Functions"
msgstr "Funciones de constructor"

#. Tag: para
#: time_types_range_types.xml:81
#, no-c-format
msgid ""
"The <varname>period</varname> type has a constructor function that accepts "
"two or four arguments. The two-argument form constructs a period in "
"<emphasis>normal form</emphasis>, that is, with inclusive lower bound and "
"exclusive upper bound. The four-argument form constructs a period with "
"bounds specified by the third and fourth arguments, which are Boolean values"
" stating, respectively, whether the left and right bounds are inclusive or "
"not."
msgstr ""
"El tipo <varname>period</varname> tiene una función constructora que acepta "
"dos o cuatro argumentos. La forma de dos argumentos construye un punto en "
"<emphasis>forma normal</emphasis>, es decir, con límite inferior inclusivo y"
" límite superior exclusivo. La forma de cuatro argumentos construye un "
"período con límites especificados por el tercer y cuarto argumento, que son "
"valores booleanos que indican, respectivamente, si los límites izquierdo y "
"derecho son inclusivos o no."

#. Tag: varname
#: time_types_range_types.xml:85 time_types_range_types.xml:205
#, no-c-format
msgid "period"
msgstr "period"

#. Tag: para
#: time_types_range_types.xml:86
#, no-c-format
msgid "Constructor for <varname>period</varname>"
msgstr "Constructor para <varname>period</varname>"

#. Tag: varname
#: time_types_range_types.xml:87
#, no-c-format
msgid "period(timestamptz,timestamptz,left_inc=true,right_inc=false): period"
msgstr "period(timestamptz,timestamptz,left_inc=true,right_inc=false): period"

#. Tag: programlisting
#: time_types_range_types.xml:88
#, no-c-format
msgid ""
"-- Period defined with two arguments\n"
"SELECT period('2012-01-01 08:00:00', '2012-01-03 08:00:00');\n"
"-- [2012-01-01 08:00:00+01, 2012-01-03 08:00:00+01)\n"
"-- Period defined with four arguments\n"
"SELECT period('2012-01-01 08:00:00', '2012-01-03 09:30:00', false, true);\n"
"-- (2012-01-01 08:00:00+01, 2012-01-03 09:30:00+01]"
msgstr ""
"-- Período definido con dos argumentos\n"
"SELECT period('2012-01-01 08:00:00', '2012-01-03 08:00:00');\n"
"-- [2012-01-01 08:00:00+01, 2012-01-03 08:00:00+01)\n"
"-- Período definido con cuatro argumentos\n"
"SELECT period('2012-01-01 08:00:00', '2012-01-03 09:30:00', false, true);\n"
"-- (2012-01-01 08:00:00+01, 2012-01-03 09:30:00+01]"

#. Tag: para
#: time_types_range_types.xml:92
#, no-c-format
msgid ""
"The <varname>timestampset</varname> type has a constructor function that "
"accepts a single argument which is an array of "
"<varname>timestamptz</varname> values."
msgstr ""
"El tipo <varname>timestampset</varname> tiene una función constructora que "
"acepta un solo argumento que es una matriz de valores de "
"<varname>timestamptz</varname>."

#. Tag: varname
#: time_types_range_types.xml:96
#, no-c-format
msgid "timestampset"
msgstr "timestampset"

#. Tag: para
#: time_types_range_types.xml:97
#, no-c-format
msgid "Constructor for <varname>timestampset</varname>"
msgstr "Constructor para <varname>timestampset</varname>"

#. Tag: varname
#: time_types_range_types.xml:98
#, no-c-format
msgid "timestampset(timestamptz[]): timestampset"
msgstr "timestampset(timestamptz[]): timestampset"

#. Tag: programlisting
#: time_types_range_types.xml:99
#, no-c-format
msgid ""
"SELECT timestampset(ARRAY[timestamptz '2012-01-01 08:00:00', '2012-01-03 09:30:00']);\n"
"-- \"{2012-01-01 08:00:00+00, 2012-01-03 09:30:00+00}\""
msgstr ""
"SELECT timestampset(ARRAY[timestamptz '2012-01-01 08:00:00', '2012-01-03 09:30:00']);\n"
"-- \"{2012-01-01 08:00:00+00, 2012-01-03 09:30:00+00}\""

#. Tag: para
#: time_types_range_types.xml:103
#, no-c-format
msgid ""
"The <varname>periodset</varname> type has a constructor function that "
"accepts a single argument which is an array of <varname>period</varname> "
"values."
msgstr ""
"El tipo <varname>periodset</varname> tiene una función constructora que "
"acepta un solo argumento que es una matriz de valores de "
"<varname>period</varname>."

#. Tag: varname
#: time_types_range_types.xml:107
#, no-c-format
msgid "periodset"
msgstr "periodset"

#. Tag: para
#: time_types_range_types.xml:108
#, no-c-format
msgid "Constructor for <varname>periodset</varname>"
msgstr "Constructor para <varname>periodset</varname>"

#. Tag: varname
#: time_types_range_types.xml:109
#, no-c-format
msgid "periodset(period[]): periodset"
msgstr "periodset(period[]): periodset"

#. Tag: programlisting
#: time_types_range_types.xml:110
#, no-c-format
msgid ""
"SELECT periodset(ARRAY[period '[2012-01-01 08:00:00, 2012-01-01 08:10:00]',\n"
"-- '[2012-01-01 08:20:00, 2012-01-01 08:40:00]']);"
msgstr ""
"SELECT periodset(ARRAY[period '[2012-01-01 08:00:00, 2012-01-01 08:10:00]',\n"
"-- '[2012-01-01 08:20:00, 2012-01-01 08:40:00]']);"

#. Tag: title
#: time_types_range_types.xml:116
#, no-c-format
msgid "Casting"
msgstr "Conversión de tipos"

#. Tag: para
#: time_types_range_types.xml:117
#, no-c-format
msgid ""
"Values of the <varname>timestamptz</varname>, <varname>tstzrange</varname>, "
"or the time types can be converted to one another using the function "
"<varname>CAST</varname> or using the <varname>::</varname> notation."
msgstr ""
"Los valores de los tipos <varname>timestamptz</varname>, "
"<varname>tstzrange</varname> o los tipos de tiempo se pueden convertir entre"
" sí utilizando la función <varname>CAST</varname> o utilizando la notación "
"<varname>::</varname>."

#. Tag: varname
#: time_types_range_types.xml:122 time_types_range_types.xml:130
#: time_types_range_types.xml:136 time_types_range_types.xml:143
#, no-c-format
msgid "<varname>::</varname>"
msgstr "<varname>::</varname>"

#. Tag: para
#: time_types_range_types.xml:123
#, no-c-format
msgid "Cast a <varname>timestamptz</varname> to another time type"
msgstr "Convertir un <varname>timestamptz</varname>a otro tipo de tiempo"

#. Tag: varname
#: time_types_range_types.xml:124
#, no-c-format
msgid "timestamptz::timestampset"
msgstr "timestamptz::timestampset"

#. Tag: varname
#: time_types_range_types.xml:125
#, no-c-format
msgid "timestamptz::period"
msgstr "timestamptz::period"

#. Tag: varname
#: time_types_range_types.xml:126
#, no-c-format
msgid "timestamptz::periodset"
msgstr "timestamptz::periodset"

#. Tag: programlisting
#: time_types_range_types.xml:127
#, no-c-format
msgid ""
"SELECT CAST(timestamptz '2012-01-01 08:00:00' AS timestampset);\n"
"-- \"{2012-01-01 08:00:00+01}\"\n"
"SELECT CAST(timestamptz '2012-01-01 08:00:00' AS period);\n"
"-- \"[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]\"\n"
"SELECT CAST(timestamptz '2012-01-01 08:00:00' AS periodset);\n"
"-- \"{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]}\""
msgstr ""
"SELECT CAST(timestamptz '2012-01-01 08:00:00' AS timestampset);\n"
"-- \"{2012-01-01 08:00:00+01}\"\n"
"SELECT CAST(timestamptz '2012-01-01 08:00:00' AS period);\n"
"-- \"[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]\"\n"
"SELECT CAST(timestamptz '2012-01-01 08:00:00' AS periodset);\n"
"-- \"{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]}\""

#. Tag: para
#: time_types_range_types.xml:131
#, no-c-format
msgid ""
"Cast a <varname>timestampset</varname> to a <varname>periodset</varname>"
msgstr ""
"Convertir un <varname>timestampset</varname> a un "
"<varname>periodset</varname>"

#. Tag: varname
#: time_types_range_types.xml:132
#, no-c-format
msgid "timestampset::periodset"
msgstr "timestampset::periodset"

#. Tag: programlisting
#: time_types_range_types.xml:133
#, no-c-format
msgid ""
"SELECT CAST(timestampset '{2012-01-01 08:00:00, 2012-01-01 08:15:00,\n"
"  2012-01-01 08:25:00}' AS periodset);\n"
"-- \"{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01],\n"
"  [2012-01-01 08:15:00+01, 2012-01-01 08:15:00+01],\n"
"  [2012-01-01 08:25:00+01, 2012-01-01 08:25:00+01]}\""
msgstr ""
"SELECT CAST(timestampset '{2012-01-01 08:00:00, 2012-01-01 08:15:00,\n"
"  2012-01-01 08:25:00}' AS periodset);\n"
"-- \"{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01],\n"
"  [2012-01-01 08:15:00+01, 2012-01-01 08:15:00+01],\n"
"  [2012-01-01 08:25:00+01, 2012-01-01 08:25:00+01]}\""

#. Tag: para
#: time_types_range_types.xml:137
#, no-c-format
msgid "Cast a <varname>period</varname> to another time type"
msgstr "Convertir un <varname>period</varname> a otro tipo de tiempo"

#. Tag: varname
#: time_types_range_types.xml:138
#, no-c-format
msgid "period::periodset"
msgstr "period::periodset"

#. Tag: varname
#: time_types_range_types.xml:139
#, no-c-format
msgid "period::tstzrange"
msgstr "period::tstzrange"

#. Tag: programlisting
#: time_types_range_types.xml:140
#, no-c-format
msgid ""
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::periodset;\n"
"-- \"{[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)}\"\n"
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::tstzrange;\n"
"-- \"[\"2012-01-01 08:00:00+01\",\"2012-01-01 08:30:00+01\")\""
msgstr ""
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::periodset;\n"
"-- \"{[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)}\"\n"
"SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::tstzrange;\n"
"-- \"[\"2012-01-01 08:00:00+01\",\"2012-01-01 08:30:00+01\")\""

#. Tag: para
#: time_types_range_types.xml:144
#, no-c-format
msgid "Cast a <varname>tstzrange</varname> to a <varname>period</varname>"
msgstr ""
"Convertir un <varname>tstzrange</varname> a un <varname>period</varname>"

#. Tag: varname
#: time_types_range_types.xml:145
#, no-c-format
msgid "tstzrange::period"
msgstr "tstzrange::period"

#. Tag: programlisting
#: time_types_range_types.xml:146
#, no-c-format
msgid ""
"SELECT tstzrange '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::period;\n"
"-- \"[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)\""
msgstr ""
"SELECT tstzrange '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::period;\n"
"-- \"[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)\""

#. Tag: title
#: time_types_range_types.xml:152
#, no-c-format
msgid "Accessor Functions"
msgstr "Funciones de accesor"

#. Tag: varname
#: time_types_range_types.xml:156
#, no-c-format
msgid "memSize"
msgstr "memSize"

#. Tag: para
#: time_types_range_types.xml:157
#, no-c-format
msgid "Get the memory size in bytes"
msgstr "Obtener el tamaño de la memoria en bytes"

#. Tag: varname
#: time_types_range_types.xml:158
#, no-c-format
msgid "memSize({timestampset,periodset}): integer"
msgstr "memSize({timestampset,periodset}): integer"

#. Tag: programlisting
#: time_types_range_types.xml:159
#, no-c-format
msgid ""
"SELECT memSize(timestampset '{2012-01-01, 2012-01-02, 2012-01-03}');\n"
"-- 104\n"
"SELECT memSize(periodset '{[2012-01-01, 2012-01-02], [2012-01-03, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06]}');\n"
"-- 136"
msgstr ""
"SELECT memSize(timestampset '{2012-01-01, 2012-01-02, 2012-01-03}');\n"
"-- 104\n"
"SELECT memSize(periodset '{[2012-01-01, 2012-01-02], [2012-01-03, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06]}');\n"
"-- 136"

#. Tag: varname
#: time_types_range_types.xml:163
#, no-c-format
msgid "lower"
msgstr "lower"

#. Tag: para
#: time_types_range_types.xml:164
#, no-c-format
msgid "Get the lower bound"
msgstr "Obtener el límite inferior"

#. Tag: varname
#: time_types_range_types.xml:165
#, no-c-format
msgid "lower(period): timestamptz"
msgstr "lower(period): timestamptz"

#. Tag: programlisting
#: time_types_range_types.xml:166
#, no-c-format
msgid ""
"SELECT lower(period '[2011-01-01, 2011-01-05)');\n"
"-- \"2011-01-01\""
msgstr ""
"SELECT lower(period '[2011-01-01, 2011-01-05)');\n"
"-- \"2011-01-01\""

#. Tag: varname
#: time_types_range_types.xml:170
#, no-c-format
msgid "upper"
msgstr "upper"

#. Tag: para
#: time_types_range_types.xml:171
#, no-c-format
msgid "Get the upper bound"
msgstr "Obtener el límite superior"

#. Tag: varname
#: time_types_range_types.xml:172
#, no-c-format
msgid "upper(period): timestamptz"
msgstr "upper(period): timestamptz"

#. Tag: programlisting
#: time_types_range_types.xml:173
#, no-c-format
msgid ""
"SELECT upper(period '[2011-01-01, 2011-01-05)');\n"
"-- \"2011-01-05\""
msgstr ""
"SELECT upper(period '[2011-01-01, 2011-01-05)');\n"
"-- \"2011-01-05\""

#. Tag: varname
#: time_types_range_types.xml:177
#, no-c-format
msgid "lower_inc"
msgstr "lower_inc"

#. Tag: para
#: time_types_range_types.xml:178
#, no-c-format
msgid "Is the lower bound inclusive?"
msgstr "¿Es el límite inferior inclusivo?"

#. Tag: varname
#: time_types_range_types.xml:179
#, no-c-format
msgid "lower_inc(period): boolean"
msgstr "lower_inc(period): boolean"

#. Tag: programlisting
#: time_types_range_types.xml:180
#, no-c-format
msgid ""
"SELECT lower_inc(period '[2011-01-01, 2011-01-05)');\n"
"-- true"
msgstr ""
"SELECT lower_inc(period '[2011-01-01, 2011-01-05)');\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:184
#, no-c-format
msgid "upper_inc"
msgstr "upper_inc"

#. Tag: para
#: time_types_range_types.xml:185
#, no-c-format
msgid "Is the upper bound inclusive?"
msgstr "¿Es el límite superior inclusivo?"

#. Tag: varname
#: time_types_range_types.xml:186
#, no-c-format
msgid "upper_inc(period): boolean"
msgstr "upper_inc(period): boolean"

#. Tag: programlisting
#: time_types_range_types.xml:187
#, no-c-format
msgid ""
"SELECT upper_inc(period '[2011-01-01, 2011-01-05)');\n"
"-- false"
msgstr ""
"SELECT upper_inc(period '[2011-01-01, 2011-01-05)');\n"
"-- false"

#. Tag: varname
#: time_types_range_types.xml:191
#, no-c-format
msgid "duration"
msgstr "duration"

#. Tag: para
#: time_types_range_types.xml:192
#, no-c-format
msgid "Get the duration"
msgstr "Obtener el intervalo de tiempo"

#. Tag: varname
#: time_types_range_types.xml:193
#, no-c-format
msgid "duration({period,periodset}): interval"
msgstr "duration({period,periodset}): interval"

#. Tag: programlisting
#: time_types_range_types.xml:194
#, no-c-format
msgid ""
"SELECT duration(period '[2012-01-01, 2012-01-03)');\n"
"-- \"2 days\"\n"
"SELECT duration(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"3 days\""
msgstr ""
"SELECT duration(period '[2012-01-01, 2012-01-03)');\n"
"-- \"2 days\"\n"
"SELECT duration(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"3 days\""

#. Tag: varname
#: time_types_range_types.xml:198
#, no-c-format
msgid "timespan"
msgstr "timespan"

#. Tag: para
#: time_types_range_types.xml:199
#, no-c-format
msgid "Get the timespan ignoring the potential time gaps"
msgstr ""
"Obtener el intervalo de tiempo ignorando las posibles brechas de tiempo"

#. Tag: varname
#: time_types_range_types.xml:200
#, no-c-format
msgid "timespan({timestampset,periodset}): interval"
msgstr "timespan({timestampset,period,periodset}): interval"

#. Tag: programlisting
#: time_types_range_types.xml:201
#, no-c-format
msgid ""
"SELECT timespan(timestampset '{2012-01-01, 2012-01-03}');\n"
"-- \"2 days\"\n"
"SELECT timespan(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"4 days\""
msgstr ""
"SELECT timespan(timestampset '{2012-01-01, 2012-01-03}');\n"
"-- \"2 days\"\n"
"SELECT timespan(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"4 days\""

#. Tag: para
#: time_types_range_types.xml:206
#, no-c-format
msgid ""
"Get the period on which the timestamp set or period set is defined ignoring "
"the potential time gaps"
msgstr ""
"Obtener el período en el que se define el conjunto de marcas de tiempo o el "
"conjunto de períodos ignorando las posibles brechas de tiempo"

#. Tag: varname
#: time_types_range_types.xml:207
#, no-c-format
msgid "period({timestampset,periodset}): period"
msgstr "period({timestampset,periodset}): period"

#. Tag: programlisting
#: time_types_range_types.xml:208
#, no-c-format
msgid ""
"SELECT period(timestampset '{2012-01-01, 2012-01-03, 2012-01-05}');\n"
"-- \"[2012-01-01, 2012-01-05]\"\n"
"SELECT period(periodset '{[2012-01-01, 2012-01-02), [2012-01-03, 2012-01-04)}');\n"
"-- \"[2012-01-01, 2012-01-04)\""
msgstr ""
"SELECT period(timestampset '{2012-01-01, 2012-01-03, 2012-01-05}');\n"
"-- \"[2012-01-01, 2012-01-05]\"\n"
"SELECT period(periodset '{[2012-01-01, 2012-01-02), [2012-01-03, 2012-01-04)}');\n"
"-- \"[2012-01-01, 2012-01-04)\""

#. Tag: varname
#: time_types_range_types.xml:212
#, no-c-format
msgid "numTimestamps"
msgstr "numTimestamps"

#. Tag: para
#: time_types_range_types.xml:213
#, no-c-format
msgid "Get the number of different timestamps"
msgstr "Obtener el número de marcas de tiempo diferentes"

#. Tag: varname
#: time_types_range_types.xml:214
#, no-c-format
msgid "numTimestamps({timestampset,periodset}): integer"
msgstr "numTimestamps({timestampset,periodset}): integer"

#. Tag: programlisting
#: time_types_range_types.xml:215
#, no-c-format
msgid ""
"SELECT numTimestamps(timestampset '{2012-01-01, 2012-01-03, 2012-01-04}');\n"
"-- 3\n"
"SELECT numTimestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- 3"
msgstr ""
"SELECT numTimestamps(timestampset '{2012-01-01, 2012-01-03, 2012-01-04}');\n"
"-- 3\n"
"SELECT numTimestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- 3"

#. Tag: varname
#: time_types_range_types.xml:219
#, no-c-format
msgid "startTimestamp"
msgstr "startTimestamp"

#. Tag: para
#: time_types_range_types.xml:220
#, no-c-format
msgid "Get the start timestamp"
msgstr "Obtener la marca de tiempo inicial"

#. Tag: varname
#: time_types_range_types.xml:221
#, no-c-format
msgid "startTimestamp({timestampset,periodset}): timestamptz"
msgstr "startTimestamp({timestampset,periodset}): timestamptz"

#. Tag: para
#: time_types_range_types.xml:222 time_types_range_types.xml:230
#: time_types_range_types.xml:238 time_types_range_types.xml:246
#, no-c-format
msgid ""
"The function does not take into account whether the bounds are inclusive or "
"not."
msgstr "La función no tiene en cuenta si los límites son inclusivos o no."

#. Tag: programlisting
#: time_types_range_types.xml:223
#, no-c-format
msgid ""
"SELECT startTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- \"2012-01-01\""
msgstr ""
"SELECT startTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- \"2012-01-01\""

#. Tag: varname
#: time_types_range_types.xml:227
#, no-c-format
msgid "endTimestamp"
msgstr "endTimestamp"

#. Tag: para
#: time_types_range_types.xml:228
#, no-c-format
msgid "Get the end timestamp"
msgstr "Obtener la marca de tiempo final"

#. Tag: varname
#: time_types_range_types.xml:229
#, no-c-format
msgid "endTimestamp({timestampset,periodset}): timestamptz"
msgstr "endTimestamp({timestampset,periodset}): timestamptz"

#. Tag: programlisting
#: time_types_range_types.xml:231
#, no-c-format
msgid ""
"SELECT endTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- \"2012-01-05\""
msgstr ""
"SELECT endTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- \"2012-01-05\""

#. Tag: varname
#: time_types_range_types.xml:235
#, no-c-format
msgid "timestampN"
msgstr "timestampN"

#. Tag: para
#: time_types_range_types.xml:236
#, no-c-format
msgid "Get the n-th different timestamp"
msgstr "Obtener la enésima marca de tiempo diferente"

#. Tag: varname
#: time_types_range_types.xml:237
#, no-c-format
msgid "timestampN({timestampset,periodset},integer): timestamptz"
msgstr "timestampN({timestampset,periodset},integer): timestamptz"

#. Tag: programlisting
#: time_types_range_types.xml:239
#, no-c-format
msgid ""
"SELECT timestampN(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}', 3);\n"
"-- \"2012-01-04\""
msgstr ""
"SELECT timestampN(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}', 3);\n"
"-- \"2012-01-04\""

#. Tag: varname
#: time_types_range_types.xml:243
#, no-c-format
msgid "timestamps"
msgstr "timestamps"

#. Tag: para
#: time_types_range_types.xml:244
#, no-c-format
msgid "Get the different timestamps"
msgstr "Obtener las marcas de tiempo diferentes"

#. Tag: varname
#: time_types_range_types.xml:245
#, no-c-format
msgid "timestamps({timestampset,periodset}): timestampset"
msgstr "timestamps({timestampset,periodset}): timestampset"

#. Tag: programlisting
#: time_types_range_types.xml:247
#, no-c-format
msgid ""
"SELECT timestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- \"{\"2012-01-01\", \"2012-01-03\", \"2012-01-05\"}\""
msgstr ""
"SELECT timestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');\n"
"-- \"{\"2012-01-01\", \"2012-01-03\", \"2012-01-05\"}\""

#. Tag: varname
#: time_types_range_types.xml:251
#, no-c-format
msgid "numPeriods"
msgstr "numPeriods"

#. Tag: para
#: time_types_range_types.xml:252
#, no-c-format
msgid "Get the number of periods"
msgstr "Obtener el número de períodos"

#. Tag: varname
#: time_types_range_types.xml:253
#, no-c-format
msgid "numPeriods(periodset): integer"
msgstr "numPeriods(periodset): integer"

#. Tag: programlisting
#: time_types_range_types.xml:254
#, no-c-format
msgid ""
"SELECT numPeriods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- 3"
msgstr ""
"SELECT numPeriods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- 3"

#. Tag: varname
#: time_types_range_types.xml:258
#, no-c-format
msgid "startPeriod"
msgstr "startPeriod"

#. Tag: para
#: time_types_range_types.xml:259
#, no-c-format
msgid "Get the start period"
msgstr "Obtener el período inicial"

#. Tag: varname
#: time_types_range_types.xml:260
#, no-c-format
msgid "startPeriod(periodset): period"
msgstr "startPeriod(periodset): period"

#. Tag: programlisting
#: time_types_range_types.xml:261
#, no-c-format
msgid ""
"SELECT startPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- \"[2012-01-01,2012-01-03)\""
msgstr ""
"SELECT startPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- \"[2012-01-01,2012-01-03)\""

#. Tag: varname
#: time_types_range_types.xml:265
#, no-c-format
msgid "endPeriod"
msgstr "endPeriod"

#. Tag: para
#: time_types_range_types.xml:266
#, no-c-format
msgid "Get the end period"
msgstr "Obtener el período final"

#. Tag: varname
#: time_types_range_types.xml:267
#, no-c-format
msgid "endPeriod(periodset): period"
msgstr "endPeriod(periodset): period"

#. Tag: programlisting
#: time_types_range_types.xml:268
#, no-c-format
msgid ""
"SELECT endPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- \"[2012-01-05,2012-01-06)\""
msgstr ""
"SELECT endPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- \"[2012-01-05,2012-01-06)\""

#. Tag: varname
#: time_types_range_types.xml:272
#, no-c-format
msgid "periodN"
msgstr "periodN"

#. Tag: para
#: time_types_range_types.xml:273
#, no-c-format
msgid "Get the n-th period"
msgstr "Obtener el enésimo período"

#. Tag: varname
#: time_types_range_types.xml:274
#, no-c-format
msgid "periodN(periodset,integer): period"
msgstr "periodN(periodset,integer): period"

#. Tag: programlisting
#: time_types_range_types.xml:275
#, no-c-format
msgid ""
"SELECT periodN(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}', 2);\n"
"-- \"[2012-01-04,2012-01-04]\""
msgstr ""
"SELECT periodN(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}', 2);\n"
"-- \"[2012-01-04,2012-01-04]\""

#. Tag: varname
#: time_types_range_types.xml:279
#, no-c-format
msgid "periods"
msgstr "periods"

#. Tag: para
#: time_types_range_types.xml:280
#, no-c-format
msgid "Get the periods"
msgstr "Obtener los períodos"

#. Tag: varname
#: time_types_range_types.xml:281
#, no-c-format
msgid "periods(periodset): period[]"
msgstr "periods(periodset): period[]"

#. Tag: programlisting
#: time_types_range_types.xml:282
#, no-c-format
msgid ""
"SELECT periods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- \"{\"[2012-01-01,2012-01-03)\", \"[2012-01-04,2012-01-04]\", \"[2012-01-05,2012-01-06)\"}\""
msgstr ""
"SELECT periods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],\n"
"  [2012-01-05, 2012-01-06)}');\n"
"-- \"{\"[2012-01-01,2012-01-03)\", \"[2012-01-04,2012-01-04]\", \"[2012-01-05,2012-01-06)\"}\""

#. Tag: title
#: time_types_range_types.xml:288
#, no-c-format
msgid "Modification Functions"
msgstr "Funciones de modificación"

#. Tag: varname
#: time_types_range_types.xml:292
#, no-c-format
msgid "shift"
msgstr "shift"

#. Tag: para
#: time_types_range_types.xml:293
#, no-c-format
msgid "Shift the time value by an interval"
msgstr "Desplazar el valor de tiempo con un intervalo"

#. Tag: varname
#: time_types_range_types.xml:294
#, no-c-format
msgid ""
"shift({timestampset,period,periodset}): {timestampset,period,periodset}"
msgstr ""
"shift({timestampset,period,periodset}): {timestampset,period,periodset}"

#. Tag: programlisting
#: time_types_range_types.xml:295
#, no-c-format
msgid ""
"SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);\n"
"-- \"{2001-01-02, 2001-01-04, 2001-01-06}\"\n"
"SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);\n"
"-- \"[2001-01-02, 2001-01-04]\"\n"
"SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',\n"
"  '1 day'::interval);\n"
"-- \"{[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}\""
msgstr ""
"SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);\n"
"-- \"{2001-01-02, 2001-01-04, 2001-01-06}\"\n"
"SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);\n"
"-- \"[2001-01-02, 2001-01-04]\"\n"
"SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',\n"
"  '1 day'::interval);\n"
"-- \"{[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}\""

#. Tag: varname
#: time_types_range_types.xml:299
#, no-c-format
msgid "setPrecision"
msgstr "setPrecision"

#. Tag: para
#: time_types_range_types.xml:300
#, no-c-format
msgid "Round the bounds of a float range to a number of decimal places"
msgstr "Redondear los límites de un rango flotante a un número de decimales"

#. Tag: varname
#: time_types_range_types.xml:301
#, no-c-format
msgid "setPrecision(floatrange,integer): floatrange"
msgstr "setPrecision(floatrange,integer): floatrange"

#. Tag: programlisting
#: time_types_range_types.xml:302
#, no-c-format
msgid ""
"SELECT setPrecision(floatrange '[1.123456789,2.123456789)', 3);\n"
"-- \"[1.123,2.123)\"\n"
"SELECT setPrecision(floatrange '(,2.123456789]', 3);\n"
"-- \"(,2.123]\"\n"
"SELECT setPrecision(floatrange '[1.123456789, inf)', 3);\n"
"-- \"[1.123,Infinity)\""
msgstr ""
"SELECT setPrecision(floatrange '[1.123456789,2.123456789)', 3);\n"
"-- \"[1.123,2.123)\"\n"
"SELECT setPrecision(floatrange '(,2.123456789]', 3);\n"
"-- \"(,2.123]\"\n"
"SELECT setPrecision(floatrange '[1.123456789, inf)', 3);\n"
"-- \"[1.123,Infinity)\""

#. Tag: title
#: time_types_range_types.xml:308
#, no-c-format
msgid "Comparison Operators"
msgstr "Operadores de comparación"

#. Tag: para
#: time_types_range_types.xml:310
#, no-c-format
msgid ""
"The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and"
" so on) require that the left and right arguments be of the same type. "
"Excepted equality and inequality, the other comparison operators are not "
"useful in the real world but allow B-tree indexes to be constructed on time "
"types. For period values, the operators compare first the lower bound, then "
"the upper bound. For timestamp set and period set values, the operators "
"compare first the bounding periods, and if those are equal, they compare the"
" first N instants or periods, where N is the minimum of the number of "
"composing instants or periods of both values."
msgstr ""
"Los operadores de comparación (<varname>=</varname>, "
"<varname>&lt;</varname>, etc.) requieren que los argumentos izquierdo y "
"derecho sean del mismo tipo. Exceptuando la igualdad y la no igualdad, los "
"otros operadores de comparación no son útiles en el mundo real, pero "
"permiten construir índices de árbol B en tipos de tiempo. Para los valores "
"de período, los operadores comparan primero el límite inferior y luego el "
"límite superior. Para los valores de conjunto de marcas de tiempo y conjunto"
" de períodos, los operadores comparan primero los períodos delimitadores y, "
"si son iguales, comparan los primeros N instantes o períodos, donde N es el "
"mínimo del número de instantes o períodos que componen ambos valores."

#. Tag: para
#: time_types_range_types.xml:312
#, no-c-format
msgid "The comparison operators available for the time types are given next."
msgstr ""
"Los operadores de comparación disponibles para los tipos de tiempo se dan a "
"continuación."

#. Tag: varname
#: time_types_range_types.xml:316
#, no-c-format
msgid "<varname>=</varname>"
msgstr "<varname>=</varname>"

#. Tag: para
#: time_types_range_types.xml:317
#, no-c-format
msgid "Are the time values equal?"
msgstr "¿Son iguales los valores de tiempo?"

#. Tag: varname
#: time_types_range_types.xml:318
#, no-c-format
msgid "time = time: boolean"
msgstr "time = time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:319
#, no-c-format
msgid ""
"SELECT period '[2012-01-01, 2012-01-04)' = period '[2012-01-01, 2012-01-04)';\n"
"-- true"
msgstr ""
"SELECT period '[2012-01-01, 2012-01-04)' = period '[2012-01-01, 2012-01-04)';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:323
#, no-c-format
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#. Tag: para
#: time_types_range_types.xml:324
#, no-c-format
msgid "Are the time values different?"
msgstr "¿Son diferentes los valores de tiempo?"

#. Tag: varname
#: time_types_range_types.xml:325
#, no-c-format
msgid "time &lt;&gt; time: boolean"
msgstr "time &lt;&gt; time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:326
#, no-c-format
msgid ""
"SELECT period '[2012-01-01, 2012-01-04)' &lt;&gt; period '[2012-01-03, 2012-01-05)';\n"
"-- true"
msgstr "time &lt;&gt; time: boolean"

#. Tag: varname
#: time_types_range_types.xml:330
#, no-c-format
msgid "&lt;"
msgstr "&lt;"

#. Tag: para
#: time_types_range_types.xml:331
#, no-c-format
msgid "Is the first time value less than the second one?"
msgstr "¿Es el primer valor de tiempo menor que el segundo?"

#. Tag: varname
#: time_types_range_types.xml:332
#, no-c-format
msgid "time &lt; time: boolean"
msgstr "time &lt; time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:333
#, no-c-format
msgid ""
"SELECT timestampset '{2012-01-01, 2012-01-04}' &lt; timestampset '{2012-01-01, 2012-01-05}';\n"
"-- true"
msgstr ""
"SELECT timestampset '{2012-01-01, 2012-01-04}' &lt; timestampset '{2012-01-01, 2012-01-05}';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:337
#, no-c-format
msgid "&gt;"
msgstr "&gt;"

#. Tag: para
#: time_types_range_types.xml:338
#, no-c-format
msgid "Is the first time value greater than the second one?"
msgstr "¿Es el primer valor de tiempo mayor que el segundo?"

#. Tag: varname
#: time_types_range_types.xml:339
#, no-c-format
msgid "time &gt; time: boolean"
msgstr "time &gt; time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:340
#, no-c-format
msgid ""
"SELECT period '[2012-01-03, 2012-01-04)' &gt; period '[2012-01-02, 2012-01-05)';\n"
"-- true"
msgstr ""
"SELECT period '[2012-01-03, 2012-01-04)' &gt; period '[2012-01-02, 2012-01-05)';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:344
#, no-c-format
msgid "&lt;="
msgstr "&lt;="

#. Tag: para
#: time_types_range_types.xml:345
#, no-c-format
msgid "Is the first time value less than or equal to the second one?"
msgstr "¿Es el primer valor de tiempo menor o igual que el segundo?"

#. Tag: varname
#: time_types_range_types.xml:346
#, no-c-format
msgid "time &lt;= time: boolean"
msgstr "time &lt;= time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:347
#, no-c-format
msgid ""
"SELECT periodset '{[2012-01-01, 2012-01-04)}' &lt;=\n"
"  periodset '{[2012-01-01, 2012-01-05), [2012-01-06, 2012-01-07)}';\n"
"-- true"
msgstr ""
"SELECT periodset '{[2012-01-01, 2012-01-04)}' &lt;=\n"
"  periodset '{[2012-01-01, 2012-01-05), [2012-01-06, 2012-01-07)}';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:351
#, no-c-format
msgid "&gt;="
msgstr "&gt;="

#. Tag: para
#: time_types_range_types.xml:352
#, no-c-format
msgid "Is the first time value greater than or equal to the second one?"
msgstr "¿Es el primer valor de tiempo mayor o igual que el segundo?"

#. Tag: varname
#: time_types_range_types.xml:353
#, no-c-format
msgid "time &gt;= time: boolean"
msgstr "time &gt;= time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:354
#, no-c-format
msgid ""
"SELECT period '[2012-01-03, 2012-01-05)' &gt;= period '[2012-01-03, 2012-01-04)';\n"
"-- true"
msgstr ""
"SELECT period '[2012-01-03, 2012-01-05)' &gt;= period '[2012-01-03, 2012-01-04)';\n"
"-- true"

#. Tag: title
#: time_types_range_types.xml:360
#, no-c-format
msgid "Set Operators"
msgstr "Operadores de conjuntos"

#. Tag: para
#: time_types_range_types.xml:362
#, no-c-format
msgid "The set operators available for the time types are given next."
msgstr ""
"Los operadores de conjuntos disponibles para los tipos de tiempo se dan a "
"continuación."

#. Tag: varname
#: time_types_range_types.xml:366
#, no-c-format
msgid "<varname>+</varname>"
msgstr "<varname>+</varname>"

#. Tag: para
#: time_types_range_types.xml:367
#, no-c-format
msgid "Union of the time values"
msgstr "Unión de valores de tiempo"

#. Tag: varname
#: time_types_range_types.xml:368
#, no-c-format
msgid "time + time: time"
msgstr "time + time: time"

#. Tag: programlisting
#: time_types_range_types.xml:369
#, no-c-format
msgid ""
"SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +\n"
"  timestampset '{2011-01-03, 2011-01-06}';\n"
"-- \"{2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}\"\n"
"SELECT period '[2011-01-01, 2011-01-05)' + period '[2011-01-03, 2011-01-07)';\n"
"-- \"[2011-01-01, 2011-01-07)\"\n"
"SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +\n"
"  period '[2011-01-03, 2011-01-04)';\n"
"-- \"{[2011-01-01, 2011-01-05)}\""
msgstr ""
"SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +\n"
"  timestampset '{2011-01-03, 2011-01-06}';\n"
"-- \"{2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}\"\n"
"SELECT period '[2011-01-01, 2011-01-05)' + period '[2011-01-03, 2011-01-07)';\n"
"-- \"[2011-01-01, 2011-01-07)\"\n"
"SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +\n"
"  period '[2011-01-03, 2011-01-04)';\n"
"-- \"{[2011-01-01, 2011-01-05)}\""

#. Tag: varname
#: time_types_range_types.xml:373
#, no-c-format
msgid "<varname>*</varname>"
msgstr "<varname>*</varname>"

#. Tag: para
#: time_types_range_types.xml:374
#, no-c-format
msgid "Intersection of the time values"
msgstr "Intersección de valores de tiempo"

#. Tag: varname
#: time_types_range_types.xml:375
#, no-c-format
msgid "time * time: time"
msgstr "time * time: time"

#. Tag: programlisting
#: time_types_range_types.xml:376
#, no-c-format
msgid ""
"SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';\n"
"-- \"{2011-01-03}\"\n"
"SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';\n"
"-- \"[2011-01-03, 2011-01-05)\""
msgstr ""
"SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';\n"
"-- \"{2011-01-03}\"\n"
"SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';\n"
"-- \"[2011-01-03, 2011-01-05)\""

#. Tag: varname
#: time_types_range_types.xml:380
#, no-c-format
msgid "<varname>-</varname>"
msgstr "<varname>-</varname>"

#. Tag: para
#: time_types_range_types.xml:381
#, no-c-format
msgid "Difference of the time values"
msgstr "Diferencia de valores de tiempo"

#. Tag: varname
#: time_types_range_types.xml:382
#, no-c-format
msgid "time - time: time"
msgstr "time - time: time"

#. Tag: programlisting
#: time_types_range_types.xml:383
#, no-c-format
msgid ""
"SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';\n"
"-- \"[2011-01-01, 2011-01-03)\"\n"
"SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'\n"
"-- \"{[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}\"\n"
"SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -\n"
"  periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05],\n"
"  [2011-01-08, 2011-01-09]}';\n"
"-- \"{[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],\n"
"  [2011-01-07,2011-01-08), (2011-01-09,2011-01-10]}\""
msgstr ""
"SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';\n"
"-- \"[2011-01-01, 2011-01-03)\"\n"
"SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'\n"
"-- \"{[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}\"\n"
"SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -\n"
"  periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05],\n"
"  [2011-01-08, 2011-01-09]}';\n"
"-- \"{[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],\n"
"  [2011-01-07,2011-01-08), (2011-01-09,2011-01-10]}\""

#. Tag: title
#: time_types_range_types.xml:389
#, no-c-format
msgid "Topological Operators"
msgstr "Operadores topológicos"

#. Tag: para
#: time_types_range_types.xml:390
#, no-c-format
msgid "The topological operators available for the time types are given next."
msgstr ""
"A continuación se presentan los operadores topológicos disponibles para los "
"tipos de tiempo."

#. Tag: varname
#: time_types_range_types.xml:394
#, no-c-format
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#. Tag: para
#: time_types_range_types.xml:395
#, no-c-format
msgid "Do the time values overlap (have instants in common)?"
msgstr "¿Se superponen los valores de tiempo (tienen instantes en común)?"

#. Tag: varname
#: time_types_range_types.xml:396
#, no-c-format
msgid ""
"{timestampset,period,periodset} &amp;&amp; {timestampset,period,periodset}: "
"boolean"
msgstr ""
"{timestampset,period,periodset} &amp;&amp; {timestampset,period,periodset}: "
"boolean"

#. Tag: programlisting
#: time_types_range_types.xml:397
#, no-c-format
msgid ""
"SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';\n"
"-- true"
msgstr ""
"SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:401
#, no-c-format
msgid "@&gt;"
msgstr "@&gt;"

#. Tag: para
#: time_types_range_types.xml:402
#, no-c-format
msgid "Does the first time value contain the second one?"
msgstr "¿Contiene el primer valor de tiempo el segundo?"

#. Tag: varname
#: time_types_range_types.xml:403
#, no-c-format
msgid "{timestampset,period,periodset} @&gt; time: boolean"
msgstr "{timestampset,period,periodset} @&gt; time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:404
#, no-c-format
msgid ""
"SELECT period '[2011-01-01, 2011-05-01)' @&gt; period '[2011-02-01, 2011-03-01)';\n"
"-- true\n"
"SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';\n"
"-- true"
msgstr ""
"SELECT period '[2011-01-01, 2011-05-01)' @&gt; period '[2011-02-01, 2011-03-01)';\n"
"-- true\n"
"SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:408
#, no-c-format
msgid "&lt;@"
msgstr "&lt;@"

#. Tag: para
#: time_types_range_types.xml:409
#, no-c-format
msgid "Is the first time value contained by the second one?"
msgstr "¿Está el primer valor de tiempo contenido en el segundo?"

#. Tag: varname
#: time_types_range_types.xml:410
#, no-c-format
msgid "time &lt;@ {timestampset,period,periodset}: boolean"
msgstr "time &lt;@ {timestampset,period,periodset}: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:411
#, no-c-format
msgid ""
"SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';\n"
"-- true\n"
"SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';\n"
"-- true"
msgstr ""
"SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';\n"
"-- true\n"
"SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:415 time_types_range_types.xml:460
#, no-c-format
msgid "<varname>-|-</varname>"
msgstr "<varname>-|-</varname>"

#. Tag: para
#: time_types_range_types.xml:416
#, no-c-format
msgid "Is the first time value adjacent to the second one?"
msgstr "¿Es el primer valor de tiempo adyacente al segundo?"

#. Tag: varname
#: time_types_range_types.xml:417
#, no-c-format
msgid "time -|- time: boolean"
msgstr "time -|- time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:418
#, no-c-format
msgid ""
"SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';\n"
"-- true\n"
"SELECT periodset '{[2012-01-01, 2012-01-02]}' -|- period '[2012-01-02, 2012-01-03)';\n"
"-- false"
msgstr ""
"SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';\n"
"-- true\n"
"SELECT periodset '{[2012-01-01, 2012-01-02]}' -|- period '[2012-01-02, 2012-01-03)';\n"
"-- false"

#. Tag: title
#: time_types_range_types.xml:424
#, no-c-format
msgid "Relative Position Operators"
msgstr "Operadores de posición relativa"

#. Tag: para
#: time_types_range_types.xml:426
#, no-c-format
msgid ""
"In PostgreSQL, the range operators <varname>&lt;&lt;</varname>, "
"<varname>&amp;&lt;</varname>, <varname>&gt;&gt;</varname>, "
"<varname>&amp;&gt;</varname>, and <varname>-|-</varname> only accept ranges "
"as left or right argument. We extended these operators for numeric ranges so"
" that one argument may be an integer or a float."
msgstr ""
"En PostgreSQL, los operadores de rango <varname>&lt;&lt;</varname>, "
"<varname>&amp;&lt;</varname>, <varname>&gt;&gt;</varname>, "
"<varname>&amp;&gt;</varname> y <varname>-|-</varname> solo aceptan rangos "
"como argumento izquierdo o derecho. Extendimos estos operadores para rangos "
"númericos de modo que un argumento puede ser un número entero o flotante."

#. Tag: para
#: time_types_range_types.xml:428
#, no-c-format
msgid ""
"The relative position operators available for the time types and range types"
" are given next."
msgstr ""
"Los operadores de posición relativa disponibles para los tipos de tiempo y "
"tipos de rango se dan a continuación."

#. Tag: varname
#: time_types_range_types.xml:432
#, no-c-format
msgid "&lt;&lt;"
msgstr "&lt;&lt;"

#. Tag: para
#: time_types_range_types.xml:433
#, no-c-format
msgid "Is the first number or range value strictly left of the second one?"
msgstr ""
"¿Está el primer número o valor de rango estrictamente a la izquierda del "
"segundo?"

#. Tag: varname
#: time_types_range_types.xml:434
#, no-c-format
msgid "{number,range} &lt;&lt; {number,range}: boolean"
msgstr "{number,range} &lt;&lt; {number,range}: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:435
#, no-c-format
msgid ""
"SELECT intrange '[15, 20)' &lt;&lt; 20;\n"
"-- true"
msgstr ""
"SELECT intrange '[15, 20)' &lt;&lt; 20;\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:439
#, no-c-format
msgid "&gt;&gt;"
msgstr "&gt;&gt;"

#. Tag: para
#: time_types_range_types.xml:440
#, no-c-format
msgid "Is the first number or range value strictly right of the second one?"
msgstr ""
"¿Está el primer número o valor de rango estrictamente a la derecha del "
"segundo?"

#. Tag: varname
#: time_types_range_types.xml:441
#, no-c-format
msgid "{number,range} &gt;&gt; {number,range}: boolean"
msgstr "{number,range} &gt;&gt; {number,range}: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:442
#, no-c-format
msgid ""
"SELECT intrange '[15, 20)' &gt;&gt; 10;\n"
"-- true"
msgstr ""
"SELECT intrange '[15, 20)' &gt;&gt; 10;\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:446
#, no-c-format
msgid "&amp;&lt;"
msgstr "&amp;&lt;"

#. Tag: para
#: time_types_range_types.xml:447
#, no-c-format
msgid "Is the first number or range value not to the right of the second one?"
msgstr "¿No está el primer número o valor de rango a la derecha del segundo?"

#. Tag: varname
#: time_types_range_types.xml:448
#, no-c-format
msgid "{number,range} &amp;&lt; {number,range}: boolean"
msgstr "{number,range} &amp;&lt; {number,range}: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:449
#, no-c-format
msgid ""
"SELECT intrange '[15, 20)' &amp;&lt; 18;\n"
"-- false"
msgstr ""
"SELECT intrange '[15, 20)' &amp;&lt; 18;\n"
"-- false"

#. Tag: varname
#: time_types_range_types.xml:453
#, no-c-format
msgid "&amp;&gt;"
msgstr "&amp;&gt;"

#. Tag: para
#: time_types_range_types.xml:454
#, no-c-format
msgid "Is the first number or range value not to the left of the second one?"
msgstr ""
"¿No está el primer número o valor de rango a la izquierda del segundo?"

#. Tag: varname
#: time_types_range_types.xml:455
#, no-c-format
msgid "{number,range} &amp;&gt; {number,range}: boolean"
msgstr "{number,range} &amp;&gt; {number,range}: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:456
#, no-c-format
msgid ""
"SELECT period '[2011-01-01, 2011-01-03)' &amp;&gt; period '[2011-01-01, 2011-01-05)';\n"
"-- true\n"
"SELECT intrange '[15, 20)' &amp;&gt; 30;\n"
"-- true"
msgstr ""
"SELECT period '[2011-01-01, 2011-01-03)' &amp;&gt; period '[2011-01-01, 2011-01-05)';\n"
"-- true\n"
"SELECT intrange '[15, 20)' &amp;&gt; 30;\n"
"-- true"

#. Tag: para
#: time_types_range_types.xml:461
#, no-c-format
msgid "Is the first number or range value adjacent to the second one?"
msgstr "¿Es el primer número o valor de rango adyacente al segundo?"

#. Tag: varname
#: time_types_range_types.xml:462
#, no-c-format
msgid "{number,range} -|- {number,range}: boolean"
msgstr "{number,range} -|- {number,range}: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:463
#, no-c-format
msgid ""
"SELECT floatrange '[15, 20)' -|- 20;\n"
"-- true"
msgstr ""
"SELECT floatrange '[15, 20)' -|- 20;\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:467
#, no-c-format
msgid "&lt;&lt;#"
msgstr "&lt;&lt;#"

#. Tag: para
#: time_types_range_types.xml:468
#, no-c-format
msgid "Is the first time value scritly before the second one?"
msgstr "¿Es el primer valor de tiempo estrictamente anterior al segundo?"

#. Tag: varname
#: time_types_range_types.xml:469
#, no-c-format
msgid "time &lt;&lt;# time: boolean"
msgstr "time &lt;&lt;# time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:470
#, no-c-format
msgid ""
"SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';\n"
"-- true"
msgstr ""
"SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:474
#, no-c-format
msgid "#&gt;&gt;"
msgstr "#&gt;&gt;"

#. Tag: para
#: time_types_range_types.xml:475
#, no-c-format
msgid "Is the first time value strictly after the second one?"
msgstr "¿Es el primer valor de tiempo estrictamente posterior al segundo?"

#. Tag: varname
#: time_types_range_types.xml:476
#, no-c-format
msgid "time #&gt;&gt; time: boolean"
msgstr "time #&gt;&gt; time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:477
#, no-c-format
msgid ""
"SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt;\n"
"  periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';\n"
"-- true"
msgstr ""
"SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt;\n"
"  periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';\n"
"-- true"

#. Tag: varname
#: time_types_range_types.xml:481
#, no-c-format
msgid "&amp;&lt;#"
msgstr "&amp;&lt;#"

#. Tag: para
#: time_types_range_types.xml:482
#, no-c-format
msgid "Is the first time value not after the second one?"
msgstr "¿No es el primer valor de tiempo posterior al segundo?"

#. Tag: varname
#: time_types_range_types.xml:483
#, no-c-format
msgid "time &amp;&lt;# time: boolean"
msgstr "time &amp;&lt;# time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:484
#, no-c-format
msgid ""
"SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';\n"
"-- false"
msgstr ""
"SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';\n"
"-- false"

#. Tag: varname
#: time_types_range_types.xml:488
#, no-c-format
msgid "#&amp;&gt;"
msgstr "#&amp;&gt;"

#. Tag: para
#: time_types_range_types.xml:489
#, no-c-format
msgid "Is the first time value not before the second one?"
msgstr "¿No es el primer valor de tiempo anterior al segundo?"

#. Tag: varname
#: time_types_range_types.xml:490
#, no-c-format
msgid "time #&amp;&gt; time: boolean"
msgstr "time #&amp;&gt; time: boolean"

#. Tag: programlisting
#: time_types_range_types.xml:491
#, no-c-format
msgid ""
"SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';\n"
"-- true"
msgstr ""
"SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';\n"
"-- true"

#. Tag: title
#: time_types_range_types.xml:497
#, no-c-format
msgid "Aggregate Functions"
msgstr "Funciones agregadas"

#. Tag: para
#: time_types_range_types.xml:499
#, no-c-format
msgid ""
"The temporal aggregate functions generalize the traditional aggregate "
"functions. Their semantics is that they compute the value of the function at"
" every instant in the <emphasis>union</emphasis> of the temporal extents of "
"the values to aggregate. In contrast, recall that all other functions "
"manipulating time types compute the value of the function at every instant "
"in the <emphasis>intersection</emphasis> of the temporal extents of the "
"arguments."
msgstr ""
"Las funciones agregadas temporales generalizan las funciones agregadas "
"tradicionales. Su semántica es que calculan el valor de la función en cada "
"instante de la <emphasis>unión</emphasis> de las extensiones temporales de "
"los valores a agregar. En contraste, recuerde que todas las otras funciones "
"que manipulan tipos de tiempo calculan el valor de la función en cada "
"instante de la <emphasis>intersección</emphasis> de las extensiones "
"temporales de los argumentos."

#. Tag: para
#: time_types_range_types.xml:501
#, no-c-format
msgid "The temporal aggregate functions are the following ones:"
msgstr "Las funciones agregadas temporales son las siguientes:"

#. Tag: para
#: time_types_range_types.xml:503
#, no-c-format
msgid ""
"Function <varname>tcount</varname> generalizes the traditional function "
"<varname>count</varname>. The temporal count can be used to compute at each "
"point in time the number of available objects (for example, number of "
"periods). Function <varname>tcount</varname> returns a temporal integer (see"
" <xref linkend=\"temporal_types\"/>)."
msgstr ""
"La función <varname>tcount</varname> generaliza la función tradicional "
"<varname>count</varname>. El conteo temporal se puede utilizar para calcular"
" en cada momento el número de objetos disponibles (por ejemplo, el número of"
" períodos). La función <varname>tcount</varname> devuelve un entero temporal"
" (ver <xref linkend=\"temporal_types\"/>)."

#. Tag: para
#: time_types_range_types.xml:504
#, no-c-format
msgid ""
"Function <varname>extent</varname> returns a bounding period that encloses a"
" set of time values."
msgstr ""
"La función <varname>extent</varname> devuelve un período delimitador que "
"engloba un conjunto de valores de tiempo."

#. Tag: para
#: time_types_range_types.xml:507
#, no-c-format
msgid "Similarly, there is an aggregate function for range types:"
msgstr "Del mismo modo, hay una función agregada para los tipos de rango:"

#. Tag: para
#: time_types_range_types.xml:509
#, no-c-format
msgid ""
"Function <varname>extent</varname> returns a bounding range that encloses a "
"set of integer or float range values."
msgstr ""
"La función <varname>extent</varname> devuelve un rango delimitador que "
"engloba un conjunto de valores de rango."

#. Tag: para
#: time_types_range_types.xml:512
#, no-c-format
msgid ""
"Union is a very useful operation for time types. As we have seen in <xref "
"linkend=\"time_set_operators\"/>, we can compute the union of two time "
"values using the <varname>+</varname> operator. However, it is also very "
"useful to have an aggregate version of the union operator for combining an "
"arbitrary number of values. Function <varname>tunion</varname> can be used "
"for this purpose."
msgstr ""
"La unión es una operación a muy útil para los tipos de tiempo. Como hemos "
"visto en la <xref linkend=\"time_set_operators\"/>, podemos calcular la "
"unión de dos valores de tiempo usando el operador <varname>+</varname>. Sin "
"embargo, también es muy útil tener una versión agregada del operador de "
"unión para combinar un número arbitrario de valores. La función "
"<varname>tunion</varname> se puede utilizar para este propósito."

#. Tag: varname
#: time_types_range_types.xml:517
#, no-c-format
msgid "tcount"
msgstr "tcount"

#. Tag: para
#: time_types_range_types.xml:518
#, no-c-format
msgid "Temporal count"
msgstr "Conteo temporal"

#. Tag: varname
#: time_types_range_types.xml:519
#, no-c-format
msgid "tcount({timestampset,period,periodset}): {tinti,tints}"
msgstr "tcount({timestampset,period,periodset}): {tinti,tints}"

#. Tag: programlisting
#: time_types_range_types.xml:520
#, no-c-format
msgid ""
"WITH times(ts) AS (\n"
"  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION\n"
"  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION\n"
"  SELECT timestampset '{2000-01-01, 2000-01-02}'\n"
")\n"
"SELECT tcount(ts) FROM times;\n"
"-- \"{2@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-04, 1@2000-01-05, 1@2000-01-06}\"\n"
"\n"
"WITH periods(ps) AS (\n"
"  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION\n"
"  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION\n"
"  SELECT periodset '{[2000-01-02, 2000-01-06]}'\n"
")\n"
"SELECT tcount(ps) FROM periods;\n"
"-- {[2@2000-01-01, 3@2000-01-02], (2@2000-01-02, 3@2000-01-03, 3@2000-01-04],\n"
"   (1@2000-01-04, 2@2000-01-05, 2@2000-01-06]}"
msgstr ""
"WITH times(ts) AS (\n"
"  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION\n"
"  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION\n"
"  SELECT timestampset '{2000-01-01, 2000-01-02}'\n"
")\n"
"SELECT tcount(ts) FROM times;\n"
"-- \"{2@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-04, 1@2000-01-05, 1@2000-01-06}\"\n"
"\n"
"WITH periods(ps) AS (\n"
"  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION\n"
"  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION\n"
"  SELECT periodset '{[2000-01-02, 2000-01-06]}'\n"
")\n"
"SELECT tcount(ps) FROM periods;\n"
"-- {[2@2000-01-01, 3@2000-01-02], (2@2000-01-02, 3@2000-01-03, 3@2000-01-04],\n"
"   (1@2000-01-04, 2@2000-01-05, 2@2000-01-06]}"

#. Tag: varname
#: time_types_range_types.xml:524 time_types_range_types.xml:531
#, no-c-format
msgid "extent"
msgstr "extent"

#. Tag: para
#: time_types_range_types.xml:525
#, no-c-format
msgid "Bounding period"
msgstr "Período delimitador"

#. Tag: varname
#: time_types_range_types.xml:526
#, no-c-format
msgid "extent({timestampset,period,periodset}): period"
msgstr "extent({timestampset,period,periodset}): period"

#. Tag: programlisting
#: time_types_range_types.xml:527
#, no-c-format
msgid ""
"WITH times(ts) AS (\n"
"  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION\n"
"  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION\n"
"  SELECT timestampset '{2000-01-01, 2000-01-02}'\n"
")\n"
"SELECT extent(ts) FROM times;\n"
"-- \"[2000-01-01, 2000-01-06]\"\n"
"\n"
"WITH periods(ps) AS (\n"
"  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION\n"
"  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION\n"
"  SELECT periodset '{[2000-01-02, 2000-01-06]}'\n"
")\n"
"SELECT extent(ps) FROM periods;\n"
"-- \"[2000-01-01, 2000-01-06]\""
msgstr ""
"WITH times(ts) AS (\n"
"  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION\n"
"  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION\n"
"  SELECT timestampset '{2000-01-01, 2000-01-02}'\n"
")\n"
"SELECT extent(ts) FROM times;\n"
"-- \"[2000-01-01, 2000-01-06]\"\n"
"\n"
"WITH periods(ps) AS (\n"
"  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION\n"
"  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION\n"
"  SELECT periodset '{[2000-01-02, 2000-01-06]}'\n"
")\n"
"SELECT extent(ps) FROM periods;\n"
"-- \"[2000-01-01, 2000-01-06]\""

#. Tag: para
#: time_types_range_types.xml:532
#, no-c-format
msgid "Bounding range"
msgstr "Rango delimitador"

#. Tag: varname
#: time_types_range_types.xml:533
#, no-c-format
msgid "extent(range): range"
msgstr "extent(range): range"

#. Tag: programlisting
#: time_types_range_types.xml:534
#, no-c-format
msgid ""
"WITH ranges(r) AS (\n"
"  SELECT floatrange '[1, 4)' UNION\n"
"  SELECT floatrange '(5, 8)' UNION\n"
"  SELECT floatrange '(7, 9)'\n"
")\n"
"SELECT extent(r) FROM ranges;\n"
"-- \"[1,9)\""
msgstr ""
"WITH ranges(r) AS (\n"
"  SELECT floatrange '[1, 4)' UNION\n"
"  SELECT floatrange '(5, 8)' UNION\n"
"  SELECT floatrange '(7, 9)'\n"
")\n"
"SELECT extent(r) FROM ranges;\n"
"-- \"[1,9)\""

#. Tag: varname
#: time_types_range_types.xml:538
#, no-c-format
msgid "tunion"
msgstr "tunion"

#. Tag: para
#: time_types_range_types.xml:539
#, no-c-format
msgid "Temporal union"
msgstr "Unión temporal"

#. Tag: varname
#: time_types_range_types.xml:540
#, no-c-format
msgid "tunion({timestampset,period,periodset}): {timestampset,periodset}"
msgstr "tunion({timestampset,period,periodset}): {timestampset,periodset}"

#. Tag: programlisting
#: time_types_range_types.xml:541
#, no-c-format
msgid ""
"WITH times(ts) AS (\n"
"  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION\n"
"  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION\n"
"  SELECT timestampset '{2000-01-01, 2000-01-02}'\n"
")\n"
"SELECT tunion(ts) FROM times;\n"
"-- \"{2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05, 2000-01-06}\"\n"
"WITH periods(ps) AS (\n"
"  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION\n"
"  SELECT periodset '{[2000-01-02, 2000-01-03], [2000-01-05, 2000-01-06]}' UNION\n"
"  SELECT periodset '{[2000-01-07, 2000-01-08]}'\n"
")\n"
"SELECT tunion(ps) FROM periods;\n"
"-- \"{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06], [2000-01-07, 2000-01-08]}\""
msgstr ""
"WITH times(ts) AS (\n"
"  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION\n"
"  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION\n"
"  SELECT timestampset '{2000-01-01, 2000-01-02}'\n"
")\n"
"SELECT tunion(ts) FROM times;\n"
"-- \"{2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05, 2000-01-06}\"\n"
"WITH periods(ps) AS (\n"
"  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION\n"
"  SELECT periodset '{[2000-01-02, 2000-01-03], [2000-01-05, 2000-01-06]}' UNION\n"
"  SELECT periodset '{[2000-01-07, 2000-01-08]}'\n"
")\n"
"SELECT tunion(ps) FROM periods;\n"
"-- \"{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06], [2000-01-07, 2000-01-08]}\""

#. Tag: title
#: time_types_range_types.xml:548
#, no-c-format
msgid "Indexing of Time Types"
msgstr "Indexación de tipos de tiempo"

#. Tag: para
#: time_types_range_types.xml:550
#, no-c-format
msgid ""
"GiST and SP-GiST indexes can be created for table columns of the "
"<varname>timestampset</varname>, <varname>period</varname>, and "
"<varname>periodset</varname> types. An example of creation of a GiST index "
"in a column <varname>During</varname> of type <varname>period</varname> in a"
" table <varname>Reservation</varname> is as follows:"
msgstr ""
"Se pueden crear índices GiST y SP-GiST en columnas de tablas de los tipos "
"<varname>timestampset</varname>, <varname>period</varname> y "
"<varname>periodset</varname>. Un ejemplo de creación de un índice GiST en "
"una columna <varname>During</varname> de tipo <varname>period</varname> en "
"una tabla <varname>Reservation</varname> es como sigue:"

#. Tag: programlisting
#: time_types_range_types.xml:551
#, no-c-format
msgid ""
"CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,\n"
"  During period);\n"
"CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);"
msgstr ""
"CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,\n"
"  During period);\n"
"CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);"

#. Tag: para
#: time_types_range_types.xml:553
#, no-c-format
msgid ""
"A GiST or SP-GiST index can accelerate queries involving the following "
"operators: <varname>=</varname>, <varname>&amp;&amp;</varname>, "
"<varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, "
"<varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, "
"<varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname>."
msgstr ""
"Un índice GiST o SP-GiST puede acelerar las consultas que involucran a los "
"siguientes operadores: <varname>=</varname>, <varname>&amp;&amp;</varname>, "
"<varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, "
"<varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, "
"<varname>&amp;&lt;</varname> y <varname>&amp;&gt;</varname>."

#. Tag: para
#: time_types_range_types.xml:554
#, no-c-format
msgid ""
"In addition, B-tree indexes can be created for table columns of a time type."
" For these index types, basically the only useful operation is equality. "
"There is a B-tree sort ordering defined for values of time types with "
"corresponding <varname>&lt;</varname> and <varname>&gt;</varname> operators,"
" but the ordering is rather arbitrary and not usually useful in the real "
"world. The B-tree support is primarily meant to allow sorting internally in "
"queries, rather than creation of actual indexes."
msgstr ""
"Además, se pueden crear índices de árbol B para columnas de tabla de un tipo"
" de tiempo. Para estos tipos de índices, básicamente la única operación útil"
" es la igualdad. Hay un orden de clasificación de árbol B definido para "
"valores de tipos de tiempo con los correspondientes operadores "
"<varname>&lt;</varname> y <varname>&gt;</varname>, pero el orden es bastante"
" arbitrario y no suele ser útil en el mundo real. El soporte del árbol B "
"está destinado principalmente a permitir la clasificación interna en las "
"consultas, en lugar de la creación de índices reales."
