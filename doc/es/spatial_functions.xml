<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
	<sect1>
		<title>Funciones y operadores espaciales</title>
		<para>A continuación, especificamos con el símbolo &Z_support; que la función admite puntos 3D y con el  símbolo &geography_support; que la función está disponible para geografías.</para>

		<sect2>
			<title>Funciones de entrada/salida</title>

			<itemizedlist>
				<listitem id="asText">
					<indexterm><primary><varname>asText</varname></primary></indexterm>
					<para>Obtener la representación de texto conocido (Well-Known Text o WKT) &Z_support; &geography_support;</para>
					<para><varname>asText({tpoint,tpoint[],geo[]}): {text,text[]}</varname></para>
					<programlisting xml:space="preserve">
	SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
	-- "[POINT Z (0 0 0)@2012-01-01 00:00:00+00, POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
	SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);
	-- "{"POINT(0 0)","POINT(1 1)"}"
	</programlisting>
				</listitem>

				<listitem id="asEWKT">
					<indexterm><primary><varname>asEWKT</varname></primary></indexterm>
					<para>Obtener la representación extendida de texto conocido (Extended Well-Known Text o EWKT)</para>
					<para><varname>asEWKT({tpoint,tpoint[],geo[]}): {text,text[]}</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
	-- "SRID=4326;[POINT Z (0 0 0)@2012-01-01 00:00:00+00,
		POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
	SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);
	-- "{"SRID=5676;POINT(0 0)","SRID=5676;POINT(1 1)"}"
	</programlisting>
				</listitem>

				<listitem id="asMFJSON">
					<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
					<para>Obtener la representación JSON de característica móviles (Moving Features) &Z_support; &geography_support;</para>
					<para><varname>asMFJSON(tpoint,maxdecdigits integer=15,options integer=0): bytea</varname></para>
					<para>El último argumento <varname>options</varname> puede usarse para agregar BBOX y/o CRS en la salida MFJSON:</para>
					<itemizedlist>
						<listitem><para>0: significa que no hay opción (valor por defecto)</para></listitem>
						<listitem><para>1: MFJSON BBOX</para></listitem>
						<listitem><para>2: MFJSON Short CRS (e.g EPSG:4326)</para></listitem>
						<listitem><para>4: MFJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)</para></listitem>
					</itemizedlist>
					<programlisting xml:space="preserve">
	SELECT asMFJSON(tgeompoint 'Point(1 2)@2019-01-01 18:00:00.15+02');
	-- "{"type":"MovingPoint","coordinates":[1,2],"datetimes":"2019-01-01T17:00:00.15+01",
		"interpolations":["Discrete"]}"
	SELECT asMFJSON(tgeompoint 'SRID=4326;
		Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 2, 3);
	-- "{"type":"MovingPoint","crs":{"type":"name","properties":{"name":"EPSG:4326"}},
		"stBoundedBy":{"bbox":[50.81,4.38,50.81,4.38],
		"period":{"begin":"2019-01-01 17:00:00.15+01","end":"2019-01-01 17:00:00.15+01"}},
		"coordinates":[50.81,4.38],"datetimes":"2019-01-01T17:00:00.15+01",
		"interpolations":["Discrete"]}"
	</programlisting>
				</listitem>

				<listitem id="asBinary">
					<indexterm><primary><varname>asBinary</varname></primary></indexterm>
					<para>Obtener la representación binaria conocida (Well-Known Binary o WKB) &Z_support; &geography_support;</para>
					<para><varname>asBinary(tpoint): bytea</varname></para>
					<para><varname>asBinary(tpoint,endian text): bytea</varname></para>
					<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
					<programlisting xml:space="preserve">
	SELECT asBinary(tgeompoint 'Point(1 2 3)@2012-01-01');
	-- "\x0191000000000000f03f0000000000000040000000000000084000fce0136a580100"
	</programlisting>
				</listitem>

				<listitem id="asEWKB">
					<indexterm><primary><varname>asEWKB</varname></primary></indexterm>
					<para>Obtener la representación extendida binaria conocida (Extended Well-Known Binary o EWKB) &Z_support; &geography_support;</para>
					<para><varname>asEWKB(tpoint): bytea</varname></para>
					<para><varname>asEWKB(tpoint,endian text): bytea</varname></para>
					<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
					<programlisting xml:space="preserve">
	SELECT asEWKB(tgeogpoint 'SRID=7844;Point(1 2 3)@2012-01-01');
	-- "\x01f1a41e0000000000000000f03f0000000000000040000000000000084000fce0136a580100"
	</programlisting>
				</listitem>

				<listitem id="asHexEWKB">
					<indexterm><primary><varname>asHexEWKB</varname></primary></indexterm>
					<para>Obtener la representación hexadecimal extendida binaria conocida (Extended Well-Known Binary o EWKB) en formato texto &Z_support; &geography_support;</para>
					<para><varname>asHexEWKB(tpoint): text</varname></para>
					<para><varname>asHexEWKB(tpoint,endian text): text</varname></para>
					<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza NDR.</para>
					<programlisting xml:space="preserve">
	SELECT asHexEWKB(tgeompoint 'SRID=3812;Point(1 2 3)@2012-01-01');
	-- "01D1E40E0000000000000000F03F0000000000000040000000000000084000FCE0136A580100"
	</programlisting>
				</listitem>

				<listitem id="tgeompointFromText">
					<indexterm><primary><varname>tgeompointFromText</varname></primary></indexterm>
					<para>Entrar un punto temporal geométrico en una representación de texto conocido (Well-Known Text o WKT) &Z_support;</para>
					<para><varname>tgeompointFromText(text): tgeompoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompointFromText(text '[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]'));
	-- "[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]"
	</programlisting>
				</listitem>

				<listitem id="tgeogpointFromText">
					<indexterm><primary><varname>tgeogpointFromText</varname></primary></indexterm>
					<para>Entrar un punto temporal geográfico en una representación de texto conocido (Well-Known Text o WKT) &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromText(text): tgeogpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeogpointFromText(text '[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]'));
	-- "SRID=4326;[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]"
	</programlisting>
				</listitem>

				<listitem id="tgeompointFromEWKT">
					<indexterm><primary><varname>tgeompointFromEWKT</varname></primary></indexterm>
					<para>Entrar un punto temporal geométrico en una representación extendida de texto conocido (Extended Well-Known Text o EWKT) &Z_support;</para>
					<para><varname>tgeompointFromEWKT(text): tgeompoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompointFromEWKT(text 'SRID=3812;[POINT(1 2)@2000-01-01,
		POINT(3 4)@2000-01-02]'));
	-- "SRID=3812;[POINT(1 2)@2000-01-01 00:00:00+01, POINT(3 4)@2000-01-02 00:00:00+01]"
	</programlisting>
				</listitem>

				<listitem id="tgeogpointFromEWKT">
					<indexterm><primary><varname>tgeogpointFromEWKT</varname></primary></indexterm>
					<para>Entrar un punto temporal geográfico en una representación extendida de texto conocido (Extended Well-Known Text o EWKT) &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromEWKT(text): tgeogpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeogpointFromEWKT(text 'SRID=7844;[POINT(1 2)@2000-01-01,
		POINT(3 4)@2000-01-02]'));
	-- "SRID=7844;[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]"
	</programlisting>
				</listitem>

				<listitem id="tgeompointFromMFJSON">
					<indexterm><primary><varname>tgeompointFromMFJSON</varname></primary></indexterm>
					<para>Entrar un punto temporal geométrico en una representación JSON de características móviles (Moving Features) &Z_support;</para>
					<para><varname>tgeompointFromMFJSON(text): tgeompoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompointFromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
		"properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
		"datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
	-- "SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01"
	</programlisting>
				</listitem>

				<listitem id="tgeogpointFromMFJSON">
					<indexterm><primary><varname>tgeogpointFromMFJSON</varname></primary></indexterm>
					<para>Entrar un punto temporal geográfico en una representación JSON de características móviles (Moving Features) &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromMFJSON(text): tgeogpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeogpointFromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
		"properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
		"datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
	-- "SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01"
	</programlisting>
				</listitem>

				<listitem id="tgeompointFromBinary">
					<indexterm><primary><varname>tgeompointFromBinary</varname></primary></indexterm>
					<para>Entrar un punto temporal geométrico en una representación binaria conocida (WKB) &Z_support;</para>
					<para><varname>tgeompointFromBinary(bytea): tgeompoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompointFromBinary(
		'\x0181000000000000f03f0000000000000040005c6c29ffffffff'));
	-- "POINT(1 2)@2000-01-01"
	</programlisting>
				</listitem>

				<listitem id="tgeogpointFromBinary">
					<indexterm><primary><varname>tgeogpointFromBinary</varname></primary></indexterm>
					<para>Entrar un punto temporal geográfico en una representación binaria conocida (WKB) &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromBinary(bytea): tgeogpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompointFromBinary(
		'\x01b1000000000000f03f000000000000f03f000000000000f03f005c6c29ffffffff'));
	-- "SRID=4326;POINT Z (1 1 1)@2000-01-01"
	</programlisting>
				</listitem>

				<listitem id="tgeompointFromEWKB">
					<indexterm><primary><varname>tgeompointFromEWKB</varname></primary></indexterm>
					<para>Entrar un punto temporal geométrico en una representación extendida binaria conocida (EWKB) &Z_support;</para>
					<para><varname>tgeompointFromEWKB(bytea): tgeompoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompointFromEWKB(
		'\x01c1e40e0000000000000000f03f0000000000000040005c6c29ffffffff'));
	-- "SRID=3812;POINT(1 2)@2000-01-01"
	</programlisting>
				</listitem>

				<listitem id="tgeogpointFromEWKB">
					<indexterm><primary><varname>tgeogpointFromEWKB</varname></primary></indexterm>
					<para>Entrar un punto temporal geográfico en una representación extendida binaria conocida (EWKB) &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromEWKB(bytea): tgeogpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeogpointFromEWKB(
		'\x01f1a41e0000000000000000f03f000000000000f03f000000000000f03f005c6c29ffffffff'));
	-- "SRID=7844;POINT Z (1 1 1)@2000-01-01"
	</programlisting>
				</listitem>

				<listitem id="tgeompointFromHexEWKB">
					<indexterm><primary><varname>tgeompointFromHexEWKB</varname></primary></indexterm>
					<para>Entrar un punto temporal geométrico en una representación hexadecimal extendida binaria conocida (HexEWKB) &Z_support;</para>
					<para><varname>tgeompointFromHexEWKB(text): tgeompoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeompointFromHexEWKB(
		'01C1E40E0000000000000000F03F0000000000000040005C6C29FFFFFFFF'));
	-- "SRID=3812;POINT(1 2)@2000-01-01"
	</programlisting>
				</listitem>

				<listitem id="tgeogpointFromHexEWKB">
					<indexterm><primary><varname>tgeogpointFromHexEWKB</varname></primary></indexterm>
					<para>Entrar un punto temporal geográfico en una representación hexadecimal extendida binaria conocida (HexEWKB) &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromHexEWKB(text): tgeogpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(tgeogpointFromHexEWKB(
		'01F1A41E0000000000000000F03F000000000000F03F000000000000F03F005C6C29FFFFFFFF'));
	-- "SRID=7844;POINT Z (1 1 1)@2000-01-01"
	</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones de sistema de referencia espacial</title>
			<itemizedlist>
				<listitem id="tpoint_SRID">
					<indexterm><primary><varname>SRID</varname></primary></indexterm>
					<para>Obtener el identificador de referencia espacial &Z_support; &geography_support;</para>
					<para><varname>SRID(tpoint): integer</varname></para>
					<programlisting xml:space="preserve">
	SELECT SRID(tgeompoint 'Point(0 0)@2012-01-01');
	-- 0
	</programlisting>
				</listitem>

				<listitem id="tpoint_setSRID">
					<indexterm><primary><varname>setSRID</varname></primary></indexterm>
					<para>Establecer el identificador de referencia espacial &Z_support; &geography_support;</para>
					<para><varname>setSRID(tpoint): tpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)', 4326));
	-- "SRID=4326;[POINT(0 0)@2012-01-01 00:00:00+00, POINT(1 1)@2012-01-02 00:00:00+00)"
	</programlisting>
					</listitem>

				<listitem id="tpoint_transform">
					<indexterm><primary><varname>transform</varname></primary></indexterm>
					<para>Transformar a una referencia espacial diferente &Z_support; &geography_support;</para>
					<para><varname>transform(tpoint,integer): tpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2012-01-01', 3812));
	-- "SRID=3812;POINT(648679.018035303 671067.055638114)@2012-01-01 00:00:00+00"
	</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones de accessor</title>
			<itemizedlist>
				<listitem id="getX">
					<indexterm><primary><varname>getX</varname></primary></indexterm>
					<para>Obtener los valores de las coordenadas X como un número flotante temporal &Z_support; &geography_support;</para>
					<para><varname>getX(tpoint): tfloat</varname></para>
					<programlisting xml:space="preserve">
	SELECT getX(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
		Point(5 6)@2000-01-03}');
	-- "{1@2000-01-01, 3@2000-01-02, 5@2000-01-03}"
	SELECT getX(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
		Point(7 8 9)@2000-01-03]');
	-- "Interp=Stepwise;[1@2000-01-01, 4@2000-01-02, 7@2000-01-03]"
	</programlisting>
				</listitem>

				<listitem id="getY">
					<indexterm><primary><varname>getY</varname></primary></indexterm>
					<para>Obtener los valores de las coordenadas Y como un número flotante temporal &Z_support; &geography_support;</para>
					<para><varname>getY(tpoint): tfloat</varname></para>
					<programlisting xml:space="preserve">
	SELECT getY(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
		Point(5 6)@2000-01-03}');
	-- "{2@2000-01-01, 4@2000-01-02, 6@2000-01-03}"
	SELECT getY(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
		Point(7 8 9)@2000-01-03]');
	-- "Interp=Stepwise;[2@2000-01-01, 5@2000-01-02, 8@2000-01-03]"
	</programlisting>
				</listitem>

				<listitem id="getZ">
					<indexterm><primary><varname>getZ</varname></primary></indexterm>
					<para>Obtener los valores de las coordenadas Z como un número flotante temporal &Z_support; &geography_support;</para>
					<para><varname>getZ(tpoint): tfloat</varname></para>
					<programlisting xml:space="preserve">
	SELECT getZ(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
		Point(5 6)@2000-01-03}');
	-- The temporal point do not have Z dimension
	SELECT getZ(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
		Point(7 8 9)@2000-01-03]');
	-- "Interp=Stepwise;[3@2000-01-01, 6@2000-01-02, 9@2000-01-03]"
	</programlisting>
				</listitem>

				<listitem id="isSimple">
					<indexterm><primary><varname>isSimple</varname></primary></indexterm>
					<para>Devuelve verdadero si el punto temporal no se auto-intersecta espacialmente &Z_support;</para>
					<para><varname>isSimple(tpoint): boolean</varname></para>
					<para>Nótese que un punto temporal de conjunto de secuencias es simple si cada una de las secuencias que lo componen es simple.</para>
					<programlisting xml:space="preserve">
	SELECT isSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
		Point(0 0)@2000-01-03]');
	-- false
	SELECT isSimple(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
		Point(2 0 2)@2000-01-03, Point(0 0 0)@2000-01-04]');
	-- true
	SELECT isSimple(tgeompoint '{[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02],
		[Point(1 1 1)@2000-01-03, Point(0 0 0)@2000-01-04]}');
	-- true
	</programlisting>
				</listitem>

				<listitem id="length">
					<indexterm><primary><varname>length</varname></primary></indexterm>
					<para>Obtener la longitud atravesada por el punto temporal &Z_support; &geography_support;</para>
					<para><varname>length(tpoint): float</varname></para>
					<programlisting xml:space="preserve">
	SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02]');
	-- 1.73205080756888
	SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
		Point(0 0 0)@2000-01-03]');
	-- 3.46410161513775
	SELECT length(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01,
		Point(1 1 1)@2000-01-02, Point(0 0 0)@2000-01-03]');
	-- 0
	</programlisting>
				</listitem>

				<listitem id="cumulativeLength">
					<indexterm><primary><varname>cumulativeLength</varname></primary></indexterm>
					<para>Obtener la longitud acumulada atravesada por el punto temporal &Z_support; &geography_support;</para>
					<para><varname>cumulativeLength(tpoint): tfloat_seq</varname></para>
					<programlisting xml:space="preserve">
	SELECT round(cumulativeLength(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
		Point(1 0)@2000-01-03], [Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}'), 6);
	-- {[0@2000-01-01, 1.414214@2000-01-02, 2.414214@2000-01-03],
		[2.414214@2000-01-04, 3.414214@2000-01-05]}
	SELECT cumulativeLength(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01,
		Point(1 1 1)@2000-01-02, Point(0 0 0)@2000-01-03]');
	-- Interp=Stepwise;[0@2000-01-01, 0@2000-01-03]
	</programlisting>
				</listitem>

				<listitem id="speed">
					<indexterm><primary><varname>speed</varname></primary></indexterm>
					<para>Obtener la velocidad del punto temporal en unidades por segundo &Z_support; &geography_support;</para>
					<para><varname>speed(tpoint): tfloat_seqset</varname></para>
					<para>El punto temporal debe tener interpolación linear</para>
					<programlisting xml:space="preserve">
	SELECT speed(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
		Point(1 0)@2000-01-03], [Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}') * 3600 * 24;
	-- "Interp=Stepwise;{[1.4142135623731@2000-01-01, 1@2000-01-02, 1@2000-01-03],
		[1@2000-01-04, 1@2000-01-05]}"
	SELECT speed(tgeompoint 'Interp=Stepwise;[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
		Point(1 0)@2000-01-03]');
	-- ERROR:  The temporal value must have linear interpolation
	</programlisting>
				</listitem>

				<listitem id="twCentroid">
					<indexterm><primary><varname>twCentroid</varname></primary></indexterm>
					<para>Obtener el centroide ponderado en el tiempo &Z_support;</para>
					<para><varname>twCentroid(tgeompoint): point</varname></para>
					<programlisting xml:space="preserve">
	SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2012-01-01,
		Point(0 1 1)@2012-01-02, Point(0 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)}'));
	-- "POINT Z (0 0.666666666666667 0.666666666666667)"
	</programlisting>
				</listitem>

				<listitem id="azimuth">
					<indexterm><primary><varname>azimuth</varname></primary></indexterm>
					<para>Obtener el acimut temporal &Z_support; &geography_support;</para>
					<para><varname>azimuth(tpoint): tfloat</varname></para>
					<programlisting xml:space="preserve">
	SELECT degrees(azimuth(tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02,
		Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)'));
	-- "Interp=Stepwise;{[45@2012-01-01, 45@2012-01-02], [225@2012-01-03, 225@2012-01-04)}"
	</programlisting>
				</listitem>

				<listitem id="bearing">
					<indexterm><primary><varname>bearing</varname></primary></indexterm>
					<para>Obtener el rumbo temporal &Z_support; &geography_support;</para>
					<para><varname>bearing({tpoint, point}, {tpoint, point}): tfloat</varname></para>
					<programlisting xml:space="preserve">
	SELECT degrees(bearing(tgeompoint '[Point(1 1)@2012-01-01, Point(3 3)@2012-01-03]',
		geometry 'Point(2 2)'));
	-- [45@2012-01-01, 0@2012-01-02, 225@2012-01-03]
	SELECT round(degrees(bearing(tgeompoint '[Point(0 0)@2012-01-01, Point(2 0)@2012-01-03]',
		tgeompoint '[Point(2 1)@2012-01-01, Point(0 1)@2012-01-03]')), 3);
	--  [63.435@2012-01-01, 0@2012-01-02, 296.565@2012-01-03]
	SELECT round(degrees(bearing(tgeompoint '[Point(2 1)@2012-01-01, Point(0 1)@2012-01-03]',
		tgeompoint '[Point(0 0)@2012-01-01, Point(2 0)@2012-01-03]')), 3);
	-- [243.435@2012-01-01, 116.565@2012-01-03]
	</programlisting>
					<para>Tenga en cuenta que esta función actualmente no acepta dos puntos geográficos temporales.</para>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones de manipulación</title>
			<itemizedlist>
				<listitem id="tpoint_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Redondear los valores de las coordenadas a un número de decimales &Z_support; &geography_support;</para>
					<para><varname>round(tpoint,integer): tpoint</varname></para>
					<programlisting xml:space="preserve">
	SELECT asText(round(tgeompoint '{Point(1.12345 1.12345 1.12345)@2000-01-01,
		Point(2 2 2)@2000-01-02, Point(1.12345 1.12345 1.12345)@2000-01-03}', 2));
	-- "{POINT Z (1.12 1.12 1.12)@2000-01-01, POINT Z (2 2 2)@2000-01-02,
		POINT Z (1.12 1.12 1.12)@2000-01-03}"
	SELECT asText(round(tgeogpoint 'Point(1.12345 1.12345)@2000-01-01', 2));
	-- "POINT(1.12 1.12)@2000-01-01"
	</programlisting>
				</listitem>

				<listitem id="makeSimple">
					<indexterm><primary><varname>makeSimple</varname></primary></indexterm>
					<para>Devuelve una matriz de fragmentos del punto temporal que son simples &Z_support;</para>
					<para><varname>makeSimple(tpoint): tgeompoint[]</varname></para>
					<programlisting xml:space="preserve">
	SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
		Point(0 0)@2000-01-03]'));
	-- {"[POINT(0 0)@2000-01-01, POINT(1 1)@2000-01-02)",
		 "[POINT(1 1)@2000-01-02, POINT(0 0)@2000-01-03]"}
	SELECT asText(makeSimple(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
		Point(2 0 2)@2000-01-03, Point(0 0 0)@2000-01-04]'));
	-- {"[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02, POINT Z (2 0 2)@2000-01-03,
		 POINT Z (0 0 0)@2000-01-04]"}
	SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
		Point(0 1)@2000-01-03, Point(1 0)@2000-01-04]'));
	-- {"[POINT(0 0)@2000-01-01, POINT(1 1)@2000-01-02, POINT(0 1)@2000-01-03)",
		 "[POINT(0 1)@2000-01-03, POINT(1 0)@2000-01-04]"}
	SELECT asText(makeSimple(tgeompoint '{[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02],
		[Point(1 1 1)@2000-01-03, Point(0 0 0)@2000-01-04]}'));
	-- {"{[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02],
		 [POINT Z (1 1 1)@2000-01-03, POINT Z (0 0 0)@2000-01-04]}"}
	</programlisting>
				</listitem>

				<listitem id="simplify">
					<indexterm><primary><varname>simplify</varname></primary></indexterm>
					<para>Simplificar un punto temporal usando una generalización del <ulink url="https://es.wikipedia.org/wiki/Algoritmo_de_Ramer%E2%80%93Douglas%E2%80%93Peucker">algoritmo de Douglas-Peucker</ulink> &Z_support;</para>
					<para><varname>simplify(tpoint,distance float): tpoint</varname></para>
					<para><varname>simplify(tpoint,distance float,speed float): tpoint</varname></para>
					<para>La primera versión elimina los puntos cuya distancia es menor que la distancia pasada como segundo argumento, que se especifica en las unidades del sistema de coordenadas. La segunda versión elimina los puntos cuya distancia es menor que la distancia pasada como segundo argumento siempre que la diferencia de velocidad entre el punto y el punto correspondiente en la versión simplificada sea menor que la velocidad pasada como tercer argumento, que se especifica en unidades por segundo. Observe que la simplificación se aplica sólo a secuencias temporales o conjuntos de secuencias con interpolación lineal. En todos los demás casos, se devuelve una copia del punto temporal dado.</para>

					<programlisting xml:space="preserve">
	-- Solo distancia especificada
	SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
		Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
		Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 1.5)));
	-- "LINESTRING(0 4,1 1,4 3,5 0,6 4)"
	SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
		Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
		Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 2)));
	-- "LINESTRING(0 4,5 0,6 4)"
	SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
		Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
		Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4)));
	-- "LINESTRING(0 4,6 4)"

	-- Solo diferencia de velocidad especificada
	SELECT round(speed(tgeompoint '[Point(0 4)@2000-01-01, Point(1 1)@2000-01-02,
		Point(2 3)@2000-01-03, Point(3 1)@2000-01-04, Point(4 3)@2000-01-05,
		Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]') * 1e5, 2);
	-- "Interp=Stepwise;[3.66@2000-01-01, 2.59@2000-01-02, 3.66@2000-01-05,
		4.77@2000-01-06, 4.77@2000-01-07]"

	-- Se especifican tanto la distancia como la diferencia de velocidad
	SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
		Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
		Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 1 / 1e5)));
	-- "LINESTRING(0 4,1 1,2 3,3 1,4 3,5 0,6 4)"
	SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
		Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
		Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 2 / 1e5)));
	-- "LINESTRING(0 4,1 1,5 0,6 4)"
	SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
		Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
		Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 3 / 1e5)));
	-- "LINESTRING(0 4,6 4)"
	</programlisting>
					<para>Un uso típico de la función <varname>simplify</varname> es reducir el tamaño de un conjunto de datos, en particular con fines de visualización.</para>
				</listitem>

				<listitem id="geoMeasure">
					<indexterm><primary><varname>geoMeasure</varname></primary></indexterm>
					<para>Construir una geometría/geografía con medida M a partir de un punto temporal y un número flotante temporal &Z_support; &geography_support;</para>
					<para><varname>geoMeasure(tpoint,tfloat,segmentize=false): geo</varname></para>
					<para>El último argumento <varname>segmentize</varname> establece si el valor resultado ya sea es un <varname>Linestring M</varname> o un <varname>MultiLinestring M</varname> donde cada componente es un segmento de dos puntos.</para>

					<programlisting xml:space="preserve">
	SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2000-01-01,
		Point(2 2 2)@2000-01-02}', '{5@2000-01-01, 5@2000-01-02}'));
	-- "MULTIPOINT ZM (1 1 1 5,2 2 2 5)"
	SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
		[Point(1 1)@2000-01-03, Point(1 1)@2000-01-04]}',
		'{[5@2000-01-01, 5@2000-01-02],[7@2000-01-03, 7@2000-01-04]}'));
	-- "GEOMETRYCOLLECTION M (LINESTRING M (1 1 5,2 2 5),POINT M (1 1 7))"
	SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2000-01-01,
		Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]',
		'[5@2000-01-01, 7@2000-01-02, 5@2000-01-03]', true));
	-- "MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))"
	</programlisting>
					<para>Una visualización típica de los datos de movilidad es mostrar en un mapa la trayectoria del objeto móvil utilizando diferentes colores según la velocidad. La <xref linkend="figspeed" /> muestra el resultado de la consulta a continuación usando una rampa de color en QGIS.</para>
					<programlisting xml:space="preserve">
	WITH Temp(t) AS (
		SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-05,
			Point(2 0)@2012-01-08, Point(3 1)@2012-01-10, Point(4 0)@2012-01-11]'
	)
	SELECT ST_AsText(geoMeasure(t, round(speed(t) * 3600 * 24, 2), true))
	FROM Temp;
	-- "MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),
		(3 1 1.41,4 0 1.41))"
	</programlisting>
					<para>La siguiente expresión se usa en QGIS para lograr esto. La función <varname>scale_linear</varname> transforma el valor M de cada segmento componente al rango [0, 1]. Este valor luego se pasa a la función <varname>ramp_color</varname>.</para>
					<programlisting xml:space="preserve">
	ramp_color(
		'RdYlBu',
		scale_linear(
			m(start_point(geometry_n($geometry,@geometry_part_num))),
			0, 2, 0, 1)
	)
	</programlisting>
					<figure id="figspeed" float="start">
						<title>Visualización de la velocidad de un objeto móvil usando una rampa de color en QGIS.</title>
						<mediaobject>
							<imageobject><imagedata scale='30' fileref='../images/speed.png'/></imageobject>
						</mediaobject>
					</figure>
				</listitem>

				<listitem id="asMVTGeom">
					<indexterm><primary><varname>asMVTGeom</varname></primary></indexterm>
					<para>Transformar un punto geométrico temporal en el espacio de coordenadas de un Mapbox Vector Tile. El resultado es un par compuesto de un valor <varname>geometry</varname> y una matriz de valores de marca de tiempo asociados codificados como época de Unix &Z_support;</para>
					<para><varname>asMVTGeom(tpoint,bounds,extent=4096,buffer=256,clip=TRUE): geom_times</varname></para>
					<para>Los parámetros son los siguientes:</para>
					<itemizedlist>
						<listitem><para><varname>tpoint</varname> es el punto temporal para transformar</para></listitem>
						<listitem><para><varname>bounds</varname> es un <varname>stbox</varname> que define los límites geométricos del contenido del mosaico sin búfer</para></listitem>
						<listitem><para><varname>extent</varname> es la extensión del mosaico en el espacio de coordenadas del mosaico</para></listitem>
						<listitem><para><varname>buffer</varname> es la distancia del búfer en el espacio de coordenadas de mosaico</para></listitem>
						<listitem><para><varname>clip</varname> es un booleano que determina si las geometrías resultantes y las marcas de tiempo deben recortarse o no</para></listitem>
					</itemizedlist>
					<programlisting xml:space="preserve">
	SELECT ST_AsText((mvt).geom), (mvt).times
	FROM (SELECT asMVTGeom(tgeompoint '[Point(0 0)@2000-01-01, Point(100 100)@2000-01-02]',
		stbox 'STBOX((40,40),(60,60))') AS mvt ) AS t;
	-- LINESTRING(-256 4352,4352 -256) | {946714680,946734120}
	SELECT ST_AsText((mvt).geom), (mvt).times
	FROM (SELECT asMVTGeom(tgeompoint '[Point(0 0)@2000-01-01, Point(100 100)@2000-01-02]',
		stbox 'STBOX((40,40),(60,60))', clip:=false) AS mvt ) AS t;
	-- LINESTRING(-8192 12288,12288 -8192) | {946681200,946767600}
	</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Funciones y operadores de distancia</title>

			<itemizedlist>
				<listitem id="smallest_distance">
					<indexterm><primary><varname>|=|</varname></primary></indexterm>
					<para>Obtener la distancia más pequeña que haya existido &Z_support; &geography_support;</para>
					<para><varname>{geo,tpoint} |=| {geo,tpoint}: float</varname></para>
					<programlisting xml:space="preserve">
SELECT tgeompoint '[Point(0 0)@2012-01-02, Point(1 1)@2012-01-04, Point(0 0)@2012-01-06)'
  |=| geometry 'Linestring(2 2,2 1,3 1)';
-- 1
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03, Point(0 0)@2012-01-05)'
  |=| tgeompoint '[Point(2 0)@2012-01-02, Point(1 1)@2012-01-04, Point(2 2)@2012-01-06)';
-- 0.5
SELECT tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
  Point(0 0 0)@2012-01-05)' |=| tgeompoint '[Point(2 0 0)@2012-01-02,
  Point(1 1 1)@2012-01-04, Point(2 2 2)@2012-01-06)';
-- 0.5
SELECT tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01, Point(3 1)@2000-01-03]' |=|
  geometry 'Linestring(1 3,2 2,3 3)';
-- 1.4142135623731
</programlisting>
					<para>El operador <varname>|=|</varname> se puede utilizar para realizar una búsqueda de vecino más cercano utilizando un índice GiST o SP-GIST (ver la <xref linkend="operators_temporal_types" />). Esta función corresponde a la función <varname>ST_DistanceCPA</varname> proporcionada por PostGIS, aunque este última requiere que ambos argumentos sean una trayectoria.</para>
					<programlisting xml:space="preserve">
SELECT ST_DistanceCPA(
  tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
    Point(0 0 0)@2012-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
    Point(2 2 2)@2012-01-06)'::geometry);
-- 0.5
</programlisting>
				</listitem>

				<listitem id="nearestApproachInstant">
					<indexterm><primary><varname>nearestApproachInstant</varname></primary></indexterm>
					<para>Obtener el instante del primer punto temporal en el que los dos argumentos están a la distancia más cercana &Z_support; &geography_support;</para>
					<para><varname>nearestApproachInstant({geo,tpoint},{geo,tpoint}): tpoint</varname></para>
					<para>La función sólo devuelve el primer instante que encuentre si hay más de uno. El instante resultante puede tener un límite exclusivo.</para>
					<programlisting xml:space="preserve">
	SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,
		Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
	-- "POINT(2 1)@2000-01-02"
	SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
		Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
	-- "POINT(1 1)@2000-01-01"
	SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,
		Point(2 2)@2000-01-03]', tgeompoint '(Point(1 1)@2000-01-01, Point(4 1)@2000-01-03]'));
	-- "POINT(1 1)@2000-01-01"
	SELECT asText(nearestApproachInstant(tgeompoint '[Point(0 0 0)@2012-01-01,
		Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-05)', tgeompoint
		'[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, Point(2 2 2)@2012-01-06)'));
	-- "POINT Z (0.75 0.75 0.75)@2012-01-03 12:00:00+00"
	</programlisting>
					<para>La función <varname>nearestApproachInstant</varname> generaliza the la función PostGIS <varname>ST_ClosestPointOfApproach</varname>. Primero, la última función requiere que ambos argumentos sean trayectorias. Segundo, la función <varname>nearestApproachInstant</varname> devuelve tanto el punto como la marca de tiempo del punto de aproximación más cercano, mientras que la función PostGIS sólo proporciona la marca de tiempo como se muestra a continuación.</para>
					<programlisting xml:space="preserve">
	SELECT to_timestamp(ST_ClosestPointOfApproach(
		tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
			Point(0 0 0)@2012-01-05)'::geometry,
		tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
			Point(2 2 2)@2012-01-06)'::geometry));
	-- "2012-01-03 12:00:00+00"
	</programlisting>
				</listitem>

				<listitem id="shortestLine">
					<indexterm><primary><varname>shortestLine</varname></primary></indexterm>
					<para>Obtener la línea que conecta el punto de aproximación más cercano &Z_support; &geography_support;</para>
					<para><varname>shortestLine({geo,tpoint},{geo,tpoint}): geo</varname></para>
					<para>La función sólo devolverá la primera línea que encuentre si hay más de una.</para>
					<programlisting xml:space="preserve">
	SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2000-01-01,
		Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
	-- "LINESTRING(2 1,2 2)"
	SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
		Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
	-- "LINESTRING(1 1,2 2)"
	SELECT ST_AsText(shortestLine(
		tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
			Point(0 0 0)@2012-01-05)',
		tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
			Point(2 2 2)@2012-01-06)'));
	-- "LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)"
	</programlisting>
					<para>La función <varname>shortestLine</varname> se puede utilizar para obtener el resultado proporcionado por la función PostGIS <varname>ST_CPAWithin</varname> cuando ambos argumentos son trayectorias como se muestra a continuación.</para>
					<programlisting xml:space="preserve">
	SELECT ST_Length(shortestLine(
		tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
			Point(0 0 0)@2012-01-05)',
		tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
			Point(2 2 2)@2012-01-06)')) &lt;= 0.5;
	-- true
	SELECT ST_CPAWithin(
		tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
			Point(0 0 0)@2012-01-05)'::geometry,
		tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
			Point(2 2 2)@2012-01-06)'::geometry, 0.5);
	-- true
	</programlisting>
				</listitem>
			</itemizedlist>

			<para>El operador de distancia temporal, denotado <varname>&lt;-&gt;</varname>, calcula la distancia en cada instante de la intersección de las extensiones temporales de sus argumentos y da como resultado un número flotante temporal. Calcular la distancia temporal es útil en muchas aplicaciones de movilidad. Por ejemplo, un grupo en movimiento (también conocido como convoy o bandada) se define como un conjunto de objetos que se mueven cerca unos de otros durante un intervalo de tiempo prolongado. Esto requiere calcular la distancia temporal entre dos objetos en movimiento.</para>

			<para>El operador de distancia temporal acepta una geometría/geografía restringida a un punto o un punto temporal como argumentos. Observe que los tipos temporales sólo consideran la interpolación lineal entre valores, mientras que la distancia es una raíz de una función cuadrática. Por lo tanto, el operador de distancia temporal proporciona una aproximación lineal del valor de distancia real para los puntos de secuencia temporal. En este caso, los argumentos se sincronizan en la dimensión de tiempo y para cada uno de los segmentos de línea que componen los argumentos, se calcula la distancia espacial entre el punto inicial, el punto final y el punto de aproximación más cercano, como se muestra en los ejemplos a continuación.</para>

			<itemizedlist>
				<listitem id="distance">
					<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
					<para>Obtener la distancia temporal &Z_support; &geography_support;</para>
					<para><varname>{point,tpoint} &lt;-&gt; {point,tpoint}: tfloat</varname></para>
					<programlisting xml:space="preserve">
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;
  geometry 'Point(0 1)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;
  tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 1)@2012-01-01, Point(0 0)@2012-01-03)' &lt;-&gt;
  tgeompoint '[Point(0 0)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)' &lt;-&gt;
  tgeompoint '[Point(0 1)@2012-01-01, Point(1 2)@2012-01-02)';
-- "[1@2012-01-01,1@2012-01-02)"
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="spatial_relationships_temporal_points">
			<title>Relaciones espaciales</title>

			<para>Las relaciones topológicas como <varname>ST_Intersects</varname> y las relaciones de distancia como <varname>ST_DWithin</varname> pueden ser generalizadas a los puntos temporales. Los argumentos de estas funciones generalizadas son un punto temporal y un tipo base (es decir, un <varname>geometry</varname> o un <varname>geography</varname>) o dos puntos temporales. Además, ambos argumentos deben ser del mismo tipo base, es decir, estas funciones no permiten merzclar un punto de geometría temporal (o una geometría) y un punto de geografía temporal (o una geografía).</para>

			<para>Hay dos versiones de las relaciones espaciales:</para>
			<itemizedlist>
				<listitem>
					<para>Las <emphasis>relaciones alguna vez</emphasis> determinan determinan si la relación topológica o de distancia se satisface alguna vez (ver <xref linkend="ever_always_comparison" />) y resultan en un <varname>boolean</varname>. Ejemplos son las funciones <varname>intersects</varname> y <varname>dwithin</varname>.</para>
				</listitem>

				<listitem>
					<para>Las <emphasis>relaciones temporales</emphasis> calculan la función topológica o de distancia en cada instante y dan como resultado un <varname>tbool</varname>. Ejemplos son las funciones <varname>tintersects</varname> y <varname>tdwithin</varname>.</para>
				</listitem>
			</itemizedlist>

			<para>
				Por ejemplo, la siguiente consulta
			</para>
			<programlisting xml:space="preserve">
SELECT intersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(0 2)@2012-01-01, Point(4 2)@2012-01-05)');
-- t
</programlisting>
			<para>
				determina si el punto temporal se cruza alguna vez con la geometría. En este caso, la consulta es equivalente a la siguiente
			</para>
			<programlisting xml:space="preserve">
SELECT ST_Intersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  geometry 'Linestring(0 2,4 2)');
</programlisting>
			<para>
				donde la segunda geometría se obtiene aplicando la función <varname>trajectory</varname> al punto temporal. Por otro lado, la consulta
			</para>
			<programlisting xml:space="preserve">
SELECT tintersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(0 2)@2012-01-01, Point(4 2)@2012-01-05)');
-- {[f@2012-01-01, t@2012-01-02, t@2012-01-04], (f@2012-01-04, f@2012-01-05)}
</programlisting>
			<para>
				calcula en cada instante si el punto temporal se cruza con la geometría. Del mismo modo, la siguiente consulta
			</para>
			<programlisting xml:space="preserve">
SELECT dwithin(tgeompoint '[Point(3 1)@2012-01-01, Point(5 1)@2012-01-03)',
  tgeompoint '[Point(3 1)@2012-01-01, Point(1 1)@2012-01-03)', 2);
-- t
</programlisting>
			<para>
				determina si la distancia entre los puntos temporales es alguna vez menor o igual a 2, mientras que la siguiente consulta
			</para>
			<programlisting xml:space="preserve">
SELECT tdwithin(tgeompoint '[Point(3 1)@2012-01-01, Point(5 1)@2012-01-03)',
  tgeompoint '[Point(3 1)@2012-01-01, Point(1 1)@2012-01-03)', 2);
-- {[t@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03)}
</programlisting>
			<para>
				calcula en cada instante si la distancia entre los puntos temporales es menor o igual a 2.
			</para>

			<para>
				Las relaciones alguna vez se utilizan normalmente en combinación con un índice espacio-temporal al calcular las relaciones temporales. Por ejemplo, la siguiente consulta
			</para>
			<programlisting xml:space="preserve">
SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
WHERE intersects(T.Trip, R.Geom)
</programlisting>
			<para>
				que verifica si un viaje <varname>T</varname> (que es un punto temporal) se cruza con una región <varname>R</varname> (que es una geometría) beneficiará de un índice espacio-temporal en la columna <varname>T.Trip</varname> dado que la función <varname>intersects</varname> realiza automáticamente la comparación del cuadro delimitador <varname>T.Trip &amp;&amp; R.Geom</varname>. Esto se explica más adelante en este documento.
			</para>

			<para>No todas las relaciones espaciales disponibles en PostGIS tienen una generalización significativa para los puntos temporales. Se define una versión generalizada de las siguientes relaciones para los puntos geométricos temporales: <varname>intersects</varname>, <varname>disjoint</varname>, <varname>dwithin</varname>, <varname>contains</varname>, y <varname>touches</varname>, mientras que para los puntos geográficos temporales solo se definen las tres primeras. Además, no todas las combinaciones de parámetros son significativas para una función generalizada dada. Por ejemplo, mientras que <varname>tcontains(geometry,tpoint)</varname> es significativo, <varname>tcontains(tpoint,geometry)</varname> es significativo solo cuando la geometría es un solo punto, y <varname>tcontains(tpoint,tpoint)</varname> es equivalente a <varname>tintersects(tpoint, geometry)</varname>. Por esta razón, solo se define la primera combinación de parámetros para <varname>contains</varname> y <varname>tcontains</varname>.</para>

			<para>Finalmente, cabe destacar que las relaciónes temporales permiten mezclar geometrías 2D/3D pero en ese caso, el cálculo sólo se realiza en 2D.</para>
		</sect2>

		<sect2>
			<title>Relaciones espaciales alguna vez</title>
			<para>Todas estas funciones incluyen automáticamente una comparación de cuadro delimitador que hace uso de cualquier índice espacial que esté disponible en los argumentos.</para>
			<itemizedlist>
				<listitem id="contains">
					<indexterm><primary><varname>contains</varname></primary></indexterm>
					<para>Contiene alguna vez</para>
					<para><varname>contains({geo,tgeompoint},{geo,tgeompoint}): boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="disjoint">
					<indexterm><primary><varname>disjoint</varname></primary></indexterm>
					<para>Está disjunto alguna vez &Z_support; &geography_support;</para>
					<para><varname>disjoint({geo,tgeompoint},{geo,tgeompoint}): boolean</varname></para>
						<programlisting xml:space="preserve">
SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
SELECT disjoint(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 0)@2012-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="dwithin">
					<indexterm><primary><varname>dwithin</varname></primary></indexterm>
					<para>Está alguna vez a distancia de &Z_support; &geography_support;</para>
					<para><varname>dwithin({geo,tpoint},{geo,tpoint},float): boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT dwithin(geometry 'Point(1 1 1)',
  tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 0)@2000-01-02]', 1);
-- true
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02]', 1);
-- false
</programlisting>
				</listitem>

				<listitem id="intersects">
					<indexterm><primary><varname>intersects</varname></primary></indexterm>
					<para>Intersecta alguna vez &Z_support; &geography_support;</para>
					<para><varname>intersects({geo,tpoint},{geo,tpoint}): boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- false
SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="touches">
					<indexterm><primary><varname>touches</varname></primary></indexterm>
					<para>Toca alguna vez</para>
					<para><varname>touches({geo,tgeompoint},{geo,tgeompoint}): boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2012-01-01, Point(0 1)@2012-01-03)');
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Relaciones espaciales temporales</title>
			<para>Un requisito común con respecto a las relaciones espaciales temporales es restringir el resultado de la relación a los instantes en que el valor del resultado es verdadero (alternativamente, falso). Por ejemplo, la siguiente consulta calcula para cada viaje el tiempo dedicado viajando en el municipio de Bruselas.</para>
					<programlisting xml:space="preserve">
SELECT TripId, duration(atValue(tintersects(T.trip, M.geom), True))
FROM Trips T, Municipality M
WHERE M.Name = "Brussels" AND atValue(tintersects(T.trip, M.geom), True) IS NOT NULL;
</programlisting>
			<para>Para simplificar la escritura de consultas, las relaciones espaciales temporales tienen un último parámetro opcional, que si se proporciona aplica la función <varname>atValue</varname> (ver <xref linkend="restriction_functions" />) al resultado de la relación. De esta forma, la consulta anterior se puede escribir de la siguiente manera.</para>
					<programlisting xml:space="preserve">
SELECT TripId, duration(tintersects(T.trip, M.geom, True))
FROM Trips T, Municipality M
WHERE M.Name = "Brussels" AND tintersects(T.trip, M.geom, True) IS NOT NULL;
</programlisting>
			<itemizedlist>
				<listitem id="tcontains">
					<indexterm><primary><varname>tcontains</varname></primary></indexterm>
					<para>Contiene temporal</para>
					<para><varname>tcontains(geometry,tgeompoint): tbool</varname></para>
					<para><varname>tcontains(geometry,tgeompoint,atValue boolean): tbool</varname></para>
					<programlisting xml:space="preserve">
SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
  tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, f@2012-01-02], (t@2012-01-02, f@2012-01-03, f@2012-01-04)}"
</programlisting>
				</listitem>

				<listitem id="tdisjoint">
					<indexterm><primary><varname>tdisjoint</varname></primary></indexterm>
					<para>Disjunto temporal &Z_support; &geography_support;</para>
					<para><varname>tdisjoint({geo,tpoint},{geo,tpoint}): tbool</varname></para>
					<para><varname>tdisjoint({geo,tpoint},{geo,tpoint},atValue boolean): tbool</varname></para>
					<para>La función solo admite 3D o geografías para dos puntos temporales</para>
					<programlisting xml:space="preserve">
SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
  tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-03], (t@2012-01-03, t@2012-01-04]}"
SELECT tdisjoint(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
  tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[t@2012-01-01, f@2012-01-03], (t@2012-01-03, t@2012-01-05)}"
</programlisting>
				</listitem>

				<listitem id="tdwithin">
					<indexterm><primary><varname>tdwithin</varname></primary></indexterm>
					<para>Está a distancia de temporal &Z_support;</para>
					<para><varname>tdwithin({geompoint,tgeompoint},{geompoint,tgeompoint},float): tbool</varname></para>
					<para><varname>tdwithin({geompoint,tgeompoint},{geompoint,tgeompoint},float,atValue boolean): tbool</varname></para>
					<para>La función solo admite 3D para dos puntos temporales</para>
					<programlisting xml:space="preserve">
SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
  tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 1);
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
SELECT tdwithin(tgeompoint '[Point(1 0)@2000-01-01, Point(1 4)@2000-01-05]',
  tgeompoint 'Interp=Stepwise;[Point(1 2)@2000-01-01, Point(1 3)@2000-01-05]', 1);
-- "{[f@2000-01-01, t@2000-01-02, t@2000-01-04], (f@2000-01-04, t@2000-01-05]}"
</programlisting>
				</listitem>

				<listitem id="tintersects">
					<indexterm><primary><varname>tintersects</varname></primary></indexterm>
					<para>Intersección temporal &Z_support; &geography_support;</para>
					<para><varname>tintersects({geo,tpoint},{geo,tpoint}): tbool</varname></para>
					<para><varname>tintersects({geo,tpoint},{geo,tpoint},atValue boolean): tbool</varname></para>
					<para>La función solo admite 3D o geografías para dos puntos temporales</para>
					<programlisting xml:space="preserve">
SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',
  tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, t@2012-01-03],
  (f@2012-01-03, f@2012-01-04]}"
SELECT tintersects(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
  tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}"
</programlisting>
				</listitem>

				<listitem id="ttouches">
					<indexterm><primary><varname>ttouches</varname></primary></indexterm>
					<para>Toca temporal</para>
					<para><varname>ttouches({geo,tgeompoint},{geo,tgeompoint}): tbool</varname></para>
					<para><varname>ttouches({geo,tgeompoint},{geo,tgeompoint},atValue boolean): tbool</varname></para>
					<programlisting xml:space="preserve">
SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
  tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
</programlisting>
				</listitem>
			</itemizedlist>
			</sect2>
	</sect1>

