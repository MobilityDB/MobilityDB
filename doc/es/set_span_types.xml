<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter xml:id="set_span_types">
	<title>Tipos de conjunto y de rango</title>

	<para>
		MobilityDB proporciona los tipos de <emphasis>conjunto</emphasis>, <emphasis>rango</emphasis> y <emphasis>conjunto de rangos</emphasis> para representar conjuntos de valores de otro tipo, que se denomina <emphasis>tipo base</emphasis>. Los tipos de conjunto son similares a los tipos de matrices de PostgreSQL restringidos a una dimensión, pero imponen la restricción de que los conjuntos no tienen duplicados. Los tipos de rango y conjunto de rangos en MobilityDB corresponden a los tipos de rango y multirango en PostgreSQL pero tienen restricciones adicionales. En particular, los tipos de rango en MobilityDB tienen una longitud fija y no permiten rangos vacíos ni límites infinitos. Si bien los tipos de rango en MobilityDB proporcionan una funcionalidad similar a los tipos de rango en PostgreSQL, los tipos de rango en MobilityDB permiten aumentar el rendimiento. En particular, se elimina la sobrecarga del procesamiento de tipos de longitud variable y, además, se pueden utilizar la aritmética de punteros y la búsqueda binaria.
	</para>

	<para>
		Los tipos de base que se utilizan para construir tipos de conjunto, de rango y de conjunto de rangos son los tipos <varname>integer</varname>, <varname>bigint</varname>, <varname>float</varname>, <varname>text</varname>, <varname>date</varname>, and <varname>timestamptz</varname> (marca de tiempo con zona horaria) proporcionados por PostgreSQL, los tipos <varname>geometry</varname> y <varname>geography</varname> proporcionados por PostGIS, y el tipo <varname>npoint</varname > (<emphasis>network point</emphasis> o punto de red) proporcionado por MobilityDB (ver <xref linkend="temporal_network_points" />). MobilityDB proporciona los siguientes tipos de conjunto y de rango:
		<itemizedlist>
			<listitem>
				<para><varname>set</varname>: <varname>intset</varname>, <varname>bigintset</varname>, <varname>floatset</varname>, <varname>textset</varname>, <varname>dateset</varname>, <varname>tstzset</varname>, <varname>geomset</varname>, <varname>geogset</varname>, <varname>npointset</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>span</varname>: <varname>intspan</varname>, <varname>bigintspan</varname>, <varname>floatspan</varname>, <varname>datespan</varname>, <varname>tstzspan</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>spanset</varname>: <varname>intspanset</varname>, <varname>bigintspanset</varname>, <varname>floatspanset</varname>, <varname>datespanset</varname>, <varname>tstzspanset</varname>.</para>
			</listitem>
		</itemizedlist>
	</para>

	<para>
			A continuación presentamos las funciones y operadores para tipos de conjunto y de rango. Estas funciones y operadores son polimórficos, es decir, sus argumentos pueden ser de varios tipos y el tipo de resultado puede depender del tipo de los argumentos. Para expresar esto en la firma de las funciones y los operadores, utilizamos la siguiente notación:
	</para>
	<itemizedlist>
		<listitem>
			<para><varname>set</varname> representa cualquier tipo de conjunto, como <varname>intset</varname> o <varname>tstzset</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>span</varname> representa cualquier tipo de rango, como <varname>intspan</varname> o <varname>tstzspan</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>spanset</varname> representa cualquier tipo de conjunto de rangos, como <varname>intspanset</varname> o <varname>tstzspanset</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>spans</varname> representa cualquier tipo de rango o conjunto de rangos, como <varname>intspan</varname> o <varname>tstzspanset</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>base</varname> representa cualquier tipo de base de un tipo de conjunto o de rango, como <varname>integer</varname> o <varname>timestamptz</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>number</varname> representa cualquier tipo de base de un tipo de rango numérico, como <varname>integer</varname> o <varname>float</varname>,</para>
		</listitem>
		<listitem>
			<para><varname>numset</varname> representa cualquier tipo de conjunto numérico, como <varname>intset</varname> o <varname>floatset</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>numspans</varname> representa cualquier tipo de rango o conjunto de rangos numérico, como <varname>intspan</varname> o <varname>floatspanset</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>numbers</varname> representa cualquier tipo de conjunto o de rango numérico, como <varname>integer</varname>, <varname>intset</varname>, <varname>intspan</varname> o <varname>intspanset</varname>,</para>
		</listitem>
		<listitem>
			<para><varname>dates</varname> representa cualquier tipo de tiempo con granularidad <varname>date</varname>, a saber <varname>date</varname>, <varname>dateset</varname>, <varname>datespan</varname> o <varname>datespanset</varname>,</para>
		</listitem>
		<listitem>
			<para><varname>numset</varname> representa cualquier tipo de conjunto numérico, como <varname>intset</varname> o <varname>floatset</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>numspans</varname> representa cualquier tipo de rango o conjunto de rangos numérico, como <varname>intspan</varname> o <varname>floatspanset</varname>.</para>
		</listitem>
		<listitem>
			<para><varname>numbers</varname> representa cualquier tipo de conjunto o de rango numérico, como <varname>integer</varname>, <varname>intset</varname>, <varname>intspan</varname> o <varname>intspanset</varname>,</para>
		</listitem>
		<listitem>
			<para><varname>dates</varname> representa cualquier tipo de tiempo con granularidad <varname>date</varname>, a saber <varname>date</varname>, <varname>dateset</varname>, <varname>datespan</varname> o <varname>datespanset</varname>,</para>
		</listitem>
		<listitem>
			<para><varname>times</varname> representa cualquier tipo de tiempo con granularidad <varname>timestamptz</varname>, a saber <varname>timestamptz</varname>, <varname>tstzset</varname>, <varname>tstzspan</varname> o <varname>tstzspanset</varname>,</para>
		</listitem>
		<listitem>
			<para>Un conjunto de tipos como <varname>{set,base}</varname> representa cualquiera de los tipos enumerados,</para>
		</listitem>
		<listitem>
			<para><varname>type[]</varname> representa una matriz de <varname>type</varname>.</para>
		</listitem>
	</itemizedlist>

	<para>
		Como ejemplo, la firma del operador contiene (<varname>@&gt;</varname>) es como sigue:
	</para>
	<programlisting xml:space="preserve">
{set,spans} @&gt; {base,set,spans} → boolean
</programlisting>
	<para>
		Nótese que la firma anterior es una versión abreviada de la firma más precisa a continuación
	</para>
	<programlisting xml:space="preserve">
set @&gt; {base,set} → boolean
spans @&gt; {base,spans} → boolean
</programlisting>
	<para>
			ya que los conjuntos y los rangos no se pueden mezclar en las operaciones y, por lo tanto, por ejemplo, no se puede preguntar si un rango contiene un conjunto. A continuación, por concisión, utilizamos el estilo abreviado de las firmas anteriores. Además, la parte de tiempo de las marcas de tiempo se omite en la mayoría de los ejemplos. Recuerde que en ese caso PostgreSQL asume el tiempo <varname>00:00:00</varname>.
	</para>

	<para>
		A continuación, dado que los tipos de rango y conjunto de rangos tienen funciones y operadores similares, cuando hablamos de tipos rango nos referimos a los tipos de rango y conjuntos de rangos, a menos que nos refiramos explícitamente a los tipos de rango <emphasis>unitarios</emphasis> y a los tipos de <emphasis>conjunto</emphasis> de rangos para distinguirlos. Además, cuando nos referimos a tipos de tiempo, nos referimos a uno de los siguientes tipos: <varname>timestamptz</varname>, <varname>tstzset</varname>, <varname>tstzspan</varname> o <varname>tstzspanset</varname>.
	</para>

	<sect1>
		<title>Entrada y salida</title>
		<para>
				MobilityDB generaliza los formatos de entrada y salida Well-Known Text (<ulink url="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">WKT</ulink>) y Well-Known Binary (<ulink url="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary">WKB</ulink>) del Open Geospatial Consortium (<ulink url="https://www.ogc.org/">OGC</ulink>) a para todos sus tipos. De esta forma, las aplicaciones pueden intercambiar datos entre ellas utilizando un formato de intercambio estandarizado. El formato WKT es legible por humanos, mientras que el formato WKB es más compacto y más eficiente que el formato WKT. El formato WKB se puede generar como una cadena binaria o como una cadena de caracteres codificada en ASCII hexadecimal.
		</para>

		<para>
			Los tipos de conjunto representan un conjunto <emphasis>ordenado</emphasis> de valores <emphasis>diferentes</emphasis>. Un conjunto debe contener al menos un elemento. Ejemplos de valores de tipos de conjunto son como sigue:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tstzset '{2001-01-01 08:00:00, 2001-01-03 09:30:00}';
-- Conjunto unitario
SELECT textset '{"highway"}';
-- Conjunto erróneo: elementos desordenados
SELECT floatset '{3.5, 1.2}';
-- Conjunto erróneo: elementos duplicados
SELECT geomset '{"Point(1 1)", "Point(1 1)"}';
</programlisting>
		<para>
			Nótese que los elementos de los conjuntos <varname>textset</varname>, <varname>geomset</varname>, <varname>geogset</varname> y <varname>npointset</varname> deben estar delimitados entre commillas dobles. Nótese también que las geometrías y las geografías utilizan el orden definido por PostGIS.
		</para>

		<para>
			Un valor de un tipo de rango unitario tiene dos límites, el <emphasis>límite inferior</emphasis> y el <emphasis>límite superior</emphasis>, que son valores del <emphasis>tipo de base</emphasis> subyacente. Por ejemplo, un valor del tipo <varname>tstzspan</varname> tiene dos límites, que son valores de <varname>timestamptz</varname>. Los límites pueden ser inclusivos o exclusivos. Un límite inclusivo significa que el instante límite está incluido en el rango, mientras que un límite exclusivo significa que el instante límite no está incluido en el rango. En el formato textual de un valor de un rango, los límites inferiores inclusivos y exclusivos están representados, respectivamente, por “<varname>[</varname>” y “<varname>(</varname>”. Asimismo, los límites superiores inclusivos y exclusivos se representan, respectivamente, por “<varname>]</varname>” y “<varname>)</varname>”. En un valor de un rango, el límite inferior debe ser menor o igual que el límite superior. Un valor de rango con límites iguales e inclusivos se llama <emphasis>rango instantáneo</emphasis> y corresponde a un valor del tipo de base. Ejemplos de valores de rango son como sigue:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)';
SELECT floatspan '[1.5, 3.5]';
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-03 09:30:00)';
-- Rangos instantáneos
SELECT intspan '[1, 1]';
SELECT floatspan '[1.5, 1.5]';
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:00:00]';
-- Rango erróneo: límites inválidos
SELECT tstzspan '[2001-01-01 08:10:00, 2001-01-01 08:00:00]';
-- Rango erróneo: rango vacío
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:00:00)';
	</programlisting>
		<para>
			Los valores de <varname>intspan</varname>, <varname>bigintspan</varname> y <varname>datespan</varname> son convertidos en <emphasis>forma normal</emphasis> para que los valores equivalentes tengan representaciones idénticas. En la representación canónica de estos tipos, el límite inferior es inclusivo y el límite superior es exclusivo, como se muestra en los siguientes ejemplos:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 1]';
-- [1, 2)
SELECT bigintspan '(1, 3]';
--[2, 4)
SELECT datespan '[2001-01-01, 2001-01-03]';
-- [2001-01-01, 2001-01-04)
</programlisting>

		<para>
			Un valor de un tipo de conjunto de rangos representa un conjunto <emphasis>ordenado</emphasis> de valores de rango <emphasis>disjuntos</emphasis>. Un valor de conjunto de rangos debe contener al menos un elemento, en cuyo caso corresponde a un único valor de rango. Ejemplos de valores conjunto de rangos son los siguientes:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT floatspanset '{[8.1, 8.5],[9.2, 9.4]}';
-- Singleton spanset
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Erroneous spanset: unordered elements
SELECT intspanset '{[3,4],[1,2]}';
-- Erroneous spanset: overlapping elements
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:05:00, 2001-01-01 08:15:00]}';
</programlisting>

		<para>
			Los valores de los tipos conjunto de rangos son convertidos en <emphasis>forma normal</emphasis> de modo que los valores equivalentes tengan representaciones idénticas. Para ello, los valores de rango consecutivos que son adyacentes se fusionan cuando es posible. Ejemplos de transformación a forma normal son los siguientes:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT intspanset '{[1,2],[3,4]}';
-- {[1, 5)}
SELECT floatspanset '{[1.5,2.5],(2.5,4.5]}';
-- {[1.5, 4.5]}
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00),
  [2001-01-01 08:10:00, 2001-01-01 08:10:00], (2001-01-01 08:10:00, 2001-01-01 08:20:00]}';
-- {[2001-01-01 08:00:00+00,2001-01-01 08:20:00+00]}
</programlisting>

		<para>
			Damos a continuación las funciones de entrada y salida de tipos de conjunto y de rango en formato textual (Well-Known Text o WKT) y binario (Well-Known Binary o WKB). El formato de salida predeterminado de todos los tipos de conjuntos y de rango es el formato de texto conocido. La función <varname>asText</varname> que se da a continuación permite determinar la salida de valores de punto flotante.
		</para>

		<itemizedlist>
			<listitem xml:id="setspan_asText">
				<indexterm significance="normal"><primary><varname>asText</varname></primary></indexterm>
				<para>Devuelve la representación textual conocida (Well-Known Text o WKT)</para>
				<para><varname>asText({floatset,floatspans},maxdecdigits=15) → text</varname></para>
					<para>El argumento <varname>maxdecdigits</varname> se puede utilizar para definir el número máximo de decimales para la salida de los valores de coma flotante (por defecto 15).</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(floatset '{1.123456789,2.123456789}', 3);
-- {1.123, 2.123}
SELECT asText(floatspanset '{[1.55,2.55],[4,5]}',0);
-- {[2, 3], [4, 5]}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_asBinary">
				<indexterm significance="normal"><primary><varname>asBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>asHexWKB</varname></primary></indexterm>
				<para>Devuelve la representación binaria conocida (Well-Known Binary o WKB) o la representación hexadecimal binaria conocida (HexWKB)</para>
				<para><varname>asBinary({set,spans},endian text='') → bytea</varname></para>
				<para><varname>asHexWKB({set,spans},endian text='') → text</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asBinary(dateset '{2001-01-01, 2001-01-03}');
-- \x01050001020000006e01000070010000
SELECT asBinary(intspan '[1, 3)');
-- \x011300010100000003000000
SELECT asBinary(floatspanset '{[1, 2], [4, 5]}', 'XDR');
-- \x00000e00000002033ff000000000000040000000000000000340100000000000004014000000000000
SELECT asHexWKB(dateset '{2001-01-01, 2001-01-03}');
-- 01050001020000006E01000070010000
SELECT asHexWKB(intspan '[1, 3)');
-- 011300010100000003000000
SELECT asHexWKB(floatspanset '{[1, 2], [4, 5]}', 'XDR');
-- 00000E00000002033FF000000000000040000000000000000340100000000000004014000000000000
</programlisting>
			</listitem>

			<listitem xml:id="setspan_FromBinary">
				<indexterm significance="normal"><primary><varname>settypeFromBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spantypeFromBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spansettypeFromBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>settypeFromHexWKB</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spantypeFromHexWKB</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spansettypeFromHexWKB</varname></primary></indexterm>
				<para>Entrar a partir de la representación binaria conocida (WKB) o a partir de la representación hexadecimal binaria conocida (HexWKB)</para>
				<para><varname>settypeFromBinary(bytea) → set</varname></para>
				<para><varname>spantypeFromBinary(bytea) → span</varname></para>
				<para><varname>spansettypeFromBinary(bytea) → spanset</varname></para>
				<para><varname>settypeFromHexWKB(text) → set</varname></para>
				<para><varname>spantypeFromHexWKB(text) → span</varname></para>
				<para><varname>spansettypeFromHexWKB(text) → spanset</varname></para>
				<para>Hay una función por tipo de conjunto o de rango, el nombre de la función tiene como prefijo el nombre del tipo.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT datesetFromBinary('\x01050001020000006e01000070010000');
-- {2001-01-01, 2001-01-03}
SELECT intspanFromBinary('\x011300010100000003000000');
-- [1, 3)
SELECT floatspansetFromBinary(
  '\x00000e00000002033ff000000000000040000000000000000340100000000000004014000000000000');
-- {[1, 2], [4, 5]}
SELECT datesetFromHexWKB('01050001020000006E01000070010000');
-- {2001-01-01, 2001-01-03}
SELECT intspanFromHexWKB('011300010100000003000000');
-- [1, 3)
SELECT floatspansetFromHexWKB(
  '00000E00000002033FF000000000000040000000000000000340100000000000004014000000000000');
-- {[1, 2], [4, 5]}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Constructores</title>

		<para>La función constructora para los tipos de conjunto tiene un único argumento que es una matriz de valores del tipo base correspondiente. Los valores deben estar ordenados y no pueden tener nulos ni duplicados.
		</para>
		<itemizedlist>
			<listitem xml:id="set">
				<indexterm significance="normal"><primary><varname>intset</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>floatset</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>textset</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tstzset</varname></primary></indexterm>
				<para>Constructor para tipos de conjunto</para>
				<para><varname>set(base[]) → set</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT set(ARRAY['highway', 'primary', 'secondary']);
-- {"highway", "primary", "secondary"}
SELECT set(ARRAY[timestamptz '2001-01-01 08:00:00', '2001-01-03 09:30:00']);
-- {2001-01-01 08:00:00+00, 2001-01-03 09:30:00+00}
</programlisting>
			</listitem>
		</itemizedlist>

		<para>Los tipos de rango unitarios tienen una función constructora que acepta cuatro argumentos, donde los dos últimos son opcionales. Los primeros dos argumentos especifican, respectivamente, el límite inferior y el superior, y los dos últimos argumentos son valores booleanos que indican, respectivamente, si los límites inferior y el superior son inclusivos o no. Se supone que los dos últimos argumentos son, respectivamente, verdadero y falso si no se especifican. Nótese que los rangos de enteros se transforman en <emphasis>forma normal</emphasis>, es decir, con límite inferior inclusivo y límite superior exclusivo.
		</para>
		<itemizedlist>
			<listitem xml:id="span">
				<indexterm significance="normal"><primary><varname>span</varname></primary></indexterm>
				<para>Constructor para tipos de rango</para>
				<para><varname>span(lower base,upper base,leftInc bool=true,rightInc bool=false) → span</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT span(20.5, 25);
-- [20.5, 25)
SELECT span(20, 25, false, true);
-- [21, 26)
SELECT span(timestamptz '2001-01-01 08:00:00', '2001-01-03 09:30:00', false, true);
-- (2001-01-01 08:00:00, 2001-01-03 09:30:00]
</programlisting>
			</listitem>
		</itemizedlist>

		<para>La función constructora para los tipos de conjuntos de rangos tiene un solo argumento que es una matriz de rangos del mismo subtipo.
		</para>
		<itemizedlist>
			<listitem xml:id="spanset">
					<indexterm significance="normal"><primary><varname>spanset</varname></primary></indexterm>
				<para>Constructor for conjunto de rangos</para>
				<para><varname>spanset(span[]) → spanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT spanset(ARRAY[intspan '[10,12]', '[13,15]']);
-- {[10, 16)}
SELECT spanset(ARRAY[floatspan '[10.5,12.5]', '[13.5,15.5]']);
-- {[10.5, 12.5], [13.5, 15.5]}
SELECT spanset(ARRAY[tstzspan '[2001-01-01 08:00, 2001-01-01 08:10]',
  '[2001-01-01 08:20, 2001-01-01 08:40]']);
-- {[2001-01-01 08:00, 2001-01-01 08:10], [2001-01-01 08:20, 2001-01-01 08:40]};
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Conversión de tipos</title>
		<para>
			Los valores de los tipos de conjunto y de rango se pueden convertir entre sí o convertirse a tipos de rango de PostgreSQL y desde ellos mediante la función <varname>CAST</varname> o mediante la notación <varname>::</varname>.
		</para>
		<itemizedlist>
			<listitem xml:id="base_convert">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>set</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>span</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spanset</varname></primary></indexterm>
				<para>Convertir un valor de base en un valor de conjunto, rango o conjunto de rangos</para>
				<para><varname>base::{set,span,spanset}</varname></para>
				<para><varname>set(base) → set</varname></para>
				<para><varname>span(base) → span</varname></para>
				<para><varname>spanset(base) → spanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS tstzset);
-- {2001-01-01 08:00:00}
SELECT timestamptz '2001-01-01 08:00:00'::tstzspan;
-- [2001-01-01 08:00:00, 2001-01-01 08:00:00]
SELECT spanset(timestamptz '2001-01-01 08:00:00');
-- {[2001-01-01 08:00:00, 2001-01-01 08:00:00]}
</programlisting>
			</listitem>

			<listitem xml:id="set_convert">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un valor de conjunto en un valor de conjunto de rangos</para>
				<para><varname>set::spanset</varname></para>
				<para><varname>spanset(set) → spanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT spanset(tstzset '{2001-01-01 08:00:00, 2001-01-01 08:15:00,
  2001-01-01 08:25:00}');
/* {[2001-01-01 08:00:00, 2001-01-01 08:00:00],
   [2001-01-01 08:15:00, 2001-01-01 08:15:00],
   [2001-01-01 08:25:00, 2001-01-01 08:25:00]} */
</programlisting>
			</listitem>

			<listitem xml:id="span_convert">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un valor de rango a un valor de conjunto de rangos</para>
				<para><varname>span::spanset</varname></para>
				<para><varname>spanset(span) → spanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[1.5,2.5]'::floatspanset;
-- {[1.5, 2.5]}
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::tstzspanset;
-- {[2001-01-01 08:00:00, 2001-01-01 08:30:00)}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_span">
				<indexterm significance="normal"><primary><varname>span</varname></primary></indexterm>
				<para>Convertir un conjunto de valores o un conjunto de rangos a un rango, ignorando las posibles brechas de tiempo</para>
				<para><varname>{set,spanset}::span</varname></para>
				<para><varname>span({set,spanset}) → span</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT span(dateset '{2001-01-01, 2001-01-03, 2001-01-05}');
-- [2001-01-01, 2001-01-06)
SELECT span(tstzspanset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</programlisting>
			</listitem>

			<listitem xml:id="range_convert">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>span</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>range</varname></primary></indexterm>
				<para>Convertir un valor de de rango en MobilityDB hacia y desde un valor de rango de PostgreSQL</para>
				<para><varname>span::range</varname></para>
				<para><varname>range::span</varname></para>
				<para><varname>range(span) → range</varname></para>
				<para><varname>span(range) → span</varname></para>
				<para>Nótese que los valores de rango en PostgreSQL aceptan rangos vacíos y rangos con límites infinitos, que no están permitidos como valores de rango en MobilityDB</para>
				<programlisting language="sql" xml:space="preserve">
SELECT intspan '[10, 20)'::int4range;
-- [10,20)
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::tstzrange;
-- ["2001-01-01 08:00:00","2001-01-01 08:30:00")
SELECT int4range '[10, 20)'::intspan;
-- [10,20)
SELECT int4range 'empty'::intspan;
-- ERROR:  Range cannot be empty
SELECT int4range '[10,)'::intspan;
-- ERROR:  Range bounds cannot be infinite
SELECT tstzrange '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::tstzspan;
-- [2001-01-01 08:00:00, 2001-01-01 08:30:00)
</programlisting>
			</listitem>

			<listitem xml:id="multirange_convert">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spanset</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>multirange</varname></primary></indexterm>
				<para>Convertir un valor de conjunto de rangos de MobilityDB hacia y desde un valor de multirango de PostgreSQL</para>
				<para><varname>spanset::multirange</varname></para>
				<para><varname>multirange::spanset</varname></para>
				<para><varname>multirange(spanset) → multirange</varname></para>
				<para><varname>spanset(multirange) → spanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intspanset '{[1,2],[4,5]}'::int4multirange;
-- {[1,3),[4,6)}
SELECT tstzspanset '{[2001-01-01,2001-01-02],[2001-01-04,2001-01-05]}'::tstzmultirange;
-- {[2001-01-01,2001-01-02],[2001-01-04,2001-01-05]}
SELECT int4multirange '{[1,2],[4,5]}'::intspanset;
-- {[1, 3), [4, 6)}
SELECT tstzmultirange '{[2001-01-01,2001-01-02],[2001-01-04,2001-01-05]}'::tstzspanset;
-- {[2001-01-01, 2001-01-02], [2001-01-04, 2001-01-05]}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Accesores</title>

		<itemizedlist>
			<listitem xml:id="setspan_memSize">
				<indexterm significance="normal"><primary><varname>memSize</varname></primary></indexterm>
				<para>Devuelve el tamaño de la memoria en bytes</para>
				<para><varname>memSize({set,spanset}) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT memSize(tstzset '{2001-01-01, 2001-01-02, 2001-01-03}');
-- 48
SELECT memSize(tstzspanset '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04],
  [2001-01-05, 2001-01-06]}');
-- 112
</programlisting>
			</listitem>

			<listitem xml:id="setspan_lower">
				<indexterm significance="normal"><primary><varname>lower</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>upper</varname></primary></indexterm>
				<para>Devuelve el límite inferior o superior</para>
				<para><varname>lower(spans) → base</varname></para>
				<para><varname>upper(spans) → base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT lower(tstzspan '[2001-01-01, 2001-01-05)');
-- 2001-01-01
SELECT lower(intspanset '{[1,2],[4,5]}');
--  1
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT lower(tstzspan '[2001-01-01, 2001-01-05)');
-- 2001-01-01
SELECT upper(intspanset '{[1,2],[4,5]}');
--  6
SELECT lower(tstzspan '[2001-01-01, 2001-01-05)');
-- 2001-01-01
SELECT lower(intspanset '{[1,2],[4,5]}');
--  1
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT upper(floatspan '[20.5, 25.3)');
-- 25.3
SELECT upper(tstzspan '[2001-01-01, 2001-01-05)');
-- 2001-01-05
</programlisting>
			</listitem>

			<listitem xml:id="setspan_lowerInc">
				<indexterm significance="normal"><primary><varname>lowerInc</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>upperInc</varname></primary></indexterm>
				<para>¿Es el límite inferior or superior inclusivo?</para>
				<para><varname>lowerInc(spans) → boolean</varname></para>
				<para><varname>upperInc(spans) → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT lowerInc(datespan '[2001-01-01, 2001-01-05)');
-- true
SELECT lowerInc(intspanset '{[1,2],[4,5]}');
-- true
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT lowerInc(tstzspan '[2001-01-01, 2001-01-05)');
-- true
SELECT upperInc(intspanset '{[1,2],[4,5]}');
-- false
SELECT upper(floatspan '[20.5, 25.3]');
-- true
SELECT upperInc(tstzspan '[2001-01-01, 2001-01-05)');
-- false
</programlisting>
			</listitem>

			<listitem xml:id="setspan_width">
				<indexterm significance="normal"><primary><varname>width</varname></primary></indexterm>
				<para>Devuelve el ancho del rango como un número de punto flotante</para>
				<para><varname>width(numspan) → float</varname></para>
				<para><varname>width(numspanset,boundspan=false) → float</varname></para>
				<para>Se puede establecer a verdadero un parámetro adicional para calcular el ancho del rango delimitador, ignorando así las posibles brechas de valors</para>
				<programlisting language="sql" xml:space="preserve">
SELECT width(floatspan '[1, 3)');
-- 2
SELECT width(intspanset '{[1,3),[5,7)}');
-- 4
SELECT width(intspanset '{[1,3),[5,7)}', true);
-- 6
</programlisting>
			</listitem>

			<listitem xml:id="setspan_duration">
				<indexterm significance="normal"><primary><varname>duration</varname></primary></indexterm>
				<para>Devuelve el rango de tiempo</para>
				<para><varname>duration({datespan,tstzspan}) → interval</varname></para>
				<para><varname>duration({datespanset,tstzspanset},boundspan bool=false) → interval</varname></para>
				<para>Se puede establecer a verdadero un parámetro adicional para calcular la duración en el rango delimitador, ignorando así las posibles brechas de tiempo</para>
				<programlisting language="sql" xml:space="preserve">
SELECT duration(datespan '[2001-01-01, 2001-01-03)');
-- 2 days
SELECT duration(tstzspanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- 3 days
SELECT duration(tstzspanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}', true);
-- 4 days
</programlisting>
			</listitem>

			<listitem xml:id="setspan_numValues">
				<indexterm significance="normal"><primary><varname>numValues</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>getValues</varname></primary></indexterm>
				<para>Devuelve el número de valores o los valores</para>
				<para><varname>numValues(set) → integer</varname></para>
				<para><varname>getValues(set) → base[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numValues(intset '{1,3,5,7}');
-- 4
SELECT getValues(tstzset '{2001-01-01, 2001-01-03, 2001-01-05, 2001-01-07}');
-- {"2001-01-01", "2001-01-03", "2001-01-05", "2001-01-07"}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_startValue">
				<indexterm significance="normal"><primary><varname>startValue</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>endValue</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>valueN</varname></primary></indexterm>
				<para>Devuelve el valor inicial, final o enésimo</para>
				<para><varname>startValue(set) → base</varname></para>
				<para><varname>endValue(set) → base</varname></para>
				<para><varname>valueN(set,integer) → base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT startValue(intset '{1,3,5,7}');
-- 1
SELECT endValue(dateset '{2001-01-01, 2001-01-03, 2001-01-05, 2001-01-07}');
-- 2001-01-07
SELECT valueN(floatset '{1,3,5,7}',2);
-- 3
</programlisting>
			</listitem>

			<listitem xml:id="setspan_numSpans">
				<indexterm significance="normal"><primary><varname>numSpans</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spans</varname></primary></indexterm>
				<para>Devuelve el número de rangos o los rangos</para>
				<para><varname>numSpans(spanset) → integer</varname></para>
				<para><varname>spans(spanset) → span[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numSpans(intspanset '{[1,3),[4,5),[6,7)}');
-- 3
SELECT numSpans(datespanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05),
  [2001-01-06, 2001-01-07)}');
-- 3
SELECT spans(floatspanset '{[1,3),[4,4],[6,7)}');
-- {"[1,3)","[4,4]","[6,7)"}
SELECT spans(tstzspanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- {"[2001-01-01,2001-01-03)", "[2001-01-04,2001-01-04]", "[2001-01-05,2001-01-06)"}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_startSpan">
				<indexterm significance="normal"><primary><varname>startSpan</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>endSpan</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spanN</varname></primary></indexterm>
				<para>Devuelve el rango inicial, final o enésimo</para>
				<para><varname>startSpan(spanset) → span</varname></para>
				<para><varname>endSpan(spanset) → span</varname></para>
				<para><varname>spanN(spanset,integer) → span</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT startSpan(intspanset '{[1,3),[4,5),[6,7)}');
-- [1,3)
SELECT startSpan(datespanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05),
  [2001-01-06, 2001-01-07)}');
-- [2001-01-01,2001-01-03)
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT endSpan(floatspanset '{[1,3),[4,4],[6,7)}');
-- [6,7)
SELECT endSpan(tstzspanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- [2001-01-05,2001-01-06)
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT spanN(floatspanset '{[1,3),[4,4],[6,7)}',2);
-- [4,4]
SELECT spanN(tstzspanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}', 2);
-- [2001-01-04,2001-01-04]
</programlisting>
			</listitem>

			<listitem xml:id="setspan_numDates">
				<indexterm significance="normal"><primary><varname>numDates</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>dates</varname></primary></indexterm>
				<para>Devuelve el (number of) different dates</para>
				<para><varname>numDates(datespanset) → integer</varname></para>
				<para><varname>dates(datespanset) → dateset</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT numDates(datespanset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- 4
SELECT dates(datespanset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- {2001-01-01, 2001-01-02, 2001-01-03, 2001-01-04}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_startDate">
				<indexterm significance="normal"><primary><varname>startDate</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>endDate</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>dateN</varname></primary></indexterm>
				<para>Devuelve el start, end, or n-th date</para>
				<para><varname>startDate(datespanset) → date</varname></para>
				<para><varname>endDate(datespanset) → date</varname></para>
				<para><varname>dateN(datespanset,integer) → date</varname></para>
				<para>The functions do not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT startDate(datespanset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- 2001-01-01
SELECT endDate(datespanset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-05
SELECT dateN(datespanset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}', 3);
-- 2001-01-05
</programlisting>
			</listitem>

			<listitem xml:id="setspan_numTimestamps">
				<indexterm significance="normal"><primary><varname>numTimestamps</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>timestamps</varname></primary></indexterm>
				<para>Devuelve el número o las marcas de tiempo diferentes</para>
				<para><varname>numTimestamps(tstzspanset) → integer</varname></para>
				<para><varname>timestamps(tstzspanset) → tstzset</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT numTimestamps(tstzspanset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 3
SELECT timestamps(tstzspanset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- {"2001-01-01 00:00:00", "2001-01-03 00:00:00", "2001-01-05 00:00:00"}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_startTimestamp">
				<indexterm significance="normal"><primary><varname>startTimestamp</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>endTimestamp</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>timestampN</varname></primary></indexterm>
				<para>Devuelve la marca de tiempo inicial, final, o enésima</para>
				<para><varname>startTimestamp(tstzspanset) → timestamptz</varname></para>
				<para><varname>endTimestamp(tstzspanset) → timestamptz</varname></para>
				<para><varname>timestampN(tstzspanset,integer) → timestamptz</varname></para>
				<para>The functions do not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT startTimestamp(tstzspanset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- 2001-01-01
SELECT endTimestamp(tstzspanset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-05
SELECT timestampN(tstzspanset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}', 3);
-- 2001-01-05
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Transformaciones</title>
		<itemizedlist>
			<listitem xml:id="setspan_expand">
				<indexterm significance="normal"><primary><varname>expand</varname></primary></indexterm>
				<para>Expandir o reducir los límites de un rango con un valor o un intervalo de tiempo</para>
				<para><varname>expand(numspan,base) → numspan</varname></para>
				<para><varname>expand(tstzspan,interval) → tstzspan</varname></para>
				<para>La función devuelve NULL si el valor o intervalo dado como segundo argumento es negativo y el rango resultante de desplazar los límites con el argumento está vacío.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT expand(floatspan '[1, 3]', 1);
-- [0, 4]
SELECT expand(floatspan '[1, 3]', -1);
-- [2, 2]
SELECT expand(floatspan '[1, 3)', -1);
-- NULL
SELECT expand(tstzspan '[2001-01-01, 2001-01-03]', interval '1 day');
-- [2000-12-31, 2001-01-04]
SELECT expand(tstzspan '[2001-01-01, 2001-01-03]', interval '-1 day');
-- [2001-01-02, 2001-01-02]
SELECT expand(tstzspan '[2001-01-01, 2001-01-03]', interval '-2 day');
-- NULL
</programlisting>
			</listitem>

			<listitem xml:id="setspan_shift">
				<indexterm significance="normal"><primary><varname>shift</varname></primary></indexterm>
				<para>Desplazar con un valor o rango de tiempo</para>
				<para><varname>shift(numbers,base) → numbers</varname></para>
				<para><varname>shift(dates,integer) → dates</varname></para>
				<para><varname>shift(times,interval) → times</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shift(dateset '{2001-01-01, 2001-01-03, 2001-01-05}', 1);
-- {2001-01-02, 2001-01-04, 2001-01-06}
SELECT shift(intspan '[1, 4)', -1);
-- [0, 3)
SELECT shift(tstzspan '[2001-01-01, 2001-01-03]', interval '1 day');
-- [2001-01-02, 2001-01-04]
SELECT shift(floatspanset '{[1, 2], [3, 4]}', -1);
-- {[0, 1], [2, 3]}
SELECT shift(tstzspanset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  interval '1 day');
-- {[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_scale">
				<indexterm significance="normal"><primary><varname>scale</varname></primary></indexterm>
				<para>Escalear con un valor o un rango de tiempo</para>
				<para><varname>scale(numbers,base) → numbers</varname></para>
				<para><varname>scale(dates,integer) → dates</varname></para>
				<para><varname>scale(times,interval) → times</varname></para>
				<para>Si el ancho o el lapso de tiempo del valor de entrada es cero (por ejemplo, para un conjunto de marcas de tiempo único), el resultado es el valor de entrada. El valor o rango de tiempo dado debe ser estrictamente mayor que cero.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT scale(tstzset '{2001-01-01}', interval '1 day');
-- {2001-01-01}
SELECT scale(tstzset '{2001-01-01, 2001-01-03, 2001-01-05}', '2 days');
-- {2001-01-01, 2001-01-02, 2001-01-03}
SELECT scale(intspan '[1, 4)', 4);
-- [1, 6)
SELECT scale(datespan '[2001-01-01, 2001-01-04)', 4);
-- [2001-01-01, 2001-01-06)
SELECT scale(tstzspan '[2001-01-01, 2001-01-03]', '1 day');
-- [2001-01-01, 2001-01-02]
SELECT scale(floatspanset '{[1, 2], [3, 4]}', 6);
-- {[1, 3], [5, 7]}
SELECT scale(tstzspanset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}', '1 day');
-- {[2001-01-01 00:00:00, 2001-01-01 12:00:00],
  [2001-01-01 18:00:00, 2001-01-02 00:00:00]}
SELECT scale(tstzset '{2001-01-01}', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem xml:id="setspan_shiftScale">
				<indexterm significance="normal"><primary><varname>shiftScale</varname></primary></indexterm>
				<para>Desplazar y escalear con los valores o rangos de tiempo</para>
				<para><varname>shiftScale(numbers,base,base) → numbers</varname></para>
				<para><varname>shiftScale(dates,integer,integer) → dates</varname></para>
				<para><varname>shiftScale(times,interval,interval) → times</varname></para>
				<para>Estas funciones combinan las funciones <link linkend="setspan_shift"><varname>shift</varname></link> y <link linkend="setspan_scale"><varname>scale</varname></link>.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT shiftScale(tstzset '{2001-01-01}', '1 day', '1 day');
-- {2001-01-02}
SELECT shiftScale(tstzset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day','2 days');
-- {2001-01-02, 2001-01-03, 2001-01-04}
SELECT shiftScale(intspan '[1, 4)', -1, 4);
-- [0, 5)
SELECT shiftScale(datespan '[2001-01-01, 2001-01-04)', -1, 4);
-- [2001-12-31, 2001-01-05)
SELECT shiftScale(tstzspan '[2001-01-01, 2001-01-03]', '1 day', '1 day');
-- [2001-01-02, 2001-01-03]
SELECT shiftScale(floatspanset '{[1, 2], [3, 4]}', -1, 6);
-- {[0, 2], [4, 6]}
SELECT shiftScale(tstzspanset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day', '1 day');
/* {[2001-01-02 00:00:00, 2001-01-02 12:00:00],
   [2001-01-02 18:00:00, 2001-01-03 00:00:00]} */
</programlisting>
			</listitem>

			<listitem xml:id="floatsetspan_floor">
				<indexterm significance="normal"><primary><varname>floor</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>ceil</varname></primary></indexterm>
				<para>Redondear al entero inferior o superior</para>
				<para><varname>floor({floatset,floatspans}) → {floatset,floatspans}</varname></para>
				<para><varname>ceil({floatset,floatspans}) → {floatset,floatspans}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT floor(floatset '{1.5,2.5}');
-- {1, 2}
SELECT ceil(floatspan '[1.5,2.5)');
-- [2, 3)
SELECT floor(floatspan '(1.5, 1.6)');
-- [1, 1]
SELECT ceil(floatspanset '{[1.5, 2.5],[3.5,4.5]}');
-- {[2, 3], [4, 5]}
</programlisting>
			</listitem>

			<listitem xml:id="floatsetspan_round">
				<indexterm significance="normal"><primary><varname>round</varname></primary></indexterm>
				<para>Redondear a un número de decimales</para>
				<para><varname>round({floatset,floatspans},integer=0) → {floatset,floatspans}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(floatset '{1.123456789,2.123456789}', 3);
-- {1.123, 2.123}
SELECT round(floatspan '[1.123456789,2.123456789)', 3);
-- [1.123,2.123)
SELECT round(floatspan '[1.123456789, inf)', 3);
-- [1.123,Infinity)
SELECT round(floatspanset '{[1.123456789, 2.123456789],[3.123456789,4.123456789]}', 3);
-- {[1.123, 2.123], [3.123, 4.123]}
</programlisting>
			</listitem>

			<listitem xml:id="floatset_degrees">
				<indexterm significance="normal"><primary><varname>degrees</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>radians</varname></primary></indexterm>
				<para>Convertir a grados o radianes</para>
				<para><varname>degrees(floatset, normalize=false) → floatset</varname></para>
				<para><varname>radians(floatset) → floatset</varname></para>
				<para>El parámetro adicional en la función <varname>degrees</varname> puede ser utilizado para normalizar los valores entre 0 y 360 grados.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(degrees(floatset '{0, 0.5, 0.7, 1.0}', true), 3);
-- {0, 28.648, 40.107, 57.296}
SELECT round(radians(floatset '{0, 45, 90}'), 3);
-- {0, 0.785, 1.571}
</programlisting>
			</listitem>

			<listitem xml:id="textset_lower">
				<indexterm significance="normal"><primary><varname>lower</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>upper</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>initcap</varname></primary></indexterm>
				<para>Transformar en minúsculas, majúsculas o initcap</para>
				<para><varname>lower(textset) → textset</varname></para>
				<para><varname>upper(textset) → textset</varname></para>
				<para><varname>initcap(textset) → textset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT lower(textset '{"AAA", "BBB", "CCC"}');
-- {"aaa", "bbb", "ccc"}
SELECT upper(textset '{"aaa", "bbb", "ccc"}');
-- {"AAA", "BBB", "CCC"}
SELECT initcap(textset '{"aaa", "bbb", "ccc"}');
-- {"Aaa", "Bbb", "Ccc"}
</programlisting>
			</listitem>

			<listitem xml:id="textset_concat">
				<indexterm significance="normal"><primary><varname>||</varname></primary></indexterm>
				<para>Concatenación de texto</para>
				<para><varname>{text,textset} || {text,textset} → textset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT textset '{aaa, bbb}' || text 'XX';
-- {"aaaXX", "bbbXX"}
SELECT text 'XX' || textset '{aaa, bbb}';
-- {"XXaaa", "XXbbb"}
</programlisting>
			</listitem>

			<listitem xml:id="time_tprecision">
				<indexterm significance="normal"><primary><varname>tprecision</varname></primary></indexterm>
				<para>Establecer la precisión temporal del valor de tiempo al rango con respecto al origen</para>
				<para><varname>tprecision(times,interval,origin timestamptz=’2000-01-03’) → times</varname></para>
				<para>Si el origen no se especifica, su valor se establece por defecto en lunes 3 de enero de 2000.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT tprecision(timestamptz '2001-12-03', '30 days');
-- 2001-11-23
SELECT tprecision(timestamptz '2001-12-03', '30 days', '2001-12-01');
-- 2001-12-01
SELECT tprecision(tstzset '{2001-01-01 08:00, 2001-01-01 08:10, 2001-01-01 09:00,
  2001-01-01 09:10}', '1 hour');
-- {"2001-01-01 08:00:00+01", "2001-01-01 09:00:00+01"}
SELECT tprecision(tstzspan '[2001-12-01 08:00, 2001-12-01 09:00]', '1 day');
-- [2001-12-01, 2001-12-02)
SELECT tprecision(tstzspan '[2001-12-01 08:00, 2001-12-15 09:00]', '1 day');
-- [2001-12-01, 2001-12-16)
SELECT tprecision(tstzspanset '{[2001-12-01 08:00, 2001-12-01 09:00],
  [2001-12-01 10:00, 2001-12-01 11:00]}', '1 day');
-- {[2001-12-01, 2001-12-02)}
SELECT tprecision(tstzspanset '{[2001-12-01 08:00, 2001-12-01 09:00],
  [2001-12-01 10:00, 2001-12-01 11:00]}', '1 day');
-- {[2001-12-01, 2001-12-02)}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id ="spatialset_spatial_srid">
		<title>Sistema de referencia espacial</title>

		<itemizedlist>
			<listitem xml:id="spatialset_SRID">
				<indexterm significance="normal"><primary><varname>SRID</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>setSRID</varname></primary></indexterm>
				<para>Devuelve o especifica el identificador de referencia espacial</para>
				<para><varname>SRID(spatialset) → integer</varname></para>
				<para><varname>setSRID(spatialset) → spatialset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT SRID(geomset '{Point(1 1), Point(2 2)}');
-- 0
SELECT SRID(geogset '{"Linestring(1 1,2 2)","Polygon((1 1,1 2,2 2,2 1,1 1))"}');
-- 4326
SELECT SRID(geomset 'SRID=5676;{"Linestring(1 1,2 2)","Polygon((1 1,1 2,2 2,2 1,1 1))"}');
-- 5676
SELECT asEWKT(setSRID(geomset '{Point(1 1), Point(2 2)}', 5676));
-- SRID=5676;{"POINT(1 1)", "POINT(2 2)"}
SELECT asEWKT(setSRID(poseset '{"Pose(Point(1 1),1)", "Pose(Point(2 2),3)"}', 5676));
-- SRID=5676;{"Pose(POINT(2 2),3)", "Pose(POINT(1 1),1)"}
</programlisting>
				</listitem>

			<listitem xml:id="spatialset_transform">
				<indexterm significance="normal"><primary><varname>transform</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>transformPipeline</varname></primary></indexterm>
				<para>Transformar a una referencia espacial diferente</para>
				<para><varname>transform(spatialset,to_srid integer) → spatialset</varname></para>
				<para><varname>transformPipeline(spatialset,pipeline text,to_srid integer,is_forward bool=true) →</varname></para>
				<para><varname>  spatialset</varname></para>
				<para>La función <varname>transform</varname> especifica la transformación con un SRID de destino. Se genera un error cuando el conjunto tiene un SRID desconocido (representado por 0). La función <varname>transformPipeline</varname> especifica la transformación con una canalización de transformación de coordenadas en el siguiente formato:</para>
				<para><varname>urn:ogc:def:coordinateOperation:AUTHORITY::CODE</varname></para>
				<para>El SRID del conjunto de entrada se ignora y el SRID de la conjunto de salida se establecerá en cero a menos que se proporcione un valor a través del parámetro opcional <varname>to_srid</varname>. Como se indica en el último parámetro, la canalización se ejecuta de forma predeterminada en dirección hacia adelante; al establecer el parámetro en falso, la canalización se ejecuta en la dirección inversa.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(transform(geomset 'SRID=4326;{Point(2.340088 49.400250),
  Point(6.575317 51.553167)}', 3812), 6);
-- SRID=3812;{"POINT(502773.429981 511805.120402)", "POINT(803028.908265 751590.742629)"}
WITH test(geoset, pipeline) AS (
  SELECT geogset 'SRID=4326;{"Point(4.3525 50.846667 100.0)",
    "Point(-0.1275 51.507222 100.0)"}', 
    text 'urn:ogc:def:coordinateOperation:EPSG::16031' )
SELECT asEWKT(transformPipeline(transformPipeline(geoset, pipeline, 4326), pipeline,
  4326, false), 6)
FROM test;
-- SRID=4326;{"POINT Z (4.3525 50.846667 100)", "POINT Z (-0.1275 51.507222 100)"}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="setspan_set_ops">
		<title>Operaciones de conjuntos</title>

		<para>Los tipos de conjunto y de rango tienen operadores de conjuntos asociados, a saber, unión, diferencia e intersección, que se representan, respectivamente, por <varname>+</varname>, <varname>-</varname> y <varname>* </varname>. Los operadores de conjunto para los tipos de rango y tiempo se dan a continuación.</para>

		<itemizedlist>
			<listitem xml:id="setspan_union">
				<indexterm significance="normal"><primary><varname>+</varname></primary></indexterm>
				<para>Unión, diferencia o intersección de conjuntos o de rangos</para>
				<para><varname>set {+, - , *} set → set</varname></para>
				<para><varname>spans {+, - , *} spans → spans</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT dateset '{2001-01-01, 2001-01-03, 2001-01-05}' +
  dateset '{2001-01-03, 2001-01-06}';
-- {2001-01-01, 2001-01-03, 2001-01-05, 2001-01-06}
SELECT intspan '[1, 3)' + intspan '[3, 5)';
-- [1, 5)
SELECT floatspan '[1, 3)' + floatspan '[4, 5)';
-- {[1, 3), [4, 5)}
SELECT tstzspanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}' +
  tstzspan '[2001-01-03, 2001-01-04)';
-- {[2001-01-01, 2001-01-05)}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT intset '{1, 3, 5}' - intset '{3, 6}';
-- {1, 5}
SELECT datespan '[2001-01-01, 2001-01-05)' - datespan '[2001-01-03, 2001-01-07)';
-- {[2001-01-01, 2001-01-03)}
SELECT floatspan '[1, 5]' - floatspan '[3, 4]';
-- {[1, 3), (4, 5]}
SELECT tstzspanset '{[2001-01-01, 2001-01-06], [2001-01-07, 2001-01-10]}' -
  tstzspanset '{[2001-01-02, 2001-01-03], [2001-01-04, 2001-01-05],
  [2001-01-08, 2001-01-09]}';
/* {[2001-01-01,2001-01-02), (2001-01-03,2001-01-04), (2001-01-05,2001-01-06],
   [2001-01-07,2001-01-08), (2001-01-09,2001-01-10]} */
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT tstzset '{2001-01-01, 2001-01-03}' * tstzset '{2001-01-03, 2001-01-05}';
-- {2001-01-03}
SELECT intspan '[1, 5)' * intspan '[3, 6)';
-- [3, 5)
SELECT floatspanset '{[1, 5),[6, 8)}' * floatspan '[1, 6)';
-- {[3, 5)}
SELECT tstzspan '[2001-01-01, 2001-01-05)' * tstzspan '[2001-01-03, 2001-01-07)';
-- [2001-01-03, 2001-01-05)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="setspan_topo_pos">
		<title>Operaciones de cuadro delimitador</title>
		<sect2>
			<title>Operaciones topológicas</title>
			<para>A continuación se presentan los operadores topológicos disponibles para los tipos de conjunto y de rango.</para>
		<itemizedlist>
				<listitem xml:id="setspan_overlaps">
					<indexterm significance="normal"><primary><varname>&amp;&amp;</varname></primary></indexterm>
					<para>¿Se superponen los valores (tienen valores en común)?</para>
					<para><varname>{set,spans} &amp;&amp; {set,spans} → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intset '{1, 3}' &amp;&amp; intset '{2, 3, 4}';
-- true
SELECT floatspan '[1, 3)' &amp;&amp; floatspan '[3, 4)';
-- false
SELECT floatspanset '{[1, 5),[6, 8)}' &amp;&amp; floatspan '[1, 6)';
-- true
SELECT tstzspan '[2001-01-01, 2001-01-05)' &amp;&amp; tstzspan '[2001-01-02, 2001-01-07)';
-- true
</programlisting>
				</listitem>

				<listitem xml:id="setspan_contains">
					<indexterm significance="normal"><primary><varname>@&gt;</varname></primary></indexterm>
					<para>¿Contiene el primer valor el segundo?</para>
					<para><varname>{set,spans} @&gt; {base,set,span} → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatset '{1.5, 2.5}' @&gt; 2.5;
-- true
SELECT tstzspan '[2001-01-01, 2001-05-01)' @&gt; timestamptz '2001-02-01';
-- true
SELECT floatspanset '{[1, 2),(2, 3)}' @&gt; 2.0;
-- false
</programlisting>
				</listitem>

				<listitem xml:id="setspan_containedby">
					<indexterm significance="normal"><primary><varname>&lt;@</varname></primary></indexterm>
					<para>¿Está el primer valor contenido en el segundo?</para>
					<para><varname>{base,set,spans} &lt;@ {set,spans} → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestamptz '2001-01-10' &lt;@ tstzspan '[2001-01-01, 2001-05-01)';
-- true
SELECT floatspan '[2, 5]' &lt;@ floatspan '[1, 5)';
-- false
SELECT floatspanset '{[1,2],[3,4]}' &lt;@ floatspan '[1, 6]';
-- true
SELECT tstzspan '[2001-02-01, 2001-03-01)' &lt;@ tstzspan '[2001-01-01, 2001-05-01)';
-- true
</programlisting>
				</listitem>

				<listitem xml:id="setspan_adjacent">
					<indexterm significance="normal"><primary><varname>-|-</varname></primary></indexterm>
					<para>¿Es el primer valor adyacente al segundo?</para>
					<para><varname>spans -|- spans → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[2, 6)' -|- intspan '[6, 7)';
-- true
SELECT floatspan '[2, 5)' -|- floatspan '(5, 6)';
-- false
SELECT floatspanset '{[2, 3],[4, 5)}' -|- floatspan '(5, 6)';
-- true
SELECT tstzspan '[2001-01-01, 2001-01-05)' -|- tstzset '{2001-01-05, 2001-01-07}';
-- true
SELECT tstzspanset '{[2001-01-01, 2001-01-02]}' -|- tstzspan '[2001-01-02, 2001-01-03)';
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Operaciones de posición</title>
			<para>Los operadores de posición disponibles para los tipos de conjunto y de rango se dan a continuación. Observe que los operadores para tipos de tiempo tienen un <varname>#</varname> adicional para distinguirlos de los operadores para tipos de números.</para>

			<itemizedlist>
				<listitem xml:id="setspan_left">
					<indexterm significance="normal"><primary><varname>&lt;&lt;</varname></primary></indexterm>
					<indexterm significance="normal"><primary><varname>&lt;&lt;#</varname></primary></indexterm>
					<para>¿Está el primer valor estrictamente a la izquierda del segundo?</para>
					<para><varname>numbers &lt;&lt; numbers → boolean</varname></para>
					<para><varname>times &lt;&lt;# times → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &lt;&lt; 20;
-- true
SELECT intspanset '{[15, 17],[18, 20)}' &lt;&lt; 20;
-- true
SELECT floatspan '[15, 20)' &lt;&lt; floatspan '(15, 20)';
-- false
SELECT dateset '{2001-01-01, 2001-01-02}' &lt;&lt;# dateset '{2001-01-03, 2001-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem xml:id="setspan_right">
					<indexterm significance="normal"><primary><varname>&gt;&gt;</varname></primary></indexterm>
					<indexterm significance="normal"><primary><varname>#&gt;&gt;</varname></primary></indexterm>
					<para>¿Está el primer valor estrictamente a la derecha del segundo?</para>
					<para><varname>numbers &gt;&gt; numbers → boolean</varname></para>
					<para><varname>times #&gt;&gt; times → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &gt;&gt; 10;
-- true
SELECT floatspan '[15, 20)' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT floatspanset '{[15, 17], [18, 20)}' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT tstzspan '[2001-01-04, 2001-01-05)' #&gt;&gt;
  tstzspanset '{[2001-01-01, 2001-01-04), [2001-01-05, 2001-01-06)}';
-- true
</programlisting>
				</listitem>

				<listitem xml:id="setspan_overleft">
					<indexterm significance="normal"><primary><varname>&amp;&lt;</varname></primary></indexterm>
					<indexterm significance="normal"><primary><varname>&amp;&lt;#</varname></primary></indexterm>
					<para>¿No está el primer valor a la derecha del segundo?</para>
					<para><varname>numbers &amp;&lt; numbers → boolean</varname></para>
					<para><varname>times &amp;&lt;# times → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&lt; 18;
-- false
SELECT intspanset '{[15, 16],[17, 18)}' &amp;&lt; 18;
-- true
SELECT floatspan '[15, 20)' &amp;&lt; floatspan '[10, 20]';
-- true
SELECT dateset '{2001-01-02, 2001-01-05}' &amp;&lt;# dateset '{2001-01-01, 2001-01-04}';
-- false
</programlisting>
				</listitem>

				<listitem xml:id="setspan_overright">
					<indexterm significance="normal"><primary><varname>&amp;&gt;</varname></primary></indexterm>
					<indexterm significance="normal"><primary><varname>#&amp;&gt;</varname></primary></indexterm>
					<para>¿No está el primer valor a la izquierda del segundo?</para>
					<para><varname>numbers &amp;&gt; numbers → boolean</varname></para>
					<para><varname>times #&amp;&gt; times → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&gt; 30;
-- true
SELECT floatspan '[1, 6]' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT floatspanset '{[1, 2],[3, 4]}' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT timestamp '2001-01-01' #&amp;&gt; tstzspan '[2001-01-01, 2001-01-05)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 xml:id="setspan_splitting">
			<title>Operaciones de división</title>

			<para>Al crear índices para tipos de conjuntos o conjunto de rangos, lo que se almacena en el índice no es el valor real, sino un cuadro delimitador que <emphasis>representa</emphasis> el valor. En este caso, el índice proporcionará una lista de valores candidatos que <emphasis>pueden</emphasis> satisfacer el predicado de la consulta, y se necesita un segundo paso para filtrar los valores candidatos calculando el predicado de la consulta sobre los valores reales.</para>

			<para>Sin embargo, cuando los cuadros delimitadores tienen un gran espacio vacío no cubierto por los valores reales, el índice generará muchos valores candidatos que no satisfacen el predicado de la consulta, lo que reduce la eficiencia del índice. En estas situaciones, puede ser mejor representar un valor no con un cuadro delimitador <emphasis>único</emphasis>, sino con <emphasis>múltiples</emphasis> cuadros delimitadores. Esto aumenta considerablemente la eficiencia del índice, siempre que el índice sea capaz de gestionar múltiples cuadros delimitadores por valor. Las siguientes funciones se utilizan para generar múltiples rangos a partir de un único valor de conjunto o conjunto de rangos.</para>

			<itemizedlist>
				<listitem xml:id="splitNSpans">
					<indexterm significance="normal"><primary><varname>splitNSpans</varname></primary></indexterm>
					<para>Devuelve una matriz de N rangos obtenida fusionando los elementos de un conjunto o los rangos de un conjunto de rangos</para>
					<para><varname>splitNSpans(set, integer) → span[]</varname></para>
					<para><varname>splitNSpans(spanset, integer) → span[]</varname></para>
					<para>El último argumento especifica el número de rangos de salida. Si el número de elementos o rangos de entrada es menor que el número especificado, la matriz resultante tendrá un rango por elemento o rango de entrada. De lo contrario, el número especificado de rangos de salida se obtendrá fusionando elementos o rangos de entrada consecutivos.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 1);
/* {"[1, 11)"} */
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 3);
-- {"[1, 5)","[5, 8)","[8, 11)"}
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 6);
-- {"[1, 3)","[3, 5)","[5, 7)","[7, 9)","[9, 10)","[10, 11)"}
SELECT splitNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 12);
/* {"[1, 2)","[2, 3)","[3, 4)","[4, 5)","[5, 6)","[6, 7)","[7, 8)","[8, 9)",
    "[9, 10)","[10, 11)"} */
</programlisting>
					<programlisting language="sql" xml:space="preserve">
SELECT splitNSpans(intspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}');
-- {"[1, 2)","[3, 4)","[5, 6)","[7, 8)","[9, 10)"}
SELECT splitNSpans(floatspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}', 3);
-- {"[1, 4)","[5, 8)","[9, 10)"}
SELECT splitNSpans(datespanset '{[2000-01-01, 2000-01-04), [2000-01-05, 2000-01-10)}', 3);
-- {"[2000-01-01, 2000-01-04)","[2000-01-05, 2000-01-10)"}
</programlisting>
				</listitem>

				<listitem xml:id="splitEachNSpans">
					<indexterm significance="normal"><primary><varname>splitEachNSpans</varname></primary></indexterm>
					<para>Devuelve una matriz de rangos obtenida fusionando N elementos consecutivos de un conjunto o N rangos consecutivos de un conjunto de rangos</para>
					<para><varname>splitEachNSpans(set, integer) → span[]</varname></para>
					<para><varname>splitEachNSpans(spanset, integer) → span[]</varname></para>
					<para>El último argumento especifica el número de elementos de entrada que se fusionan para producir un rango de salida. Si la cantidad de elementos de entrada es menor que el número especificado, la matriz resultante tendrá un rango de salida por elemento. De lo contrario, la cantidad especificada de elementos de entrada consecutivos se fusionará en un único rango de salida en la respuesta. Observe que, a diferencia de la función <link linkend="splitNSpans"><varname>splitNSpans</varname></link>, el número de rangos en el resultado depende del número de elementos o de rangos de entrada.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT splitEachNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 1);
/* {"[1, 2)","[2, 3)","[3, 4)","[4, 5)","[5, 6)","[6, 7)","[7, 8)","[8, 9)",
    "[9, 10)","[10, 11)"} */
SELECT splitEachNSpans(intspanset '{[1, 2), [3, 4), [5, 6), [7, 8), [9, 10)}', 3);
-- {"[1, 6)","[7, 10)"}
SELECT splitEachNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 6);
-- {"[1, 7)","[7, 11)"}
SELECT splitEachNSpans(intset '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}', 12);
-- {"[1, 11)"}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 xml:id="setspan_distance">
		<title>Operaciones de distancia</title>

		<para>El operador de distancia <varname>&lt;-&gt;</varname> para los tipos de rango o de tiempo considera el lapso o período delimitador y devuelve la distancia más pequeña entre los dos valores. En el caso de valores de tiempo, el operador devuelve la cantidad de días o la cantidad de segundos entre los dos valores de tiempo. El operador de distancia también se puede usar para búsquedas de vecinos más cercanos utilizando un índice GiST o SP-GiST (ver <xref linkend="setspan_indexing" />).</para>

		<itemizedlist>
			<listitem xml:id="smallest_distance_time">
				<indexterm significance="normal"><primary><varname>&lt;-&gt;</varname></primary></indexterm>
				<para>Devuelve la distancia mínima</para>
				<para><varname>numbers &lt;-&gt; numbers → base</varname></para>
				<para><varname>dates &lt;-&gt; dates → integer</varname></para>
				<para><varname>times &lt;-&gt; times → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT 3 &lt;-&gt; intspan '[6, 8)';
-- 3
SELECT floatspan '[1, 3]' &lt;-&gt; floatspan '(5.5, 7]';
-- 2.5
SELECT floatspan '[1, 3]' &lt;-&gt; floatspanset '{(5.5, 7],[8, 9]}';
-- 2.5
SELECT tstzspan '[2001-01-02, 2001-01-06)' &lt;-&gt; timestamptz '2001-01-07';
-- 86400
SELECT dateset '{2001-01-01, 2001-01-03, 2001-01-05}' &lt;-&gt;
  dateset '{2001-01-02, 2001-01-04}';
--  0
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="setspan_comparisons">
		<title>Comparaciones</title>

		<para>Los operadores de comparación (<varname>=</varname>, <varname>&lt;</varname>, etc.) requieren que los argumentos izquierdo y derecho sean del mismo tipo. Exceptuando la igualdad y la no igualdad, los otros operadores de comparación no son útiles en el mundo real, pero permiten construir índices de árbol B en tipos de rango o de tiempo. Para los valores de rango, los operadores comparan primero el límite inferior y luego el límite superior. Para los valores de conjunto de marcas de tiempo y conjunto de períodos, los operadores comparan primero los períodos delimitadores y, si son iguales, comparan los primeros N instantes o períodos, donde N es el mínimo del número de instantes o períodos que componen ambos valores.</para>

		<para>Los operadores de comparación disponibles para los tipos de conjunto y de rango se dan a continuación. Recuerde que los rangos de enteros siempre se representan por su forma canónica.</para>

		<itemizedlist>
			<listitem xml:id="setspan_eq">
				<indexterm significance="normal"><primary><varname>=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&gt;=</varname></primary></indexterm>
				<para>Comparaciones tradicionales</para>
				<para><varname>set {=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=} set → boolean</varname></para>
				<para><varname>spans {=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=} spans → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1,3]' = intspan '[1,4)';
-- true
SELECT floatspanset '{[1, 2),[2,3)}' = floatspanset '{[1,3)}';
-- true
SELECT tstzset '{2001-01-01, 2001-01-04}' &lt;&gt; tstzset '{2001-01-01, 2001-01-05}';
-- false
SELECT tstzspan '[2001-01-01, 2001-01-04)' &lt;&gt; tstzspan '[2001-01-03, 2001-01-05)';
-- true
SELECT floatspan '[3, 4]' &lt; floatspan '(3, 4]';
-- true
SELECT intspanset '{[1,2],[3,4]}' &lt; intspanset '{[3, 4]}';
-- true
SELECT floatspan '[3, 4]' &gt; floatspan '[3, 4)';
-- true
SELECT tstzspan '[2001-01-03, 2001-01-04)' &gt; tstzspan '[2001-01-02, 2001-01-05)';
-- true
SELECT floatspanset '{[1, 4)}' &lt;= floatspanset '{[1, 5), [6, 7)}';
-- true
SELECT tstzspanset '{[2001-01-01, 2001-01-04)}' &lt;=
  tstzspanset '{[2001-01-01, 2001-01-05), [2001-01-06, 2001-01-07)}';
-- true
SELECT tstzspan '[2001-01-03, 2001-01-05)' &gt;= tstzspan '[2001-01-03, 2001-01-04)';
-- true
SELECT intspanset '{[1, 4)}' &gt;= intspanset '{[1, 5), [6, 7)}';
-- false
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

		<sect1 xml:id="setspan_agg">
		<title>Agregaciones</title>

		<para>Hay varias funciones agregadas definidas para los tipos de conjunto y de rango. Estas se describen a continuación.</para>

		<itemizedlist>
			<listitem><para>La función <varname>extent</varname> devuelve el rango o período delimitador que engloba un conjunto de valores de rango o de tiempo.</para></listitem>
			<listitem><para>La unión es una operación muy útil para los tipos de conjunto y de rango. Como hemos visto en la <xref linkend="setspan_set_ops" />, podemos calcular la unión de dos valores de conjunto o de rango usando el operador <varname>+</varname>. Sin embargo, también es muy útil tener una versión agregada del operador de unión para combinar un número arbitrario de valores. Las funciones <varname>set_union</varname> y <varname>span_union</varname> se pueden utilizar para este propósito.</para></listitem>
			<listitem><para>La función <varname>tCount</varname> generaliza la función de agregación tradicional <varname>count</varname>. El conteo temporal se puede utilizar para calcular en cada momento el número de objetos disponibles (por ejemplo, el número of períodos). La función <varname>tCount</varname> devuelve un entero temporal (ver el <xref linkend="ttype_aggregation" />). La función tiene dos parámetros opcionales que especifican la granularidad (un <varname>interval</varname>) y el origen del tiempo (un <varname>timestamptz</varname>). Cuando se dan estos parámetros, el conteo temporal se calcula en rangos de tiempo de la granularidad dada (ver <xref linkend="ttype_tiling" />)</para></listitem>
		</itemizedlist>

		<itemizedlist>
			<listitem xml:id="setspan_extent">
				<indexterm significance="normal"><primary><varname>extent</varname></primary></indexterm>
				<para>Rango o período delimitador</para>
				<para><varname>extent({set,spans}) → span</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH spans(r) AS (
  SELECT floatspan '[1, 4)' UNION SELECT floatspan '(5, 8)' UNION
  SELECT floatspan '(7, 9)' )
SELECT extent(r) FROM spans;
-- [1,9)
WITH times(ts) AS (
  SELECT tstzset '{2001-01-01, 2001-01-03, 2001-01-05}' UNION
  SELECT tstzset '{2001-01-02, 2001-01-04, 2001-01-06}' UNION
  SELECT tstzset '{2001-01-01, 2001-01-02}' )
SELECT extent(ts) FROM times;
-- [2001-01-01, 2001-01-06]
WITH periods(ps) AS (
  SELECT tstzspanset '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}' UNION
  SELECT tstzspanset '{[2001-01-01, 2001-01-04], [2001-01-05, 2001-01-06]}' UNION
  SELECT tstzspanset '{[2001-01-02, 2001-01-06]}' )
SELECT extent(ps) FROM periods;
-- [2001-01-01, 2001-01-06]
</programlisting>
			</listitem>

			<listitem xml:id="setspan_union_agg">
				<indexterm significance="normal"><primary><varname>setUnion</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>spanUnion</varname></primary></indexterm>
				<para>Unión agregada</para>
				<para><varname>setUnion({value,set}) → set</varname></para>
				<para><varname>spanUnion(spans) → spanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT tstzset '{2001-01-01, 2001-01-03, 2001-01-05}' UNION
  SELECT tstzset '{2001-01-02, 2001-01-04, 2001-01-06}' UNION
  SELECT tstzset '{2001-01-01, 2001-01-02}' )
SELECT setUnion(ts) FROM times;
-- {2001-01-01, 2001-01-02, 2001-01-03, 2001-01-04, 2001-01-05, 2001-01-06}
WITH periods(ps) AS (
  SELECT tstzspanset '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}' UNION
  SELECT tstzspanset '{[2001-01-02, 2001-01-03], [2001-01-05, 2001-01-06]}' UNION
  SELECT tstzspanset '{[2001-01-07, 2001-01-08]}' )
SELECT spanUnion(ps) FROM periods;
-- {[2001-01-01, 2001-01-04], [2001-01-05, 2001-01-06], [2001-01-07, 2001-01-08]}
</programlisting>
			</listitem>

			<listitem xml:id="setspan_tCount">
				<indexterm significance="normal"><primary><varname>tCount</varname></primary></indexterm>
				<para>Conteo temporal</para>
				<para><varname>tCount(times) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT tstzset '{2001-01-01, 2001-01-03, 2001-01-05}' UNION
  SELECT tstzset '{2001-01-02, 2001-01-04, 2001-01-06}' UNION
  SELECT tstzset '{2001-01-01, 2001-01-02}' )
SELECT tCount(ts) FROM times;
-- {2@2001-01-01, 2@2001-01-02, 1@2001-01-03, 1@2001-01-04, 1@2001-01-05, 1@2001-01-06}
WITH periods(ps) AS (
  SELECT tstzspanset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}' UNION
  SELECT tstzspanset '{[2001-01-01, 2001-01-04), [2001-01-05, 2001-01-06)}' UNION
  SELECT tstzspanset '{[2001-01-02, 2001-01-06)}' )
SELECT tCount(ps) FROM periods;
-- {[2@2001-01-01, 3@2001-01-03, 1@2001-01-04, 2@2001-01-05, 2@2001-01-06)}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id ="setspan_indexing">
		<title>Indexación</title>

		<para>Se pueden crear índices GiST y SP-GiST en columnas de tablas de los tipos de conjunto y de rango. El índice GiST implementa un árbol R, mientras que el índice SP-GiST implementa un árbol cuádruple. Un ejemplo de creación de un índice GiST en una columna <varname>During</varname> de tipo <varname>tstzspan</varname> en una tabla <varname>Reservation</varname> es como sigue:
			<programlisting language="sql" xml:space="preserve">
CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,
  During tstzspan);
CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);
</programlisting>
		</para>
		<para>Un índice GiST o SP-GiST puede acelerar las consultas que involucran a los siguientes operadores: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>&amp;&lt;#</varname>, <varname>#&amp;&gt;</varname> y <varname>&lt;-&gt;</varname>.</para>
		<para>Además, se pueden crear índices de árbol B para columnas de tabla de un tipo de rango o de tiempo. Para estos tipos de índices, básicamente la única operación útil es la igualdad. Hay un orden de clasificación de árbol B definido para valores de tipos de rango o de tiempo con los correspondientes operadores <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname> y <varname>&gt;=</varname>, pero el orden es bastante arbitrario y no suele ser útil en el mundo real. El soporte del árbol B está destinado principalmente a permitir la clasificación interna en las consultas, en lugar de la creación de índices reales.</para>
		<para>Finalmente, se pueden crear índices hash para columnas de tabla de un tipo de rango o de tiempo. Para estos tipos de índices, la única operación definida es la igualdad.</para>
	</sect1>
</chapter>
