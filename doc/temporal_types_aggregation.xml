<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="temporal_types_aggregation">
	<title>Temporal Types: Aggregation and Indexing</title>

	<sect1 id="temporal_types_aggregations">
		<title>Aggregation</title>

		<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant in the <emphasis>union</emphasis> of the temporal extents of the values to aggregate. In contrast, recall that all other functions manipulating temporal types compute the value of the function at every instant in the <emphasis>intersection</emphasis> of the temporal extents of the arguments.</para>

		<para>The temporal aggregate functions are the following ones:</para>
		<itemizedlist>
			<listitem><para>For all temporal types, the function <varname>tcount</varname> generalize the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available objects (for example, number of cars in an area).</para></listitem>
			<listitem><para>For all temporal types, function <varname>extent</varname> returns a bounding box that encloses a set of temporal values. Depending on the base type, the result of this function can be a <varname>tstzspan</varname>, a <varname>tbox</varname> or an <varname>stbox</varname>.</para></listitem>
			<listitem><para>For the temporal Boolean type, the functions <varname>tand</varname> and <varname>tor</varname> generalize the traditional functions <varname>and</varname> and <varname>or</varname>.</para></listitem>
			<listitem><para>For temporal numeric types, there are two types of temporal aggregate functions. The functions <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname>, and <varname>tavg</varname> generalize the traditional functions <varname>min</varname>, <varname>max</varname>, <varname>sum</varname>, and <varname>avg</varname>. Furthermore, the functions <varname>wmin</varname>, <varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname>, and <varname>wavg</varname> are window (or cumulative) versions of the traditional functions that, given a time interval w, compute the value of the function at an instant t by considering the values during the interval [t-w, t]. All window aggregate functions are available for temporal integers, while for temporal floats only window minimum and maximum are meaningful.</para></listitem>
			<listitem><para>For the temporal text type, the functions <varname>tmin</varname> y <varname>tmax</varname> generalize the traditional functions <varname>min</varname> and <varname>max</varname>.</para></listitem>
			<listitem><para>Finally, for temporal point types, the function <varname>tcentroid</varname> generalizes the function <varname>ST_Centroid</varname> provided by PostGIS. For example, given set of objects that move together (that is, a convoy or a flock) the temporal centroid will produce a temporal point that represents at each instant the geometric center (or the center of mass) of all the moving objects.</para></listitem>
		</itemizedlist>

		<para>In the examples that follow, we suppose the tables <varname>Department</varname> and <varname>Trip</varname> contain the two tuples introduced in <xref linkend="temporal_types_examples" />.</para>
		<itemizedlist>
			<listitem id="tcount">
				<indexterm><primary><varname>tcount</varname></primary></indexterm>
				<para>Temporal count</para>
				<para><varname>tcount(ttype) → {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcount(NoEmps) FROM Department;
-- {[1@2001-01-01, 2@2001-02-01, 1@2001-08-01, 1@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="extent">
				<indexterm><primary><varname>extent</varname></primary></indexterm>
				<para>Bounding box extent</para>
				<para><varname>extent(temp) → {tstzspan,tbox,stbox}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT extent(noEmps) FROM Department;
-- TBOX XT((4,12),[2001-01-01,2001-10-01])
SELECT extent(Trip) FROM Trips;
-- STBOX XT(((0,0),(3,3)),[2001-01-01 08:00:00+01, 2001-01-01 08:20:00+01))
</programlisting>
			</listitem>

			<listitem id="tand">
				<indexterm><primary><varname>tand</varname></primary></indexterm>
				<para>Temporal and</para>
				<para><varname>tand(tbool) → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tand(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-04-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tor">
				<indexterm><primary><varname>tor</varname></primary></indexterm>
				<para>Temporal or</para>
				<para><varname>tor(tbool) → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tor(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-08-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmin">
				<indexterm><primary><varname>tmin</varname></primary></indexterm>
				<para>Temporal minimum</para>
				<para><varname>tmin(ttype) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmin(NoEmps) FROM Department;
-- {[10@2001-01-01, 4@2001-02-01, 6@2001-06-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmax">
				<indexterm><primary><varname>tmax</varname></primary></indexterm>
				<para>Temporal maximum</para>
				<para><varname>tmax(ttype) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmax(NoEmps) FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tsum">
				<indexterm><primary><varname>tsum</varname></primary></indexterm>
				<para>Temporal sum</para>
				<para><varname>tsum(tnumber) → {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tsum(NoEmps) FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 16@2001-04-01, 18@2001-06-01, 6@2001-08-01,
   6@2001-10-01)} */
</programlisting>
			</listitem>

			<listitem id="tavg">
				<indexterm><primary><varname>tavg</varname></primary></indexterm>
				<para>Temporal average</para>
				<para><varname>tavg(tnumber) → {tfloat_seq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tavg(NoEmps) FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8@2001-04-01, 8@2001-06-01), [9@2001-06-01, 9@2001-08-01),
   [6@2001-08-01, 6@2001-10-01) */
</programlisting>
			</listitem>

			<listitem id="wmin">
				<indexterm><primary><varname>wmin</varname></primary></indexterm>
				<para>Window minimum</para>
				<para><varname>wmin(tnumber,interval) → {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmin(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 4@2001-04-01, 6@2001-06-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wmax">
				<indexterm><primary><varname>wmax</varname></primary></indexterm>
				<para>Window maximum</para>
				<para><varname>wmax(tnumber,interval) → {tnumber_discseq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmax(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wcount">
				<indexterm><primary><varname>wcount</varname></primary></indexterm>
				<para>Window count</para>
				<para><varname>wcount(tnumber,interval) → {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wcount(NoEmps, interval '2 days') FROM Department;
/* {[1@2001-01-01, 2@2001-02-01, 3@2001-04-01, 2@2001-04-03, 3@2001-06-01, 2@2001-06-03,
   1@2001-08-03, 1@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wsum">
				<indexterm><primary><varname>wsum</varname></primary></indexterm>
				<para>Window sum</para>
				<para><varname>wsum(tint,interval) → {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wsum(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 26@2001-04-01, 16@2001-04-03, 22@2001-06-01,
   18@2001-06-03, 6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wavg">
				<indexterm><primary><varname>wavg</varname></primary></indexterm>
				<para>Window average</para>
				<para><varname>wavg(tint,interval) → {tfloat_seq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wavg(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8.66666666666667@2001-04-01, 8.66666666666667@2001-04-03),
   [8@2001-04-03, 8@2001-06-01),
   [7.33333333333333@2001-06-01, 7.33333333333333@2001-06-03),
   [9@2001-06-03, 9@2001-08-03), [6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="tcentroid">
				<indexterm><primary><varname>tcentroid</varname></primary></indexterm>
				<para>Temporal centroid</para>
				<para><varname>tcentroid(tgeompoint) → tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcentroid(Trip) FROM Trips;
/* {[POINT(0 0)@2001-01-01 08:00:00+00, POINT(1 0)@2001-01-01 08:05:00+00),
   [POINT(0.5 0)@2001-01-01 08:05:00+00, POINT(1.5 0.5)@2001-01-01 08:10:00+00,
   POINT(2 1.5)@2001-01-01 08:15:00+00),
   [POINT(2 2)@2001-01-01 08:15:00+00, POINT(3 3)@2001-01-01 08:20:00+00)} */
</programlisting>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1 id="temporal_types_indexing">
		<title>Indexing</title>
		<para>GiST and SP-GiST indexes can be created for table columns of temporal types. The GiST index implements an R-tree and the SP-GiST index implements an n-dimensional quad-tree. Examples of index creation are as follows:
			<programlisting language="sql" xml:space="preserve">
CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		</para>

		<para>The GiST and SP-GiST indexes store the bounding box for the temporal types. As explained in <xref linkend="temporal_types" />, these are
			<itemizedlist>
				<listitem>
					<para>the <varname>tstzspan</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>A GiST or SP-GiST index can accelerate queries involving the following operators (see <xref linkend="temporal_types_bbox" /> for more information):
			<itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, which only consider the value dimension in temporal alphanumeric types,</para>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, and <varname>/&amp;&gt;</varname>, which only consider the spatial dimension in temporal point types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, which only consider the time dimension for all temporal types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, and <varname>|=|</varname>, which consider as many dimensions as they are shared by the indexed column and the query argument. These operators work on bounding boxes (that is, <varname>tstzspan</varname>, <varname>tbox</varname>, or <varname>stbox</varname>), not the entire values.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>For example, given the index defined above on the <varname>Department</varname> table and a query that involves a condition with the <varname>&amp;&amp;</varname> (overlaps) operator, if the right argument is a temporal float then both the value and the time dimensions are considered for filtering the tuples of the relation, while if the right argument is a float value, a float span, or a time type, then either the value or the time dimension will be used for filtering the tuples of the relation. Furthermore, a bounding box can be constructed from a value/span and/or a timestamp/period, which can be used for filtering the tuples of the relation. Examples of queries using the index on the <varname>Department</varname> table defined above are given next.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Department WHERE NoEmps &amp;&amp; intspan '[1, 5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; tstzspan '[2001-04-01, 2001-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tbox(intspan '[1, 5)', tstzspan '[2001-04-01, 2001-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tfloat '{[1@2001-01-01, 1@2001-02-01), [5@2001-04-01, 5@2001-05-01)}';
</programlisting>
		</para>

		<para>Similarly, examples of queries using the index on the <varname>Trips</varname> table defined above are given next.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; tstzspan '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;
  stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', tstzspan '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;
  tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
</programlisting>
		</para>

		<para>Finally, B-tree indexes can be created for table columns of all temporal types. For this index type, the only useful operation is equality. There is a B-tree sort ordering defined for values of temporal types, with corresponding <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname>, <varname>&gt;=</varname> and operators, but the ordering is rather arbitrary and not usually useful in the real world. B-tree support for temporal types is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>

		<para>In order to speed up several of the functions for temporal types, we can add in the <varname>WHERE</varname> clause of queries a bounding box comparison that make uses of the available indexes. For example, this would be typically the case for the functions that project the temporal types to the value/spatial and/or time dimensions. This will filter out the tuples with an index as shown in the following query.
			<programlisting language="sql" xml:space="preserve">
SELECT atTime(T.Trip, tstzspan '[2001-01-01, 2001-01-02)')
FROM Trips T
-- Bouding box index filtering
WHERE T.Trip &amp;&amp; tstzspan '[2001-01-01, 2001-01-02)';
</programlisting>
		</para>

		<para>In the case of temporal points, all spatial relationships with the ever semantics (see <xref linkend="tpoint_spatial_rel" />) automatically include a bounding box comparison that will make use of any indexes that are available on the temporal points. For this reason, the first version of the relationships is typically used for filtering the tuples with the help of an index when computing the temporal relationships as shown in the following query.
			<programlisting language="sql" xml:space="preserve">
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Bouding box index filtering
WHERE intersects(T.Trip, R.Geom);
</programlisting>
		</para>
	</sect1>

	<sect1 id="temporal_types_statistics">
		<title>Statistics and Selectivity</title>
		<sect2>
			<title>Statistics Collection</title>
			<para>The PostgreSQL planner relies on statistical information about the contents of tables in order to generate the most efficient execution plan for queries. These statistics include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. For large tables, a random sample of the table contents is taken, rather than examining every row. This enables large tables to be analyzed in a small amount of time. The statistical information is gathered by the <varname>ANALYZE</varname> command and stored in the <varname>pg_statistic</varname> catalog table. Since different kinds of statistics may be appropriate for different kinds of data, the table only stores very general statistics (such as number of null values) in dedicated columns. Everything else is stored in five &ldquo;slots&rdquo;, which are couples of array columns that store the statistics for a column of an arbitrary type.</para>

			<para>The statistics collected for time types and temporal types are based on those collected by PostgreSQL for scalar types and span types. For scalar types, such as <varname>float</varname>, the following statistics are collected:
				<orderedlist numeration="arabic">
					<listitem>
						<para>fraction of null values,</para>
					</listitem>
					<listitem>
						<para>average width, in bytes, of non-null values,</para>
					</listitem>
					<listitem>
						<para>number of different non-null values,</para>
					</listitem>
					<listitem>
						<para>array of most common values and array of their frequencies,</para>
					</listitem>
					<listitem>
						<para>histogram of values, where the most common values are excluded,</para>
					</listitem>
					<listitem>
						<para>correlation between physical and logical row ordering.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>For range types, like <varname>tstzrange</varname>, three additional histograms are collected:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>length histogram of non-empty ranges,</para>
					</listitem>
					<listitem>
						<para>histograms of lower and upper bounds.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>For geometries, in addition to (1)&#x2013;(3), the following statistics are collected:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>number of dimensions of the values, N-dimensional bounding box, number of rows in the table, number of rows in the sample, number of non-null values,</para>
					</listitem>
					<listitem>
						<para>N-dimensional histogram that divides the bounding box into a number of cells and keeps the proportion of values that intersects with each cell.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>The statistics collected for columns of the time and span types <varname>tstzset</varname>, <varname>tstzspan</varname>, <varname>tstzspanset</varname>, <varname>intspan</varname>, and <varname>floatspan</varname> replicate those collected by PostgreSQL for the <varname>tstzrange</varname>. This is clear for the span types in MobilityDB, which are more efficient versions of the range types in PostgreSQL. For the <varname>tstzset</varname> and the <varname>tstzspanset</varname> types, a value is converted into its bounding period, then the statistics for the <varname>tstzspan</varname> type are collected.</para>

			<para>The statistics collected for columns of temporal types depend on their subtype and their base type. In addition to statistics (1)&#x2013;(3) that are collected for all temporal types, statistics are collected for the time and the value dimensions independently. More precisely, the following statistics are collected for the time dimension:
				<itemizedlist>
					<listitem>
						<para>For columns of instant subtype, the statistics (4)&#x2013;(6) are collected for the timestamps.</para>
					</listitem>

					<listitem>
						<para>For columns of other subtype, the statistics (7)&#x2013;(8) are collected for the (bounding box) periods.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>The following statistics are collected for the value dimension:
				<itemizedlist>
					<listitem>
						<para>For columns of temporal types with step interpolation (that is, <varname>tbool</varname>, <varname>ttext</varname>, or <varname>tint</varname>):
							<itemizedlist>
								<listitem>
									<para>For the instant subtype, the statistics (4)&#x2013;(6) are collected for the values.</para>
								</listitem>

								<listitem>
									<para>For all other subtypes, the statistics (7)&#x2013;(8) are collected for the values.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>For columns of the temporal float type (that is, <varname>tfloat</varname>):
							<itemizedlist>
								<listitem>
									<para>For the instant subtype, the statistics (4)&#x2013;(6) are collected for the values.</para>
								</listitem>
								<listitem>
									<para>For all other subtype, the statistics (7)&#x2013;(8) are collected for the (bounding) value spans.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>For columns of temporal point types (that is, <varname>tgeompoint</varname> and <varname>tgeogpoint</varname>) the statistics (9)&#x2013;(10) are collected for the points.</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Selectivity Estimation</title>

			<para>Boolean operators in PostgreSQL can be associated with two selectivity functions, which compute how likely a value of a given type will match a given criterion. These selectivity functions rely on the statistics collected. There are two types of selectivity functions. The <emphasis>restriction</emphasis> selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>column OP constant</varname>. On the other hand, the <emphasis>join</emphasis> selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>table1.column1 OP table2.column2</varname>.</para>

			<para>MobilityDB defines 23 classes of Boolean operators (such as <varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), each of which can have as left or right arguments a PostgreSQL type (such as <varname>integer</varname>, <varname>timestamptz</varname>, etc.) or a MobilityDB type (such as <varname>tstzspan</varname>, <varname>tint</varname>, etc.). As a consequence, there is a very high number of operators with different arguments to be considered for the selectivity functions. The approach taken was to group these combinations into classes corresponding to the value and time dimensions. The classes correspond to the type of statistics collected as explained in the previous section.</para>

			<para>MobilityDB estimates both restriction and join selectivity for time, span, and temporal types.</para>
		</sect2>
	</sect1>
</chapter>
