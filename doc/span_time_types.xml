<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="span_time_types">
	<title>Span and Time Types</title>

	<para>
		MobilityDB has three span types, namely <varname>intspan</varname>, <varname>floatspan</varname>, and <varname>period</varname>, for representing, respectively, ranges of <varname>integer</varname>, <varname>float</varname>, and <varname>timestamptz</varname> (timestamp with time zone) values. Furthermore, MobilityDB has two additional time types, namely, <varname>timestampset</varname>, and <varname>periodset</varname>.
	</para>

	<para>
		The span types in MobilityDB correspond to the range types in PostgreSQL, where <varname>intspan</varname> and <varname>period</varname> correspond to <varname>int4range</varname> and <varname>tstzrange</varname>. However, span types in MobilityDB have a more efficient implementation than the range types in PostgreSQL. In particular, span types in MobilityDB are of fixed length while the range types in PostgreSQL are of variable length. Furthermore, empty ranges and infinite bounds are allowed in range values in PostgreSQL, while this is not allowed for span values in MobilityDB. In what follows, we explain the span types in MobilityDB using the <varname>period</varname> type but similar considerations apply to the <varname>intspan</varname> and <varname>floatspan</varname> types.
	</para>

	<sect1 id ="functions_operations_span_time_types">
		<title>Functions and Operators for Span and Time Types</title>

		<para>
			We present next the functions and operators for span and time types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this in the signature of the operators, we use the following notation:
		</para>
		<itemizedlist>
			<listitem>
				<para><varname>span</varname> represents any span type, that is, <varname>intspan</varname>, <varname>floatspan</varname>, or <varname>period</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>numspan</varname> represents any numeric span type, that is, <varname>intspan</varname> or <varname>floatspan</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>element</varname> represents any base type of a span type, that is, <varname>integer</varname>, <varname>float</varname>, or <varname>timestamptz</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>number</varname> represents any base type of a numeric span type, that is, <varname>integer</varname> or <varname>float</varname>,</para>
			</listitem>
			<listitem>
				<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
			</listitem>
			<listitem>
				<para>A set of types such as <varname>{period,timestampset,periodset}</varname> represents any of the types listed,</para>
			</listitem>
			<listitem>
				<para><varname>type[]</varname> represents an array of <varname>type</varname>.</para>
			</listitem>
		</itemizedlist>

		<para>
			As an example, the signature of the contains operator (<varname>@&gt;</varname>) is as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
{timestampset, period, periodset} @&gt; time: boolean
</programlisting>
		<para>
			In the following, for conciseness, the time part of the timestamps is omitted in the examples. Recall that in that case PostgreSQL assumes the time <varname>00:00:00</varname>.
		</para>

		<sect2>
			<title>Input/Output Functions</title>

			<para>
				MobilityDB generalizes Open Geospatial Consortium's Well-Known Text (WKT) and Well-Known Binary (WKB) input/output format for all temporal types. In this way, applications can exchange data between them using a standardized exchange format. The WKT format is human-readable while the WKB format is more compact and more efficient than the WKT format. The WKB format can be output either as a binary string or as a character string encoded in hexadecimal ASCII.
			</para>

			<para>
				A value of a span type has two bounds, the <emphasis>lower bound</emphasis> and the <emphasis>upper bound</emphasis>, which are values of the underlying <emphasis>base type</emphasis>. For example, a value of the <varname>period</varname> type has two bounds, which are <varname>timestamptz</varname> values. The bounds can be inclusive or exclusive. An inclusive bound means that the boundary instant is included in the span, while an exclusive bound means that the boundary instant is not included in the span. In the text form of a span value, inclusive and exclusive lower bounds are represented, respectively, by &ldquo;<varname>[</varname>&rdquo; and &ldquo;<varname>(</varname>&rdquo;. Likewise, inclusive and exclusive upper bounds are represented, respectively, by &ldquo;<varname>]</varname>&rdquo; and &ldquo;<varname>)</varname>&rdquo;. In a span value, the lower bound must be less than or equal to the upper bound. A span value with equal and inclusive bounds is called an <emphasis>instantaneous span</emphasis> and corresponds to a base type value. Examples of span values are as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)';
SELECT floatspan '[1.5, 3.5]';
SELECT period '[2001-01-01 08:00:00, 2001-01-03 09:30:00)';
-- Instant spans
SELECT intspan '[1, 1]';
SELECT floatspan '[1.5, 1.5]';
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:00:00]';
-- Erroneous span: invalid bounds
SELECT period '[2001-01-01 08:10:00, 2001-01-01 08:00:00]';
-- Erroneous span: empty span
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:00:00)';
</programlisting>

			<para>
				The <varname>timestampset</varname> type represents a set of different <varname>timestamptz</varname> values. A <varname>timestampset</varname> value must contain at least one element, in which case it corresponds to a <varname>timestamptz</varname> value. The elements composing a <varname>timestampset</varname> value must be ordered. Examples of <varname>timestampset</varname> values are as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT timestampset '{2001-01-01 08:00:00, 2001-01-03 09:30:00}';
-- Singleton timestampset
SELECT timestampset '{2001-01-01 08:00:00}';
-- Erroneous timestampset: unordered elements
SELECT timestampset '{2001-01-01 08:10:00, 2001-01-01 08:00:00}';
-- Erroneous timestampset: duplicate elements
SELECT timestampset '{2001-01-01 08:00:00, 2001-01-01 08:00:00}';
</programlisting>

			<para>
				Finally, the <varname>periodset</varname> type represents a set of disjoint <varname>period</varname> values. A <varname>periodset</varname> value must contain at least one element, in which case it corresponds to a <varname>period</varname> value. The elements composing a <varname>periodset</varname> value must be ordered. Examples of <varname>periodset</varname> values are as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:20:00, 2001-01-01 08:40:00]}';
-- Singleton periodset
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Erroneous periodset: unordered elements
SELECT periodset '{[2001-01-01 08:20:00, 2001-01-01 08:40:00],
  [2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Erroneous periodset: overlapping elements
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:05:00, 2001-01-01 08:15:00]}';
</programlisting>

			<para>
				Values of the <varname>periodset</varname> type are converted into <emphasis>normal form</emphasis> so that equivalent values have identical representations. For this, consecutive adjacent period values are merged when possible. An example of transformation into normal form is as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00),
  [2001-01-01 08:10:00, 2001-01-01 08:10:00], (2001-01-01 08:10:00, 2001-01-01 08:20:00]}';
-- {[2001-01-01 08:00:00+00,2001-01-01 08:20:00+00]}
</programlisting>

			<para>
				We give next the functions for input/output of span and time types in Well-Known Binary format.
			</para>

			<itemizedlist>
				<listitem id="spantime_asBinary">
					<indexterm><primary><varname>asBinary</varname></primary></indexterm>
					<para>Get the Well-Known Binary (WKB) representation</para>
					<para><varname>asBinary({span,timestampset,periodset}): bytea</varname></para>
					<para><varname>asBinary({span,timestampset,periodset},endian text): bytea</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asBinary(intspan '[1, 2]');
-- \x010800010100000003000000
SELECT asBinary(intspan '[1, 2]', 'XDR');
-- \x000008010000000100000003
SELECT asBinary(floatspan '[1.5, 2.5)');
-- \x01060001000000000000f83f0000000000000440
SELECT asBinary(period '[2001-01-01, 2001-01-03]');
-- \x010a000300fce0136a58010000bc8f4f92580100
SELECT asBinary(timestampset '{2001-01-01, 2001-01-03}');
-- \x010200000000fce0136a58010000bc8f4f92580100
SELECT asBinary(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}');
-- \x01020000000300fce0136a58010000bc8f4f9258010003001c676da6580100007c3e8bba580100
</programlisting>
				</listitem>

				<listitem id="spantime_asHexWKB">
					<indexterm><primary><varname>asHexWKB</varname></primary></indexterm>
					<para>Get the Hexadecimal Well-Known Binary (HexWKB) representation as text</para>
					<para><varname>asHexWKB({span,timestampset,periodset}): text</varname></para>
					<para><varname>asHexWKB({span,timestampset,periodset},endian text): text</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then NDR is used.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asHexWKB(intspan '[1, 2]');
-- 010800010100000003000000
SELECT asHexWKB(intspan '[1, 2]', 'XDR');
-- 000008010000000100000003
SELECT asHexWKB(floatspan '[1.5, 2.5)');
-- 01060001000000000000F83F0000000000000440
SELECT asHexWKB(period '[2001-01-01, 2001-01-03]');
-- 010A000300FCE0136A58010000BC8F4F92580100
SELECT asHexWKB(timestampset '{2001-01-01, 2001-01-03}');
-- 010200000000FCE0136A58010000BC8F4F92580100
SELECT asHexWKB(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}');
-- 01020000000300FCE0136A58010000BC8F4F9258010003001C676DA6580100007C3E8BBA580100
</programlisting>
				</listitem>

				<listitem id="intspanFromBinary">
					<indexterm><primary><varname>intspanFromBinary</varname></primary></indexterm>
					<para>Input an integer span from a Well-Known Binary (WKB) representation</para>
					<para><varname>intspanFromBinary(bytea): intspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanFromBinary('\x010800010100000003000000');
-- [1, 3)
</programlisting>
				</listitem>

				<listitem id="floatspanFromBinary">
					<indexterm><primary><varname>floatspanFromBinary</varname></primary></indexterm>
					<para>Input a float span from a Well-Known Binary (WKB) representation</para>
					<para><varname>floatspanFromBinary(bytea): floatspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspanFromBinary('\x01060001000000000000f83f0000000000000440');
-- [1.5, 2.5)
</programlisting>
				</listitem>

				<listitem id="periodFromBinary">
					<indexterm><primary><varname>periodFromBinary</varname></primary></indexterm>
					<para>Input a period from a Well-Known Binary (WKB) representation</para>
					<para><varname>periodFromBinary(bytea): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodFromBinary('\x010a000300fce0136a58010000bc8f4f92580100');
-- [2001-01-01, 2001-01-03]
</programlisting>
				</listitem>

				<listitem id="timestampsetFromBinary">
					<indexterm><primary><varname>timestampsetFromBinary</varname></primary></indexterm>
					<para>Input a timestamp set from a Well-Known Binary (WKB) representation</para>
					<para><varname>timestampsetFromBinary(bytea): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampsetFromBinary('\x010200000000fce0136a58010000bc8f4f92580100');
-- {2001-01-01, 2001-01-03}
</programlisting>
				</listitem>

				<listitem id="periodsetFromBinary">
					<indexterm><primary><varname>periodsetFromBinary</varname></primary></indexterm>
					<para>Input a period set from a Well-Known Binary (WKB) representation</para>
					<para><varname>periodsetFromBinary(bytea): periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodsetFromBinary(
  '\x01020000000300fce0136a58010000bc8f4f9258010003001c676da6580100007c3e8bba580100');
-- {[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}
</programlisting>
				</listitem>

				<listitem id="intspanFromHexWKB">
					<indexterm><primary><varname>intspanFromHexWKB</varname></primary></indexterm>
					<para>Input an integer span from an Hexadecimal Well-Known Binary (HexWKB) representation</para>
					<para><varname>intspanFromHexWKB(text): intspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanFromHexWKB('010800010100000003000000');
-- [1, 3)
</programlisting>
				</listitem>

				<listitem id="floatspanFromHexWKB">
					<indexterm><primary><varname>floatspanFromHexWKB</varname></primary></indexterm>
					<para>Input a float span from an Hexadecimal Well-Known Binary (HexWKB) representation</para>
					<para><varname>floatspanFromHexWKB(text): floatspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspanFromHexWKB('01060001000000000000F83F0000000000000440');
-- [1.5, 2.5)
</programlisting>
				</listitem>

				<listitem id="periodFromHexWKB">
					<indexterm><primary><varname>periodFromHexWKB</varname></primary></indexterm>
					<para>Input a period from an Hexadecimal Well-Known Binary (HexWKB) representation</para>
					<para><varname>periodFromHexWKB(text): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodFromHexWKB('010A000300FCE0136A58010000BC8F4F92580100');
-- [2001-01-01, 2001-01-03]
</programlisting>
				</listitem>

				<listitem id="timestampsetFromHexWKB">
					<indexterm><primary><varname>timestampsetFromHexWKB</varname></primary></indexterm>
					<para>Input a timestamp set from an Hexadecimal Well-Known Binary (HexWKB) representation</para>
					<para><varname>timestampsetFromHexWKB(text): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampsetFromHexWKB('010200000000FCE0136A58010000BC8F4F92580100');
-- {2001-01-01, 2001-01-03}
</programlisting>
				</listitem>

				<listitem id="periodsetFromHexWKB">
					<indexterm><primary><varname>periodsetFromHexWKB</varname></primary></indexterm>
					<para>Input a periodset from an Hexadecimal Well-Known Binary (HexWKB) representation</para>
					<para><varname>periodsetFromHexWKB(text): periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodsetFromHexWKB(
  '01020000000300FCE0136A58010000BC8F4F9258010003001C676DA6580100007C3E8BBA580100');
-- {[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Constructor Functions</title>

			<para>The span types have a constructor function that accepts four arguments. The first two arguments specify, respectively, the lower and upper bound, and the last two arguments are Boolean values stating, respectively, whether the lower and upper bounds are inclusive or not. The last two arguments are assumed to be true if not specified. Notice that integer spans are always transformed into <emphasis>normal form</emphasis>, that is, with inclusive lower bound and exclusive upper bound.
			</para>
			<itemizedlist>
				<listitem id="period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Constructor for span types</para>
					<para><varname>intspan(integer,integer,left_inc=true,right_inc=false): intspan</varname></para>
					<para><varname>floatspan(float,float,left_inc=true,right_inc=false): floatspan</varname></para>
					<para><varname>period(timestamptz,timestamptz,left_inc=true,right_inc=false): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
-- Float span defined with two arguments
SELECT floatspan(20.5, 25);
-- [20.5, 25)
-- Integer span defined with four arguments
SELECT SELECT intspan (20, 25, false, true);
-- [21, 26)
-- Period defined with four arguments
SELECT period('2001-01-01 08:00:00', '2001-01-03 09:30:00', false, true);
-- (2001-01-01 08:00:00+01, 2001-01-03 09:30:00+01]
</programlisting>
				</listitem>
			</itemizedlist>

			<para>The <varname>timestampset</varname> type has a constructor function that accepts a single argument which is an array of <varname>timestamptz</varname> values.
			</para>
			<itemizedlist>
				<listitem id="timestampset">
					<indexterm><primary><varname>timestampset</varname></primary></indexterm>
					<para>Constructor for <varname>timestampset</varname></para>
					<para><varname>timestampset(timestamptz[]): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampset(ARRAY[timestamptz '2001-01-01 08:00:00', '2001-01-03 09:30:00']);
-- {2001-01-01 08:00:00+00, 2001-01-03 09:30:00+00}
</programlisting>
				</listitem>
			</itemizedlist>

			<para>The <varname>periodset</varname> type has a constructor function that accepts a single argument which is an array of <varname>period</varname> values.
			</para>
			<itemizedlist>
				<listitem id="periodset">
					<indexterm><primary><varname>periodset</varname></primary></indexterm>
					<para>Constructor for <varname>periodset</varname></para>
					<para><varname>periodset(period[]): periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodset(ARRAY[period '[2001-01-01 08:00:00, 2001-01-01 08:10:00]',
-- '[2001-01-01 08:20:00, 2001-01-01 08:40:00]']);
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Casting</title>
			<para>Values of the time types, MobilityDB span types, and PostgreSQL range types can be converted to one another using the function <varname>CAST</varname> or using the <varname>::</varname> notation. However, as stated before, empty spans or spans with infinite bounds are not allowed in MobilityDB.
			</para>

			<itemizedlist>
				<listitem id="timestamptz_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestamptz</varname> to another time type</para>
					<para><varname>timestamptz::timestampset</varname></para>
					<para><varname>timestamptz::period</varname></para>
					<para><varname>timestamptz::periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS timestampset);
-- {2001-01-01 08:00:00+01}
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS period);
-- [2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01]
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS periodset);
-- {[2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01]}
</programlisting>
				</listitem>
				<listitem id="timestampset_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestampset</varname> to a <varname>periodset</varname></para>
					<para><varname>timestampset::periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT CAST(timestampset '{2001-01-01 08:00:00, 2001-01-01 08:15:00,
  2001-01-01 08:25:00}' AS periodset);
/* {[2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01],
   [2001-01-01 08:15:00+01, 2001-01-01 08:15:00+01],
   [2001-01-01 08:25:00+01, 2001-01-01 08:25:00+01]} */
</programlisting>
				</listitem>
				<listitem id="period_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>period</varname> to another time type</para>
					<para><varname>period::periodset</varname></para>
					<para><varname>period::tstzrange</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::periodset;
-- {[2001-01-01 08:00:00+01, 2001-01-01 08:30:00+01)}
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::tstzrange;
-- ["2001-01-01 08:00:00+01","2001-01-01 08:30:00+01")
</programlisting>
				</listitem>
				<listitem id="intspan_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast an <varname>intspan</varname> to an <varname>int4range</varname></para>
					<para><varname>intspan::int4range</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[10, 20)'::int4range;
-- [10,20)
</programlisting>
				</listitem>
				<listitem id="tstzrange_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>tstzrange</varname> to a <varname>period</varname></para>
					<para><varname>tstzrange::period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tstzrange '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::period;
-- [2001-01-01 08:00:00+01, 2001-01-01 08:30:00+01)
</programlisting>
				</listitem>
				<listitem id="int4range_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast an <varname>int4range</varname> to an <varname>intspan</varname></para>
					<para><varname>int4range::intspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT int4range '[10, 20)'::intspan;
-- [10,20)
SELECT int4range 'empty'::intspan;
-- ERROR:  Range cannot be empty
SELECT int4range '[10,)'::intspan;
-- ERROR:  Range bounds cannot be infinite
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Accessor Functions</title>

			<itemizedlist>
				<listitem id="time_memSize">
					<indexterm><primary><varname>memSize</varname></primary></indexterm>
					<para>Get the memory size in bytes</para>
					<para><varname>memSize({timestampset,periodset}): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT memSize(timestampset '{2001-01-01, 2001-01-02, 2001-01-03}');
-- 104
SELECT memSize(periodset '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04],
  [2001-01-05, 2001-01-06]}');
-- 136
</programlisting>
				</listitem>

				<listitem id="lower">
					<indexterm><primary><varname>lower</varname></primary></indexterm>
					<para>Get the lower bound</para>
					<para><varname>lower(span): element</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT lower(intspan '[20, 25)');
-- 20
SELECT lower(period '[2011-01-01, 2011-01-05)');
-- 2011-01-01
</programlisting>
				</listitem>

				<listitem id="upper">
					<indexterm><primary><varname>upper</varname></primary></indexterm>
					<para>Get the upper bound</para>
					<para><varname>upper(span): element</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT upper(floatspan '[20.5, 25.3)');
-- 25.3
SELECT upper(period '[2011-01-01, 2011-01-05)');
-- 2011-01-05
</programlisting>
				</listitem>

				<listitem id="lower_inc">
					<indexterm><primary><varname>lower_inc</varname></primary></indexterm>
					<para>Is the lower bound inclusive?</para>
					<para><varname>lower_inc(span): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT lower(intspan '[20, 25)');
-- true
SELECT lower_inc(period '[2011-01-01, 2011-01-05)');
-- true
</programlisting>
				</listitem>

				<listitem id="upper_inc">
					<indexterm><primary><varname>upper_inc</varname></primary></indexterm>
					<para>Is the upper bound inclusive?</para>
					<para><varname>upper_inc(span): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT upper(floatspan '[20.5, 25.3]');
-- true
SELECT upper_inc(period '[2011-01-01, 2011-01-05)');
-- false
</programlisting>
				</listitem>

				<listitem id="time_duration">
					<indexterm><primary><varname>duration</varname></primary></indexterm>
					<para>Get the duration</para>
					<para><varname>duration({period,periodset}): interval</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT duration(period '[2001-01-01, 2001-01-03)');
-- 2 days
SELECT duration(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- 3 days
</programlisting>
				</listitem>

				<listitem id="width">
					<indexterm><primary><varname>width</varname></primary></indexterm>
					<para>Get the width of the span as a float</para>
					<para><varname>width(numspan): float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT width(intspan '[1, 3)');
-- 2
SELECT width(floatspan '[1, 3.5)');
-- 2.5
</programlisting>
				</listitem>

				<listitem id="time_timespan">
					<indexterm><primary><varname>timespan</varname></primary></indexterm>
					<para>Get the timespan ignoring the potential time gaps</para>
					<para><varname>timespan({timestampset,periodset}): interval</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timespan(timestampset '{2001-01-01, 2001-01-03}');
-- 2 days
SELECT timespan(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- 4 days
</programlisting>
				</listitem>

				<listitem id="time_period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Get the period on which the timestamp set or period set is defined ignoring the potential time gaps</para>
					<para><varname>period({timestampset,periodset}): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}');
-- [2001-01-01, 2001-01-05]
SELECT period(periodset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</programlisting>
				</listitem>

				<listitem id="time_numTimestamps">
					<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
					<para>Get the number of different timestamps</para>
					<para><varname>numTimestamps({timestampset,periodset}): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT numTimestamps(timestampset '{2001-01-01, 2001-01-03, 2001-01-04}');
-- 3
SELECT numTimestamps(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="time_startTimestamp">
					<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
					<para>Get the start timestamp</para>
					<para><varname>startTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT startTimestamp(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-01
</programlisting>
				</listitem>

				<listitem id="time_endTimestamp">
					<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
					<para>Get the end timestamp</para>
					<para><varname>endTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT endTimestamp(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-05
</programlisting>
				</listitem>

				<listitem id="time_timestampN">
					<indexterm><primary><varname>timestampN</varname></primary></indexterm>
					<para>Get the n-th different timestamp</para>
					<para><varname>timestampN({timestampset,periodset},integer): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampN(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}', 3);
-- 2001-01-04
</programlisting>
				</listitem>

				<listitem id="time_timestamps">
					<indexterm><primary><varname>timestamps</varname></primary></indexterm>
					<para>Get the different timestamps</para>
					<para><varname>timestamps({timestampset,periodset}): timestampset</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestamps(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- {"2001-01-01", "2001-01-03", "2001-01-05"}
</programlisting>
				</listitem>

				<listitem id="numPeriods">
					<indexterm><primary><varname>numPeriods</varname></primary></indexterm>
					<para>Get the number of periods</para>
					<para><varname>numPeriods(periodset): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT numPeriods(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="startPeriod">
					<indexterm><primary><varname>startPeriod</varname></primary></indexterm>
					<para>Get the start period</para>
					<para><varname>startPeriod(periodset): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT startPeriod(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- [2001-01-01,2001-01-03)
</programlisting>
				</listitem>

				<listitem id="endPeriod">
					<indexterm><primary><varname>endPeriod</varname></primary></indexterm>
					<para>Get the end period</para>
					<para><varname>endPeriod(periodset): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT endPeriod(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- [2001-01-05,2001-01-06)
</programlisting>
				</listitem>

				<listitem id="periodN">
					<indexterm><primary><varname>periodN</varname></primary></indexterm>
					<para>Get the n-th period</para>
					<para><varname>periodN(periodset,integer): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodN(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}', 2);
-- [2001-01-04,2001-01-04]
</programlisting>
				</listitem>

				<listitem id="periods">
					<indexterm><primary><varname>periods</varname></primary></indexterm>
					<para>Get the periods</para>
					<para><varname>periods(periodset): period[]</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periods(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- {"[2001-01-01,2001-01-03)", "[2001-01-04,2001-01-04]", "[2001-01-05,2001-01-06)"}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id ="modification_time_tyes">
			<title>Modification Functions</title>

			<itemizedlist>
				<listitem id="time_shift">
					<indexterm><primary><varname>shift</varname></primary></indexterm>
					<para>Shift the time value by an interval</para>
					<para><varname>shift({timestampset,period,periodset}): {timestampset,period,periodset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);
-- {2001-01-02, 2001-01-04, 2001-01-06}
SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);
-- [2001-01-02, 2001-01-04]
SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day'::interval);
-- {[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}
</programlisting>
				</listitem>

			<listitem id="time_tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Scale the time value to an interval. If the time span of the time value is zero (for example, for a singleton timestamp set), the result is the time value. The given interval must be strictly greater than zero.</para>
				<para><varname>tscale({timestampset,period,periodset},interval): {timestampset,period,periodset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tscale(timestampset '{2001-01-01}', '1 day');
-- {2001-01-01}
SELECT tscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '2 days');
-- {2001-01-01, 2001-01-02, 2001-01-03}
SELECT tscale(period '[2001-01-01, 2001-01-03]', '1 day');
-- [2001-01-01, 2001-01-02]
SELECT tscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}', '1 day');
/* {[2001-01-01 00:00:00, 2001-01-01 12:00:00],
   [2001-01-01 18:00:00, 2001-01-02 00:00:00]} */
SELECT tscale(timestampset '{2001-01-01}', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem id="time_shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Shift and scale the time value to the two intervals. This function combines in a single step the functions <link linkend="time_shift"><varname>shift</varname></link> and <link linkend="time_tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale({timestampset,period,periodset},interval,interval):</varname></para>
				<para><varname>  {timestampset,period,periodset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shiftTscale(timestampset '{2001-01-01}', '1 day', '1 day');
-- {2001-01-02}
SELECT shiftTscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day','2 days');
-- {2001-01-02, 2001-01-03, 2001-01-04}
SELECT shiftTscale(period '[2001-01-01, 2001-01-03]', '1 day', '1 day');
-- [2001-01-02, 2001-01-03]
SELECT shiftTscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day', '1 day');
/* {[2001-01-02 00:00:00, 2001-01-02 12:00:00],
   [2001-01-02 18:00:00, 2001-01-03 00:00:00]} */
</programlisting>
			</listitem>

				<listitem id="floatspan_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Round the bounds of a float span to a number of decimal places</para>
					<para><varname>round(floatspan,integer): floatspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT round(floatspan '[1.123456789,2.123456789)', 3);
-- [1.123,2.123)
SELECT round(floatspan '[1.123456789, inf)', 3);
-- [1.123,Infinity)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_comp_operators">
			<title>Comparison Operators</title>

			<para>The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right arguments be of the same type. Excepted equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on span and time types. For span values, the operators compare first the lower bound, then the upper bound. For timestamp set and period set values, the operators compare first the bounding periods, and if those are equal, they compare the first N instants or periods, where N is the minimum of the number of composing instants or periods of both values.</para>

			<para>The comparison operators available for the span and time types are given next. Recall that integer spans are always represented by their canonical form.</para>

			<itemizedlist>
				<listitem id="time_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Are the values equal?</para>
					<para><varname>{numspan,time} = {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1,3]' = intspan '[1,4)';
-- true
SELECT period '[2001-01-01, 2001-01-04)' = period '[2001-01-01, 2001-01-04)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>Are the values different?</para>
					<para><varname>{numspan,time} &lt;&gt; {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2001-01-01, 2001-01-04)' &lt;&gt; period '[2001-01-03, 2001-01-05)';
-- true
SELECT timestampset '{2001-01-01, 2001-01-04}' &lt;&gt; timestampset '{2001-01-01, 2001-01-05}';
-- false
</programlisting>
				</listitem>

				<listitem id="time_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>Is the first value less than the second one?</para>
					<para><varname>{numspan,time} &lt; {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[3, 4]' &lt; floatspan '(3, 4]';
-- true
SELECT period '[2001-01-01, 2001-01-04)' &lt; period '[2001-01-01, 2001-01-04]';
-- true
SELECT timestampset '{2001-01-01, 2001-01-04}' &lt; timestampset '{2001-01-01, 2001-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>Is the first value greater than the second one?</para>
					<para><varname>{numspan,time} &gt; {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[3, 4]' &gt; floatspan '[3, 4)';
-- true
SELECT period '[2001-01-03, 2001-01-04)' &gt; period '[2001-01-02, 2001-01-05)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>Is the first value less than or equal to the second one?</para>
					<para><varname>{numspan,time} &lt;= {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodset '{[2001-01-01, 2001-01-04)}' &lt;=
  periodset '{[2001-01-01, 2001-01-05), [2001-01-06, 2001-01-07)}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>Is the first value greater than or equal to the second one?</para>
					<para><varname>{numspan,time} &gt;= {numspan,time}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2001-01-03, 2001-01-05)' &gt;= period '[2001-01-03, 2001-01-04)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_set_operators">
			<title>Set Operators</title>

			<para>The span and time types have associated set operators, namely union, difference, and intersection, which are represented, respectively by <varname>+</varname>, <varname>-</varname>, and <varname>*</varname>. These operators behave differently for numeric spans, that is <varname>intspan</varname> and <varname>floatspan</varname>, and for the <varname>period</varname> type, since discontiguous periods can be represented by the <varname>periodset</varname> type, whereas discontiguous numeric spans cannot be represented. Therefore, when a union or difference operator on numeric spans produces a discontiguous span an error is raised, which is not the case for periods. The set operators for the span and time types are given next.</para>

			<itemizedlist>
				<listitem id="time_union">
					<indexterm><primary><varname>+</varname></primary></indexterm>
					<para>Union of span or time values</para>
					<para><varname>numspan + numspan: numspan</varname></para>
					<para><varname>time + time: time</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)' + intspan '[3, 5)';
-- [1, 5)
SELECT floatspan '[1, 3)' + floatspan '[4, 5)';
-- ERROR: The union of the two spans would not be contiguous
SELECT period '[2011-01-01, 2011-01-03)' + period '[2011-01-04, 2011-01-05)';
-- {[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}
SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +
  timestampset '{2011-01-03, 2011-01-06}';
-- {2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}
SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +
  period '[2011-01-03, 2011-01-04)';
-- {[2011-01-01, 2011-01-05)}
</programlisting>
				</listitem>

				<listitem id="time_difference">
					<indexterm><primary><varname>-</varname></primary></indexterm>
					<para>Difference of span or time values</para>
					<para><varname>numspan - numspan: numspan</varname></para>
					<para><varname>time - time: time</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 5]' - intspan '[3, 6]';
-- [1, 3)
SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';
-- [2011-01-01, 2011-01-03)
SELECT floatspan '[1, 5]' - floatspan '[3, 4]';
-- ERROR:  result of span difference would not be contiguous
SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'
-- {[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}
SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -
  periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05],
  [2011-01-08, 2011-01-09]}';
/* {[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],
   [2011-01-07,2011-01-08), (2011-01-09,2011-01-10]} */
</programlisting>
				</listitem>

				<listitem id="time_intersection">
					<indexterm><primary><varname>*</varname></primary></indexterm>
					<para>Intersection of span or time values</para>
					<para><varname>numspan * numspan: numspan</varname></para>
					<para><varname>time * time: time</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 5)' * intspan '[3, 6)';
-- [3, 5)
SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';
-- {2011-01-03}
SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';
-- [2011-01-03, 2011-01-05)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_topo_operators">
			<title>Topological Operators</title>
			<para>The topological operators available for the span and time types are given next.</para>

			<itemizedlist>
				<listitem id="time_overlaps">
					<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
					<para>Do the values overlap (have values in common)?</para>
					<para><varname>{numrange,number} &amp;&amp; {numrange,number}: boolean</varname></para>
					<para><varname>{timestampset,period,periodset} &amp;&amp; {timestampset,period,periodset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)' &amp;&amp; intspan '[2, 4)';
-- true
SELECT floatspan '[1, 3)' &amp;&amp; floatspan '[3, 4)';
-- false
SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_contains">
					<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
					<para>Does the first value contain the second one?</para>
					<para><varname>numrange @&gt; {numrange,number}: boolean</varname></para>
					<para><varname>{timestampset,period,periodset} @&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[1, 5]' @&gt; floatspan '[2, 5)';
-- true
SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';
-- true
</programlisting>
				</listitem>

				<listitem id="time_containedby">
					<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
					<para>Is the first value contained by the second one?</para>
					<para><varname> {numrange,number}&lt;@ numrange: boolean</varname></para>
					<para><varname>time &lt;@ {timestampset,period,periodset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[2, 5]' &lt;@ floatspan '[1, 5)';
-- false
SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_adjacent">
					<indexterm><primary><varname>-|-</varname></primary></indexterm>
					<para>Is the first value adjacent to the second one?</para>
					<para><varname>{numrange,number} -|- {numrange,number}: boolean</varname></para>
					<para><varname>time -|- time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[2, 6)' -|- intspan '[6, 7)';
-- true
SELECT floatspan '[2, 5)' -|- floatspan '(5, 6)';
-- false
SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';
-- true
SELECT periodset '{[2001-01-01, 2001-01-02]}' -|- period '[2001-01-02, 2001-01-03)';
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_relpos_operators">
			<title>Relative Position Operators</title>
			<para>The relative position operators available for span and time types are given next.</para>

			<itemizedlist>
				<listitem id="span_left">
					<indexterm><primary><varname>&lt;&lt;</varname></primary></indexterm>
					<para>Is the first value strictly left of the second one?</para>
					<para><varname>{number,span} &lt;&lt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &lt;&lt; 20;
-- true
SELECT floatspan '[15, 20)' &lt;&lt; floatspan '(15, 20)';
-- false
</programlisting>
				</listitem>

				<listitem id="span_right">
					<indexterm><primary><varname>&gt;&gt;</varname></primary></indexterm>
					<para>Is the first value strictly to the right of the second one?</para>
					<para><varname>{number,span} &gt;&gt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &gt;&gt; 10;
-- true
SELECT floatspan '[15, 20)' &gt;&gt; floatspan '[5, 10]';
-- true
</programlisting>
				</listitem>

				<listitem id="span_overleft">
					<indexterm><primary><varname>&amp;&lt;</varname></primary></indexterm>
					<para>Is the first value not to the right of the second one?</para>
					<para><varname>{number,span} &amp;&lt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&lt; 18;
-- false
SELECT floatspan '[15, 20)' &amp;&lt; floatspan '[10, 20]';
-- true
</programlisting>
				</listitem>

				<listitem id="span_overright">
					<indexterm><primary><varname>&amp;&gt;</varname></primary></indexterm>
					<para>Is the first value not to the left of the second one?</para>
					<para><varname>{number,span} &amp;&gt; {number,span}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&gt; 30;
-- true
SELECT floatspan '[1, 6]' &amp;&gt; floatspan '(1, 3)';
-- false
</programlisting>
				</listitem>

				<listitem id="time_before">
					<indexterm><primary><varname>&lt;&lt;#</varname></primary></indexterm>
					<para>Is the first value scritly before the second one?</para>
					<para><varname>time &lt;&lt;# time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_after">
					<indexterm><primary><varname>#&gt;&gt;</varname></primary></indexterm>
					<para>Is the first value strictly after the second one?</para>
					<para><varname>time #&gt;&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt;
  periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_overbefore">
					<indexterm><primary><varname>&amp;&lt;#</varname></primary></indexterm>
					<para>Is the first value not after the second one?</para>
					<para><varname>time &amp;&lt;# time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';
-- false
</programlisting>
				</listitem>

				<listitem id="time_overafter">
					<indexterm><primary><varname>#&amp;&gt;</varname></primary></indexterm>
					<para>Is the first value not before the second one?</para>
					<para><varname>time #&amp;&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Distance Operator</title>

			<para>The distance operator <varname>&lt;-&gt;</varname> for span and time types consider the bounding span or period and returns a <varname>float</varname> value which is the smallest distance between the two values. In the case of periods it returns the number of seconds between the two time values. The distance operator can also be used for nearest neighbor searches using a GiST or an SP-GiST index (see <xref linkend="indexing_time_types" />).</para>

			<itemizedlist>
				<listitem id="smallest_distance_time">
					<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
					<para>Get the smallest distance ever</para>
					<para><varname>{number,span} &lt;-&gt; {number,span}: float</varname></para>
					<para><varname>time &lt;-&gt; time: float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 3 &lt;-&gt; intspan '(5, 7]';
-- 3
SELECT floatspan '[1, 3]' &lt;-&gt; floatspan '(5.5, 7]';
-- 2.5
SELECT period '[2001-01-02, 2001-01-06)' &lt;-&gt; timestamptz '2001-01-07';
-- 86400
SELECT timestampset '{2001-01-01, 2001-01-03, 2001-01-05}' &lt;-&gt;
  timestampset '{2001-01-02, 2001-01-04}';
--  0
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Aggregate Functions</title>

			<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant in the <emphasis>union</emphasis> of the temporal extents of the values to aggregate. In contrast, recall that all other functions manipulating time types compute the value of the function at every instant in the <emphasis>intersection</emphasis> of the temporal extents of the arguments.</para>

			<para>The temporal aggregate functions are the following ones:</para>
			<itemizedlist>
				<listitem><para>Function <varname>tcount</varname> generalizes the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available objects (for example, number of periods). Function <varname>tcount</varname> returns a temporal integer (see <xref linkend="temporal_types" />).</para></listitem>
				<listitem><para>Function <varname>extent</varname> returns a bounding span or period that encloses a set of span or time values.</para></listitem>
			</itemizedlist>

			<para>Union is a very useful operation for time types. As we have seen in <xref linkend="time_set_operators" />, we can compute the union of two time values using the <varname>+</varname> operator. However, it is also very useful to have an aggregate version of the union operator for combining an arbitrary number of values. Function <varname>tunion</varname> can be used for this purpose.
			</para>

			<itemizedlist>
				<listitem id="time_tcount">
					<indexterm><primary><varname>tcount</varname></primary></indexterm>
					<para>Temporal count</para>
					<para><varname>tcount({timestampset,period,periodset}): {tint_seq,tint_seqset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tcount(ts) FROM times;
-- {2@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-04, 1@2000-01-05, 1@2000-01-06}

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT tcount(ps) FROM periods;
/* {[2@2000-01-01, 3@2000-01-02], (2@2000-01-02, 3@2000-01-03, 3@2000-01-04],
   (1@2000-01-04, 2@2000-01-05, 2@2000-01-06]} */
</programlisting>
				</listitem>

				<listitem id="time_extent">
					<indexterm><primary><varname>extent</varname></primary></indexterm>
					<para>Bounding span or period</para>
					<para><varname>extent(span): span</varname></para>
					<para><varname>extent({timestampset,period,periodset}): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH spans(r) AS (
  SELECT floatspan '[1, 4)' UNION
  SELECT floatspan '(5, 8)' UNION
  SELECT floatspan '(7, 9)'
)
SELECT extent(r) FROM spans;
-- [1,9)

WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT extent(ts) FROM times;
-- [2000-01-01, 2000-01-06]

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT extent(ps) FROM periods;
-- [2000-01-01, 2000-01-06]
</programlisting>
				</listitem>

				<listitem id="tunion">
					<indexterm><primary><varname>tunion</varname></primary></indexterm>
					<para>Temporal union</para>
					<para><varname>tunion({timestampset,period,periodset}): {timestampset,periodset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tunion(ts) FROM times;
-- {2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05, 2000-01-06}
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-03], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-07, 2000-01-08]}'
)
SELECT tunion(ps) FROM periods;
-- {[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06], [2000-01-07, 2000-01-08]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id ="indexing_time_types">
		<title>Indexing of Time and Span Types</title>

		<para>GiST and SP-GiST indexes can be created for table columns of the <varname>intspan</varname>, <varname>floatspan</varname>, <varname>period</varname>, <varname>timestampset</varname>, and <varname>periodset</varname> types. The GiST index implements an R-tree while the SP-GiST index implements a quad-tree. An example of creation of a GiST index in a column <varname>During</varname> of type <varname>period</varname> in a table <varname>Reservation</varname> is as follows:
			<programlisting language="sql" xml:space="preserve">
CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,
  During period);
CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);
</programlisting>
		</para>
		<para>A GiST or an SP-GiST index can accelerate queries involving the following operators: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, and <varname>&lt;-&gt;</varname>.</para>
		<para>In addition, B-tree indexes can be created for table columns of a span or time type. For these index types, basically the only useful operation is equality. There is a B-tree sort ordering defined for values of span time types with corresponding <varname>&lt;</varname> and <varname>&gt;</varname> operators, but the ordering is rather arbitrary and not usually useful in the real world. The B-tree support is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>
	</sect1>
</chapter>
