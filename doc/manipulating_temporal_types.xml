<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="manipulating_temporal_types">
	<title>Manipulating Temporal Types</title>
	<para>We present next the functions and operators for temporal types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this, we use the following notation:</para>

	<itemizedlist>
		<listitem>
			<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>ttype</varname> represents any temporal type,</para>
		</listitem>

		<listitem>
			<para><varname>tdisc</varname> represents any temporal type with a discrete base type, that is, <varname>tbool</varname>, <varname>tint</varname>, or <varname>ttext</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tcont</varname> represents any temporal type with a continuous base type, that is, <varname>tfloat</varname>, <varname>tgeompoint</varname>, or <varname>tgeogpoint</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>torder</varname> represents any temporal type whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tnumber</varname> represents any temporal number type, that is, <varname>tint</varname> or <varname>tfloat</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tpoint</varname> represents a temporal point type, that is, <varname>tgeompoint</varname> or <varname>tgeogpoint</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_inst</varname> represents any temporal type with instant subtype,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_seq</varname> represents any temporal type with sequence subtype,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_discseq</varname> represents any temporal type with sequence subtype and discrete interpolation,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_seqset</varname> represents any temporal type with sequence set subtype,</para>
		</listitem>

		<listitem>
			<para><varname>base</varname> represents any base type of a temporal type, that is, <varname>boolean</varname>, <varname>integer</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname>, or <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>number</varname> represents any number base type, that is, <varname>integer</varname> or <varname>float</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>numspan</varname> represents any number span type, that is, either <varname>intspan</varname> or <varname>floatspan</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>geo</varname> represents the types <varname>geometry</varname> or <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>geompoint</varname> represents the type <varname>geometry</varname> restricted to a point.</para>
		</listitem>

		<listitem>
			<para><varname>point</varname> represents the types <varname>geometry</varname> or <varname>geography</varname> restricted to a point.</para>
		</listitem>

		<listitem>
			<para><varname>type[]</varname> represents an array of <varname>type</varname>.</para>
		</listitem>
	</itemizedlist>

	<para>
		A common way to generalize the traditional operations to the temporal types is to apply the operation <emphasis>at each instant</emphasis>, which yields a temporal value as result. In that case, the operation is only defined on the intersection of the emporal extents of the operands; if the temporal extents are disjoint, then the result is null. For example, the temporal comparison operators, such as <varname>#&lt;</varname>, test whether the values taken by their operands at each instant satisfy the condition and return a temporal Boolean. Examples of the various generalizations of the operators are given next.
	</para>
	<programlisting language="sql" xml:space="preserve">
-- Temporal comparison
SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';
-- {[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';
-- NULL

-- Temporal addition
SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';
-- [3@2001-01-02, 3@2001-01-03)

-- Temporal intersects
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}

-- Temporal distance
SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;
  tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';
-- [0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)
</programlisting>

	<para>
		Another common requirement is to determine whether the operands <emphasis>ever</emphasis> or <emphasis>always</emphasis> satisfy a condition with respect to an operation. These can be obtained by applying the ever/always comparison operators. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Examples of ever and always comparison operators are given next.
	</para>
	<programlisting language="sql" xml:space="preserve">
-- Does the operands ever intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;
-- true

-- Does the operands always intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;
-- true

-- Is the left operand ever less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
  tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;
-- true

-- Is the left operand always less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
  tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;
-- true
</programlisting>
	<para>
		For efficiency reasons, some common operations with the ever or the always semantics are natively provided. For example, the <varname>intersects</varname> function determines whether there is an instant at which the two arguments spatially intersect.
	</para>

	<para>
		We describe next the functions and operators for temporal types. For conciseness, in the examples we mostly use sequences composed of two instants.
	</para>

	<sect1 id="input_output_temporal_types">
		<title>Input/Output of Temporal Types</title>
			<para>
				MobilityDB generalizes Open Geospatial Consortium's Well-Known Text (WKT), Well-Known Binary (WKB), and Moving Features JSON (MF-JSON) input/output format for all temporal types. We start by describing the WKT format.
			</para>

		<para>
			An <emphasis>instant value</emphasis> is a couple of the form <varname>v@t</varname>, where <varname>v</varname> is a value of the base type and <varname>t</varname> is a <varname>timestamptz</varname> value. The temporal extent of an instant value is a single timestamp. Examples of instant values are as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool 'true@2001-01-01 08:00:00';
SELECT tint '1@2001-01-01 08:00:00';
SELECT tfloat '1.5@2001-01-01 08:00:00';
SELECT ttext 'AAA@2001-01-01 08:00:00';
SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';
</programlisting>
		<para>
			A <emphasis>sequence value</emphasis> is a set of values <varname>v1@t1,...,vn@tn</varname> delimited by lower and upper bounds, which can be inclusive (represented by &lsquo;<varname>[</varname>&rsquo; and &lsquo;<varname>]</varname>&rsquo;) or exclusive (represented by &lsquo;<varname>(</varname>&rsquo; and &lsquo;<varname>)</varname>&rsquo;). A sequence value composed of a single couple <varname>v@t</varname> is called an <emphasis>instantaneous sequence</emphasis>. Sequence values have an associated <emphasis>interpolation function</emphasis> which may be discrete, linear, or stepwise. By definition, the lower and upper bounds of an instantaneous sequence or of a sequence value with discrete interpolation are inclusive. The temporal extent of a sequence value with discrete interpolation is a timestamp set. Examples of sequence values with discrete interpolation are as follows.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00}'; -- Instantaneous sequence
SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';
SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';
SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
</programlisting>
		<para>The temporal extent of a sequence value with linear or stepwise interpolation is a period defined by the first and last instants as well as the lower and upper bounds. Examples of sequence values with linear interpolation are as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';
SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';
SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';
SELECT tfloat '[1.5@2001-01-01 08:00:00]'; -- Instantaneous sequence
SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';
SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';
SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,
  Point(0 0)@2017-01-01 08:10:00)';
</programlisting>
		<para>Sequence values whose base type is continuous may specify that the interpolation is stepwise with the prefix <varname>Interp=Stepwise</varname>. If this is not specified, it is supposed that the interpolation is linear by default. Example of sequence values with stepwise interpolation are given next:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01 08:00:00, 3@2001-01-01 08:10:00]';
SELECT tgeompoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
  Point(1 1)@2017-01-01 08:05:00, Point(1 1)@2017-01-01 08:10:00)';
SELECT tgeompoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
 Point(1 1)@2017-01-01 08:05:00, Point(0 0)@2017-01-01 08:10:00)';
ERROR:  Invalid end value for temporal sequence with stepwise interpolation
SELECT tgeogpoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
  Point(1 1)@2017-01-01 08:10:00]';
</programlisting>
		<para>
			The last two instants of a sequence value with discrete interpolation and exclusive upper bound must have the same base value, as shown in the second and third examples above.
		</para>
		<para>
			A <emphasis>sequence set value</emphasis> is a set <varname>{v1,...,vn}</varname> where every <varname>vi</varname> is a sequence value. The interpolation of sequence set values can only be linear or stepwise, not discrete. All sequences composing a sequence set value must have the same interpolation. The temporal extent of a sequence set value is a set of periods. Examples of sequence set values with linear interpolation are as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),
  [true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';
SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),
  [2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,
  3@2001-01-06 08:00:00]}';
SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),
  [CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';
SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
  [Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
  [Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
</programlisting>
		<para>
			Sequence set values whose base type is continuous may specify that the interpolation is stepwise with the prefix <varname>Interp=Stepwise</varname>. If this is not specified, it is supposed that the interpolation is linear by default. Example of sequence set values with stepwise interpolation are given next:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00,
  2@2001-01-04 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tgeompoint 'Interp=Stepwise;{[Point(0 0)@2017-01-01 08:00:00,
  Point(0 1)@2017-01-01 08:05:00], [Point(0 1)@2017-01-01 08:10:00,
  Point(0 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint 'Interp=Stepwise;{[Point(0 0)@2017-01-01 08:00:00,
  Point(0 1)@2017-01-01 08:05:00], [Point(0 1)@2017-01-01 08:10:00,
  Point(0 1)@2017-01-01 08:15:00)}';
</programlisting>

		<para>
			For temporal points, it is possible to specify the spatial reference identifier (SRID) using the Extended Well-Known text (EWKT) representation as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'
</programlisting>
		<para>
			All component geometries of a temporal point will then be of the given SRID. Furthermore, each component geometry can specify its SRID with the EWKT format as in the following example
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'
</programlisting>
		<para>
			An error is raised if the component geometries are not all in the same SRID or if the SRID of a component geometry is different from the one of the temporal point, as shown below.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';
-- ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,
  SRID=4326;Point(0 1)@2000-01-02]';
-- ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
</programlisting>
		<para>
			If not specified, the default SRID for temporal geometric points is 0 (unknown) and for temporal geographic points is 4326 (WGS 84). Temporal points with stepwise interpolation may also specify the SRID, as shown next.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint 'SRID=5435,Interp=Stepwise;[Point(0 0)@2000-01-01,
  Point(0 1)@2000-01-02]';
SELECT tgeogpoint 'Interp=Stepwise;[SRID=4326;Point(0 0)@2000-01-01,
  SRID=4326;Point(0 1)@2000-01-02]';
</programlisting>
		<para>
			We give below the input/output functions in Moving Features JSON (MF-JSON) and Well-Known Binary (WKB) format for temporal alphanumeric types. The corresponding functions for temporal points are detailed in <xref linkend="tpoint_inout" />.
		</para>

		<itemizedlist>
			<listitem id="temporal_asMFJSON">
				<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>Get the Moving Features JSON representation</para>
				<para><varname>asMFJSON(ttype,options integer=0,flags integer=0,maxdecdigits integer=15): bytea</varname></para>
				<para>The <varname>options</varname> argument can be used to add a bounding box in the MFJSON output:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: MFJSON BBOX</para></listitem>
				</itemizedlist>
				<para>The <varname>flags</varname> argument can be used to customize the JSON output, for example, to produce an easy-to-read (for human readers) JSON output. Please look at the documentation of the <varname>json-c</varname> library. Typical values are as follows:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: JSON_C_TO_STRING_SPACED</para></listitem>
					<listitem><para>2: JSON_C_TO_STRING_PRETTY</para></listitem>
				</itemizedlist>
				<para>The <varname>maxdecdigits</varname> argument can be used to set the maximum number of decimal places in the output of floating point values (default 15).</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asMFJSON(tbool 't@2019-01-01 18:00:00', 1);
/* {"type":"MovingBoolean","stBoundedBy":{"period":{"begin":"2019-01-01 18:00:00+01",
   "end":"2019-01-01 18:00:00+01",'lower_inc':true,'upper_inc':true}},"values":true,
   "datetimes":"2019-01-01T18:00:00+01","interpolations":["Discrete"]} */
SELECT asMFJSON(tint '{10@2019-01-01 18:00:00, 25@2019-01-01 18:10:00}', 1);
/* {"type":"MovingInteger","stBoundedBy":{"bbox":[10,25],
   "period":{"begin":"2019-01-01 18:00:00+01","end":"2019-01-01 18:10:00+01"}},
   "values":[10,25],"datetimes":["2019-01-01T18:00:00+01","2019-01-01T18:10:00+01"],
   "interpolations":["Discrete"]} */
SELECT asMFJSON(tfloat '[10.5@2019-01-01 18:00:00+02, 25.5@2019-01-01 18:10:00+02]');
/* {"type":"MovingFloat","values":[10.5,25.5],
   "datetimes":["2019-01-01T17:00:00+01","2019-01-01T17:10:00+01"],
   "lower_inc":true,"upper_inc":true,"interpolations":["Linear"]} */
SELECT asMFJSON(ttext '{[walking@2019-01-01 18:00:00+02,
  driving@2019-01-01 18:10:00+02]}');
/* {"type":"MovingText","sequences":[{"values":["walking","driving"],
   "datetimes":["2019-01-01T17:00:00+01","2019-01-01T17:10:00+01"],
   "lower_inc":true,"upper_inc":true}],"interpolations":["Stepwise"]} */
</programlisting>
			</listitem>

			<listitem id="temporal_asBinary">
				<indexterm><primary><varname>asBinary</varname></primary></indexterm>
				<para>Get the Well-Known Binary (WKB) representation</para>
				<para><varname>asBinary(ttype): bytea</varname></para>
				<para><varname>asBinary(ttype,endian text): bytea</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asBinary(tbool 'true@2001-01-01');
-- \x010d000101009c57d3c11c0000
SELECT asBinary(tint '1@2001-01-01', 'XDR');
-- \x000016010000000100001cc1d3579c00
SELECT asBinary(tfloat '1.5@2001-01-01');
-- \x01130081000000000000f83f009c57d3c11c0000
SELECT asBinary(ttext 'AAA@2001-01-01');
-- \x01170001040000000000000041414100009c57d3c11c0000
</programlisting>
			</listitem>

			<listitem id="temporal_asHexWKB">
				<indexterm><primary><varname>asHexWKB</varname></primary></indexterm>
				<para>Get the Hexadecimal Well-Known Binary (WKB) representation as text</para>
				<para><varname>asHexWKB(ttype): text</varname></para>
				<para><varname>asHexWKB(ttype,endian text): text</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asHexWKB(tbool 'true@2001-01-01');
-- 010D000101009C57D3C11C0000
SELECT asHexWKB(tint '1@2001-01-01', 'XDR');
-- 000016010000000100001CC1D3579C00
SELECT asHexWKB(tfloat '1.5@2001-01-01');
-- 01130081000000000000F83F009C57D3C11C0000
SELECT asHexWKB(ttext 'AAA@2001-01-01');
-- 01170001040000000000000041414100009C57D3C11C0000
</programlisting>
			</listitem>

			<listitem id="tboolFromBinary">
				<indexterm><primary><varname>tboolFromBinary</varname></primary></indexterm>
				<para>Input a temporal Boolean from its Well-Known Binary (WKB) representation</para>
				<para><varname>tboolFromBinary(bytea): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tboolFromBinary('\x010d000101009c57d3c11c0000');
-- t@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tintFromBinary">
				<indexterm><primary><varname>tintFromBinary</varname></primary></indexterm>
				<para>Input a temporal integer from its Well-Known Binary (WKB) representation</para>
				<para><varname>tintFromBinary(bytea): tint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tintFromBinary('\x000016010000000100001cc1d3579c00');
-- 1@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tfloatFromBinary">
				<indexterm><primary><varname>tfloatFromBinary</varname></primary></indexterm>
				<para>Input a temporal float from its Well-Known Binary (WKB) representation</para>
				<para><varname>tfloatFromBinary(bytea): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloatFromBinary('\x01130081000000000000f83f009c57d3c11c0000');
-- 1.5@2001-01-01
</programlisting>
			</listitem>

			<listitem id="ttextFromBinary">
				<indexterm><primary><varname>ttextFromBinary</varname></primary></indexterm>
				<para>Input a temporal text from its Well-Known Binary (WKB) representation</para>
				<para><varname>ttextFromBinary(bytea): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ttextFromBinary('\x01170001040000000000000041414100009c57d3c11c0000');
-- "AAA"@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tboolFromHexWKB">
				<indexterm><primary><varname>tboolFromHexWKB</varname></primary></indexterm>
				<para>Input a temporal Boolean from its Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para><varname>tboolFromHexWKB(text): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tboolFromHexWKB('010D000101009C57D3C11C0000');
-- t@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tintFromHexWKB">
				<indexterm><primary><varname>tintFromHexWKB</varname></primary></indexterm>
				<para>Input a temporal integer from its Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para><varname>tintFromHexWKB(text): tint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tintFromHexWKB('000016010000000100001CC1D3579C00');
-- 1@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tfloatFromHexWKB">
				<indexterm><primary><varname>tfloatFromHexWKB</varname></primary></indexterm>
				<para>Input a temporal float from its Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para><varname>tfloatFromHexWKB(text): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloatFromHexWKB('01130081000000000000F83F009C57D3C11C0000');
-- 1.5@2001-01-01
</programlisting>
			</listitem>

			<listitem id="ttextFromHexWKB">
				<indexterm><primary><varname>ttextFromHexWKB</varname></primary></indexterm>
				<para>Input a temporal text from its Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para><varname>ttextFromHexWKB(text): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ttextFromHexWKB('01170001040000000000000041414100009C57D3C11C0000');
-- "AAA"@2001-01-01
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="constructor_temporal_tyes">
		<title>Constructor Functions</title>

		<para>
			Each temporal type has a constructor function with the same name as the type and a suffix for the subtype, where the suffixes &lsquo;<varname>_inst</varname>&rsquo;, &lsquo;<varname>_discseq</varname>&rsquo;, &lsquo;<varname>_seq</varname>&rsquo;, and &lsquo;<varname>_seqset</varname>&rsquo; correspond, respectively, to the subtypes instant, sequence with discrete interpolation, sequence with linear or stepwise interpolation, and sequence set. Examples are <varname>tint_seq</varname> or <varname>tgeompoint_seqset</varname>. Using the constructor function is frequently more convenient than writing a literal constant.
		</para>

		<itemizedlist>
			<listitem>
				<para>A first set of functions have two arguments, a base type and a time type, where the latter is a <varname>timestamptz</varname>, a <varname>timestampset</varname>, a <varname>period</varname>, or a <varname>periodset</varname> value for constructing, respectively, an instant, a sequence with discrete interpolation, a sequence with linear or stepwise interpolation, or a sequence set value. The functions for sequence or sequence set values with continuous base type have in addition an optional third argument which is a Boolean for stating whether the resulting temporal value has linear interpolation or not. By default this argument is true if it is not specified.</para>
			</listitem>

			<listitem>
				<para>Another set of functions for sequence values with discrete interpolation have a single argument, which is an array of values of the corresponding instant values.</para>
			</listitem>

			<listitem>
				<para>Another set of functions for sequence values have one argument for the array of values of the corresponding instant subtype and two optional Boolean arguments stating, respectively, whether the left and right bounds are inclusive or exclusive. It the these arguments are not specified they are assumed to be true by default. In addition, the functions for sequence values with continuous base type have an additional Boolean argument stating whether the interpolation is linear or not. It this argument is not specified it is assumed to be true by default.</para>
			</listitem>

			<listitem>
				<para>Another set of functions for sequence set values have a single argument, which is an array of values of the corresponding sequence values. For sequence values with continuous base type, the interpolation of the resulting temporal value depends on the interpolation of the composing sequences. An error is raised if the sequences composing the array have different interpolation.</para>
			</listitem>

			<listitem>
				<para>Finally, another set of functions for sequence set values have as first argument an array of values of the corresponding instant values, and two arguments stating a maximum distance and a maximum time interval such that a gap is introduced between composing sequences of the result whenever two consecutive input instants have a distance or a time gap greater than these values. For temporal points the distance is specified in units of the underlying SRID. These two gaps arguments are optional and if they are not given, a zero value is assumed, which is not taken into account for determining the gaps. In addition, the functions for sequence values with continuous base type have an additional Boolean argument stating whether the interpolation is linear or not. It this argument is not specified it is assumed to be true by default.</para>
			</listitem>
		</itemizedlist>

		<para>We give next the constructor functions for the various subtypes.</para>

		<itemizedlist>
			<listitem id="ttype_inst">
				<indexterm><primary><varname>ttype_inst</varname></primary></indexterm>
				<para>Constructor for temporal types of instant subtype</para>
				<para><varname>ttype_inst(base,timestamptz): ttype_inst</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_inst(true, '2001-01-01');
SELECT tint_inst(1, '2001-01-01');
SELECT tfloat_inst(1.5, '2001-01-01');
SELECT ttext_inst('AAA', '2001-01-01');
SELECT tgeompoint_inst('Point(1 1)', '2001-01-01');
SELECT tgeogpoint_inst('SRID=7844;Point(1 1)', '2001-01-01');
</programlisting>
			</listitem>

			<listitem id="ttype_discseq">
				<indexterm><primary><varname>ttype_discseq</varname></primary></indexterm>
				<para>Constructor for temporal types of sequence subtype and discrete interpolation</para>
				<para><varname>ttype_discseq(base,timestampset): ttype_discseq</varname></para>
				<para><varname>ttype_discseq(ttype_inst[]): ttype_discseq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_discseq(true, '{2001-01-01, 2001-01-02}');
SELECT tint_discseq(1, '{2001-01-01, 2001-01-02}');
SELECT tfloat_discseq(1.5, '{2001-01-01, 2001-01-02}');
SELECT ttext_discseq('AAA', '{2001-01-01, 2001-01-02}');
SELECT tgeompoint_discseq('Point(1 1)', '{2001-01-01, 2001-01-02}');
SELECT tgeogpoint_discseq('SRID=7844;Point(1 1)', '{2001-01-01, 2001-01-02}');
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_discseq(ARRAY[tbool 'true@2001-01-01 08:00:00','false@2001-01-01 08:05:00']);
SELECT tint_discseq(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);
SELECT tfloat_discseq(ARRAY[tfloat '1.0@2001-01-01 08:00:00', '2.0@2001-01-01 08:05:00']);
SELECT ttext_discseq(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);
SELECT tgeompoint_discseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);
SELECT tgeogpoint_discseq(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',
  'Point(2 2)@2001-01-01 08:05:00']);
</programlisting>
			</listitem>

			<listitem id="ttype_seq">
				<indexterm><primary><varname>ttype_seq</varname></primary></indexterm>
				<para>Constructor for temporal types of sequence subtype</para>
				<para><varname>tdisc_seq(base,period): tdisc_seq</varname></para>
				<para><varname>tcont_seq(base,period,linear=true): tcont_seq</varname></para>
				<para><varname>tdisc_seq(ttype_inst[],left_inc=true,right_inc=true}): tdisc_seq</varname></para>
				<para><varname>tcont_seq(ttype_inst[],left_inc=true,right_inc=true,linear=true}): tcont_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seq(true, '[2001-01-01, 2001-01-02]');
SELECT tint_seq(1, '[2001-01-01, 2001-01-02]');
SELECT tfloat_seq(1.5, '[2001-01-01, 2001-01-02]', false);
SELECT ttext_seq('AAA', '[2001-01-01, 2001-01-02]');
SELECT tgeompoint_seq('Point(0 0)', '[2001-01-01, 2001-01-02]', false);
SELECT tgeogpoint_seq('SRID=7844;Point(0 0)', '[2001-01-01, 2001-01-02]');
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],
  true, true);
SELECT tint_seq(ARRAY[tint(2,'2001-01-01 08:00:00'), tint(2,'2001-01-01 08:10:00')],
  true, false);
SELECT tfloat_seq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
  '1@2001-01-03 08:10:00'], true, false);
SELECT tfloat_seq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
  '1@2001-01-03 08:10:00'], true, true, false);
SELECT ttext_seq(ARRAY[ttext('AAA', '2001-01-01 08:00:00'),
  ttext('BBB', '2001-01-03 08:05:00'), ttext('BBB', '2001-01-03 08:10:00')]);
SELECT tgeompoint_seq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);
SELECT tgeogpoint_seq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 0)@2001-01-03 08:05:00'], true, true, false);
</programlisting>
			</listitem>

			<listitem id="ttype_seqset">
				<indexterm><primary><varname>ttype_seqset</varname></primary></indexterm>
				<para>Constructors for temporal types of sequence set subtype</para>
				<para><varname>tdisc_seqset(base,periodset): tdisc_seqset</varname></para>
				<para><varname>tcont_seqset(base,periodset,linear=true): tcont_seqset</varname></para>
				<para><varname>ttype_seqset(ttype_seq[]): ttype_seqset</varname></para>
				<para><varname>tint_seqset_gaps(tint_inst[],maxdist=0.0,maxt='0 minutes'): tint_seqset</varname></para>
				<para><varname>tcont_seqset_gaps(tcont_inst[],linear=true,maxdist=0.0,maxt='0 minutes'):</varname></para>
				<para><varname>  tcont_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seqset(true, '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tint_seqset(1, '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tfloat_seqset(1.5, '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT ttext_seqset('AAA', '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tgeompoint_seqset('Point(0 0)', '{[2001-01-01, 2001-01-02],
  [2001-01-03, 2001-01-04]}', false);
SELECT tgeogpoint_seqset('SRID=7844;Point(0 0)', '{[2001-01-01, 2001-01-02],
  [2001-01-03, 2001-01-04]}', false);
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seqset(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',
  '[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);
SELECT tint_seqset(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,
  2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);
SELECT tfloat_seqset(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,
  2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT tfloat_seqset(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
  2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
  'Interp=Stepwise;[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT ttext_seqset(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',
  '[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);
SELECT tgeompoint_seqset(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,
  Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',
  '[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);
SELECT tgeogpoint_seqset(ARRAY[tgeogpoint
  'Interp=Stepwise;[Point(0 0)@2001-01-01 08:00:00, Point(0 0)@2001-01-01 08:05:00)',
  'Interp=Stepwise;[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);
SELECT tfloat_seqset(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
  2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
  '[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
-- ERROR:  Input sequences must have the same interpolation
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tint_seqset_gaps(ARRAY[tint '1@2000-01-01', '3@2000-01-02', '4@2000-01-03',
  '5@2000-01-05'], 1, '1 day');
-- {[1@2000-01-01], [3@2000-01-02, 4@2000-01-03], [5@2000-01-05]}
SELECT asText(tgeompoint_seqset_gaps(ARRAY[tgeompoint 'Point(1 1)@2000-01-01',
  'Point(2 2)@2000-01-02', 'Point(3 2)@2000-01-03', 'Point(3 2)@2000-01-05'],
  true, 1, '1 day'));
/* {[POINT(1 1)@2000-01-01], [POINT(2 2)@2000-01-02, POINT(3 2)@2000-01-03],
   [POINT(3 2)@2000-01-05]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="casting_temporal_types">
		<title>Casting</title>

		<para>A temporal value can be converted into a compatible type using the notation <varname>CAST(ttype1 AS ttype2)</varname> or <varname>ttype1::ttype2</varname>.</para>
		<itemizedlist>
			<listitem id="temporal_period">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal value to a period</para>
				<para><varname>ttype::period</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::period;
-- [2001-01-01, 2001-01-03]
SELECT ttext '(A@2000-01-01, B@2000-01-03, C@2000-01-05]'::period;
-- (2000-01-01, 2000-01-05]
</programlisting>
			</listitem>

			<listitem id="tnumber_span">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal number to a span</para>
				<para><varname>tnumber::span</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::intspan;
-- [1, 3)
SELECT tfloat '(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::floatspan;
-- (1, 3]
SELECT tfloat 'Interp=Stepwise;(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::floatspan;
-- [1, 3]
</programlisting>
			</listitem>

			<listitem id="tnumber_tbox">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal number to a <varname>tbox</varname></para>
				<para><varname>tnumber::tbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tbox;
-- TBOX XT((1,2),[2001-01-01,2001-01-03])
SELECT tfloat '(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::tbox;
-- TBOX XT((1,3),[2001-01-01,2001-01-05])
</programlisting>
			</listitem>

			<listitem id="tpoint_stbox">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal point to an <varname>stbox</varname></para>
				<para><varname>tpoint::stbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]'::stbox;
-- STBOX XT(((1,1),(3,3)),[2001-01-01, 2001-01-03])
SELECT tgeogpoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]'::stbox;
/* SRID=4326;GEODSTBOX XT(
   ((0.9972609281539917,0.017449747771024704,0.01745240643728351),
   (0.9996954202651978,0.05226423218846321,0.05233595624294383)),
   [2001-01-01, 2001-01-03]) */
</programlisting>
			</listitem>

			<listitem id="tint_tfloat">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal integer to a temporal float</para>
				<para><varname>tint::tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;
-- [1@2001-01-01, 2@2001-01-03]
SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;
-- Interp=Stepwise;[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]
</programlisting>
			</listitem>

			<listitem id="tfloat_tint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal float to a temporal integer</para>
				<para><varname>tfloat::tint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- [1@2001-01-01, 2@2001-01-03]
SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer
</programlisting>
			</listitem>

			<listitem id="tgeompoint_tgeogpoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal geometry point to a temporal geography point</para>
				<para><varname>tgeompoint::tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);
-- {POINT(0 0)@2001-01-01}
</programlisting>
			</listitem>

			<listitem id="tgeogpoint_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal geography point to a temporal geometry point</para>
				<para><varname>tgeogpoint::tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);
-- {[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}
</programlisting>
			</listitem>
		</itemizedlist>

		<para>
			A common way to store temporal points in PostGIS is to represent them as geometries of type <varname>LINESTRING M</varname> and abuse the M dimension to encode timestamps as seconds since 1970-01-01 00:00:00. These time-enhanced geometries, called <emphasis>trajectories</emphasis>, can be validated with the function <varname>ST_IsValidTrajectory</varname> to verify that the M value is growing from each vertex to the next. Trajectories can be manipulated with the functions <varname>ST_ClosestPointOfApproach</varname>, <varname>ST_DistanceCPA</varname>, and <varname>ST_CPAWithin</varname>. Temporal point values can be converted to/from PostGIS trajectories.
		</para>

		<itemizedlist>
			<listitem id="tgeompoint_geometry">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal point to a PostGIS trajectory</para>
				<para><varname>tgeompoint::geometry</varname></para>
				<para><varname>tgeogpoint::geography</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);
-- POINT M (0 0 978307200)
SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(1 1)@2001-01-03}')::geometry);
-- MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)"
SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);
-- LINESTRING M (0 0 978307200,1 1 978393600)
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
  [Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
/* MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),
   (1 1 978652800,0 0 978739200)) */
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
  [Point(1 1)@2001-01-03],
  [Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
/* GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
   POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200)) */
</programlisting>
			</listitem>

			<listitem id="geometry_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a PostGIS trajectory to a temporal point</para>
				<para><varname>geometry::tgeompoint</varname></para>
				<para><varname>geography::tgeogpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,
  1 1 978480000)'::tgeompoint);
-- [POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03];
SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
  POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);
/* {[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],
   [POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Accessor Functions</title>
		<itemizedlist>

			<listitem id="ttype_memSize">
				<indexterm><primary><varname>memSize</varname></primary></indexterm>
				<para>Get the memory size in bytes</para>
				<para><varname>memSize(ttype): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT memSize(tint '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- 280
</programlisting>
			</listitem>

			<listitem id="tempSubtype">
				<indexterm><primary><varname>tempSubtype</varname></primary></indexterm>
				<para>Get the temporal type</para>
				<para><varname>tempSubtype(ttype): {'Instant','Sequence','SequenceSet'}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tempSubtype(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Sequence
</programlisting>
			</listitem>

			<listitem id="interpolation">
				<indexterm><primary><varname>interpolation</varname></primary></indexterm>
				<para>Get the interpolation</para>
				<para><varname>interpolation(ttype): {'Discrete','Stepwise','Linear'}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT interpolation(tfloat '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- Discrete
SELECT interpolation(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Stepwise
SELECT interpolation(tfloat '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Linear
SELECT interpolation(tfloat 'Interp=Stepwise;[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Stepwise
SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2001-01-01,
  Point(2 2)@2001-01-02, Point(3 3)@2001-01-03]');
-- Stepwise
</programlisting>
			</listitem>

			<listitem id="getValue">
				<indexterm><primary><varname>getValue</varname></primary></indexterm>
				<para>Get the value</para>
				<para><varname>getValue(ttype_inst): base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getValue(tint '1@2001-01-01');
-- 1
SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2001-01-01'));
-- POINT(0 0)
</programlisting>
			</listitem>

			<listitem id="getValues">
				<indexterm><primary><varname>getValues</varname></primary></indexterm>
				<para>Get the values</para>
				<para><varname>getValues(ttype): {base[],floatspan[],geo}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getValues(tint '[1@2001-01-01, 2@2001-01-03]');
-- {1,2}
SELECT getValues(tfloat '[1@2001-01-01, 2@2001-01-03)');
-- {[1,2)}
SELECT getValues(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 4@2001-01-05)}');
-- {[1,2),[3,4)}
SELECT getValues(tfloat 'Interp=Stepwise;{[1@2001-01-01, 2@2001-01-02],
  [3@2001-01-03, 4@2001-01-05]}');
-- {"[1,1]","[2,2]","[3,3]","[4,4]"}
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04)}'));
-- LINESTRING(0 0,0 1,1 1)
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(2 2)@2001-01-04)}'));
-- MULTILINESTRING((0 0,0 1),(1 1,2 2)
SELECT ST_AsText(getValues(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2001-01-01,
  Point(0 1)@2001-01-02], [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04]}'));
-- GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))
SELECT ST_AsText(getValues(tgeompoint '{Point(0 0)@2001-01-01, Point(0 1)@2001-01-02}'));
-- MULTIPOINT(0 0,0 1)
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
  [Point(2 1)@2001-01-05, Point(2 2)@2001-01-06)}'));
-- GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))
</programlisting>
			</listitem>

			<listitem id="startValue">
				<indexterm><primary><varname>startValue</varname></primary></indexterm>
				<para>Get the start value</para>
				<para><varname>startValue(ttype): base</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startValue(tfloat '(1@2001-01-01, 2@2001-01-03)');
-- 1
</programlisting>
			</listitem>

			<listitem id="endValue">
				<indexterm><primary><varname>endValue</varname></primary></indexterm>
				<para>Get the end value</para>
				<para><varname>endValue(ttype): base</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT endValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</programlisting>
			</listitem>

			<listitem id="minValue">
				<indexterm><primary><varname>minValue</varname></primary></indexterm>
				<para>Get the minimum value</para>
				<para><varname>minValue(torder): base</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minValue(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1
</programlisting>
			</listitem>

			<listitem id="maxValue">
				<indexterm><primary><varname>maxValue</varname></primary></indexterm>
				<para>Get the maximum value</para>
				<para><varname>maxValue(torder): base</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT maxValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</programlisting>
			</listitem>

			<listitem id="minInstant">
				<indexterm><primary><varname>minInstant</varname></primary></indexterm>
				<para>Get the instant with the minimum value</para>
				<para><varname>minInstant(torder): base</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not. If several instants have the minimum value, the first one is returned.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minInstant(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1@2001-01-01
</programlisting>
			</listitem>

			<listitem id="maxInstant">
				<indexterm><primary><varname>maxInstant</varname></primary></indexterm>
				<para>Get the instant with the maximum value</para>
				<para><varname>maxInstant(torder): base</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not. If several instants have the maximum value, the first one is returned.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT maxInstant(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5@2001-01-05
</programlisting>
			</listitem>

			<listitem id="valueSpan">
				<indexterm><primary><varname>valueSpan</varname></primary></indexterm>
				<para>Get the value span</para>
				<para><varname>valueSpan(tnumber): numspan</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT valueSpan(tfloat '{[2@2001-01-01, 1@2001-01-03), [4@2001-01-03, 6@2001-01-05)}');
-- [1,6]
SELECT valueSpan(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [1,3])
</programlisting>
			</listitem>

			<listitem id="valueAtTimestamp">
				<indexterm><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Get the value at a timestamp</para>
				<para><varname>valueAtTimestamp(ttype,timestamptz): base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT valueAtTimestamp(tfloat '[1@2001-01-01, 4@2001-01-04)', '2001-01-02');
-- 2
</programlisting>
			</listitem>

			<listitem id="getTimestamp">
				<indexterm><primary><varname>getTimestamp</varname></primary></indexterm>
				<para>Get the timestamp</para>
				<para><varname>getTimestamp(ttype_inst): timestamptz</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getTimestamp(tint '1@2001-01-01');
-- 2001-01-01
</programlisting>
			</listitem>

			<listitem id="getTime">
				<indexterm><primary><varname>getTime</varname></primary></indexterm>
				<para>Get the time</para>
				<para><varname>getTime(ttype): periodset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getTime(tint '[1@2001-01-01, 1@2001-01-15)');
-- {[2001-01-01, 2001-01-15)}
</programlisting>
			</listitem>

			<listitem id="ttype_duration">
				<indexterm><primary><varname>duration</varname></primary></indexterm>
				<para>Get the duration</para>
				<para><varname>duration(ttype): interval</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT duration(tfloat '[1@2001-01-01, 2@2001-01-03, 2@2001-01-05)');
-- 4 days
SELECT duration(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}');
-- 3 days
</programlisting>
			</listitem>

			<listitem id="ttype_timespan">
				<indexterm><primary><varname>timespan</varname></primary></indexterm>
				<para>Get the timespan ignoring the potential time gaps</para>
				<para><varname>timespan(ttype): interval</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timespan(tfloat '{1@2001-01-01, 2@2001-01-03, 2@2001-01-05}');
-- 4 days
SELECT timespan(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}');
-- 4 days
</programlisting>
			</listitem>

			<listitem id="ttype_period">
				<indexterm><primary><varname>period</varname></primary></indexterm>
				<para>Get the period on which the temporal value is defined ignoring the potential time gaps</para>
				<para><varname>period(ttype): period</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT period(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [2001-01-01, 2001-01-05]
SELECT period(tfloat '{[1@2001-01-01, 1@2001-01-02), [2@2001-01-03, 3@2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</programlisting>
			</listitem>

			<listitem id="numInstants">
				<indexterm><primary><varname>numInstants</varname></primary></indexterm>
				<para>Get the number of different instants</para>
				<para><varname>numInstants(ttype): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3
</programlisting>
			</listitem>

			<listitem id="startInstant">
				<indexterm><primary><varname>startInstant</varname></primary></indexterm>
				<para>Get the start instant</para>
				<para><varname>startInstant(ttype): ttype_inst</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02),
  (2@2000-01-02, 3@2000-01-03)}');
-- 1@2000-01-01
</programlisting>
			</listitem>

			<listitem id="endInstant">
				<indexterm><primary><varname>endInstant</varname></primary></indexterm>
				<para>Get the end instant</para>
				<para><varname>endInstant(ttype): ttype_inst</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3@2000-01-03
</programlisting>
			</listitem>

			<listitem id="instantN">
				<indexterm><primary><varname>instantN</varname></primary></indexterm>
				<para>Get the n-th different instant</para>
				<para><varname>instantN(ttype,integer): ttype_inst</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);
-- 3@2000-01-03
</programlisting>
			</listitem>

			<listitem id="instants">
				<indexterm><primary><varname>instants</varname></primary></indexterm>
				<para>Get the different instants</para>
				<para><varname>instants(ttype): ttype_inst[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- {"1@2000-01-01","2@2000-01-02","3@2000-01-03"}
</programlisting>
			</listitem>

			<listitem id="ttype_numTimestamps">
				<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
				<para>Get the number of different timestamps</para>
				<para><varname>numTimestamps(ttype): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numTimestamps(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 3
</programlisting>
			</listitem>

			<listitem id="ttype_startTimestamp">
				<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
				<para>Get the start timestamp</para>
				<para><varname>startTimestamp(ttype): timestamptz</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startTimestamp(tfloat '[1@2001-01-01, 2@2001-01-03)');
-- 2001-01-01
</programlisting>
			</listitem>

			<listitem id="ttype_endTimestamp">
				<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
				<para>Get the end timestamp</para>
				<para><varname>endTimestamp(ttype): timestamptz</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT endTimestamp(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2001-01-05
</programlisting>
			</listitem>

			<listitem id="ttype_timestampN">
				<indexterm><primary><varname>timestampN</varname></primary></indexterm>
				<para>Get the n-th different timestamp</para>
				<para><varname>timestampN(ttype,integer): timestamptz</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timestampN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 3);
-- 2001-01-05
</programlisting>
			</listitem>

			<listitem id="ttype_timestamps">
				<indexterm><primary><varname>timestamps</varname></primary></indexterm>
				<para>Get the different timestamps</para>
				<para><varname>timestamps(ttype): timestamptz[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timestamps(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"2001-01-01", "2001-01-03", "2001-01-05"}
</programlisting>
			</listitem>

			<listitem id="numSequences">
				<indexterm><primary><varname>numSequences</varname></primary></indexterm>
				<para>Get the number of sequences</para>
				<para><varname>numSequences({ttype_seq,ttype_seqset}): integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numSequences(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2
</programlisting>
			</listitem>

			<listitem id="startSequence">
				<indexterm><primary><varname>startSequence</varname></primary></indexterm>
				<para>Get the start sequence</para>
				<para><varname>startSequence({ttype_seq,ttype_seqset}): ttype_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT startSequence(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- [1@2001-01-01, 2@2001-01-03)
</programlisting>
			</listitem>

			<listitem id="endSequence">
				<indexterm><primary><varname>endSequence</varname></primary></indexterm>
				<para>Get the end sequence</para>
				<para><varname>endSequence({ttype_seq,ttype_seqset}): ttype_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT endSequence(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- [3@2001-01-03, 5@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="sequenceN">
				<indexterm><primary><varname>sequenceN</varname></primary></indexterm>
				<para>Get the n-th sequence</para>
				<para><varname>sequenceN({ttype_seq,ttype_seqset},integer): ttype_seq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT sequenceN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 2);
-- [3@2001-01-03, 5@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="sequences">
				<indexterm><primary><varname>sequences</varname></primary></indexterm>
				<para>Get the sequences</para>
				<para><varname>sequences({ttype_seq,ttype_seqset}): ttype_seq[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT sequences(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"[1@2001-01-01, 2@2001-01-03)", "[3@2001-01-03, 5@2001-01-05)"}
</programlisting>
			</listitem>

			<listitem id="segments">
				<indexterm><primary><varname>segments</varname></primary></indexterm>
				<para>Get the segments</para>
				<para><varname>segments({ttype_seq,ttype_seqset}): ttype_seq[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT segments(tint '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 1@2001-01-02)","[3@2001-01-02, 3@2001-01-03)","[2@2001-01-03]",
   "(3@2001-01-03, 3@2001-01-05)","[5@2001-01-05]"} */
SELECT segments(tfloat '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 3@2001-01-02)","[3@2001-01-02, 2@2001-01-03]",
   "(3@2001-01-03, 5@2001-01-05]"} */
</programlisting>
			</listitem>

			<listitem id="intersectsTimestamp">
				<indexterm><primary><varname>intersectsTimestamp</varname></primary></indexterm>
				<para>Does the temporal value intersect the timestamp?</para>
				<para><varname>intersectsTimestamp(ttype,timestamptz): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsTimestamp(tint '[1@2001-01-01, 1@2001-01-15)', timestamptz '2001-01-03');
-- true
</programlisting>
			</listitem>

			<listitem id="intersectsTimestampSet">
				<indexterm><primary><varname>intersectsTimestampSet</varname></primary></indexterm>
				<para>Does the temporal value intersect the timestamp set?</para>
				<para><varname>intersectsTimestampSet(ttype,timestampset): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsTimestampSet(tint '[1@2001-01-01, 1@2001-01-15)',
  timestampset '{2001-01-01, 2001-01-03}');
-- true
</programlisting>
			</listitem>

			<listitem id="intersectsPeriod">
				<indexterm><primary><varname>intersectsPeriod</varname></primary></indexterm>
				<para>Does the temporal value intersect the period?</para>
				<para><varname>intersectsPeriod(ttype,period): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsPeriod(tint '[1@2001-01-01, 1@2001-01-04)',
  period '[2001-01-01,2001-01-05)');
-- true
</programlisting>
			</listitem>

			<listitem id="intersectsPeriodSet">
				<indexterm><primary><varname>intersectsPeriodSet</varname></primary></indexterm>
				<para>Does the temporal value intersect the period set?</para>
				<para><varname>intersectsPeriodSet(ttype,periodset): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT intersectsPeriodSet(tbool '[t@2001-01-01, f@2001-01-15]',
  periodset '{[2001-01-01, 2001-01-03), [2001-01-05, 2001-01-07)}');
-- true
</programlisting>
			</listitem>

			<listitem id="twAvg">
				<indexterm><primary><varname>twAvg</varname></primary></indexterm>
				<para>Get the time-weighted average</para>
				<para><varname>twAvg(tnumber): float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT twAvg(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-06)}');
-- 1.75
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="modification_functions">
		<title>Modification Functions</title>
		<para>A temporal value can be transformed to another subtype. An error is raised if the subtypes are incompatible.</para>
		<itemizedlist>
			<listitem id="ttype_transform">
				<indexterm><primary><varname>ttype_inst</varname></primary></indexterm>
				<indexterm><primary><varname>ttype_seq</varname></primary></indexterm>
				<indexterm><primary><varname>ttype_discseq</varname></primary></indexterm>
				<indexterm><primary><varname>ttype_seqset</varname></primary></indexterm>
				<para>Transform a temporal value to another subtype</para>
				<para><varname>ttype_inst(ttype): ttype_inst</varname></para>
				<para><varname>ttype_seq(ttype): ttype_seq</varname></para>
				<para><varname>ttype_discseq(ttype): ttype_discseq</varname></para>
				<para><varname>ttype_seqset(ttype): ttype_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_inst(tbool '{[true@2001-01-01]}');
-- t@2001-01-01
SELECT tbool_inst(tbool '{[true@2001-01-01, true@2001-01-02]}');
-- ERROR: Cannot transform input to a temporal instant
SELECT tint_seq(tint '1@2001-01-01');
-- [1@2001-01-01]
SELECT tbool_discseq(tbool 'true@2001-01-01');
-- {t@2001-01-01}
SELECT tfloat_seqset(tfloat '2.5@2001-01-01');
-- {[2.5@2001-01-01]}
SELECT tfloat_seqset(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');
-- {[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}
</programlisting>
			</listitem>

			<listitem id="toLinear">
				<indexterm><primary><varname>toLinear</varname></primary></indexterm>
				<para>Transform a temporal value with continuous base type from stepwise to linear interpolation</para>
				<para><varname>toLinear(ttype): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02,
  1@2000-01-03, 2@2000-01-04]');
/* {[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03),
   [1@2000-01-03, 1@2000-01-04), [2@2000-01-04]} */
SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01,
  Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));
/* {[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02],
   [POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]} */
</programlisting>
			</listitem>

			<listitem id="appendInstant">
				<indexterm><primary><varname>appendInstant</varname></primary></indexterm>
				<para>Append a temporal instant to a temporal value</para>
				<para><varname>appendInstant(ttype,ttype_inst): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');
-- {1@2000-01-01, 1@2000-01-02}
SELECT appendInstant(tint_seq(tint '1@2000-01-01'), tint '1@2000-01-02');
-- [1@2000-01-01, 1@2000-01-02]
SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tgeompoint 'Point(1 1 1)@2000-01-06'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
   [POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05,
   POINT Z (1 1 1)@2000-01-06]} */
</programlisting>
			</listitem>

			<listitem id="merge">
				<indexterm><primary><varname>merge</varname></primary></indexterm>
				<para>Merge the temporal values</para>
				<para><varname>merge(ttype,ttype): ttype</varname></para>
				<para><varname>merge(ttype[]): ttype</varname></para>
				<para>The values may share a single timestamp, in that case the temporal values are joined in the result if their value at the common timestamp is the same, otherwise an error is raised.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT merge(tint '1@2000-01-01', tint '1@2000-01-02');
-- {1@2000-01-01, 1@2000-01-02}
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[2@2000-01-02, 1@2000-01-03]');
-- [1@2000-01-01, 2@2000-01-02, 1@2000-01-03]
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[3@2000-01-03, 1@2000-01-04]');
-- {[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 1@2000-01-04]}
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[1@2000-01-02, 2@2000-01-03]');
-- ERROR:  Both arguments have different value at their overlapping timestamp
SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tgeompoint '{[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]}'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
   [POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05,
   POINT Z (1 1 1)@2000-01-06]} */

SELECT merge(ARRAY[tint '1@2000-01-01', '1@2000-01-02']);
-- {1@2000-01-01, 1@2000-01-02}
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{2@2000-01-02, 3@2000-01-03}']);
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03}
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{3@2000-01-03, 4@2000-01-04}']);
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04}
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[2@2000-01-02, 1@2000-01-03]']);
-- [1@2000-01-01, 2@2000-01-02, 1@2000-01-03]
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[3@2000-01-03, 4@2000-01-04]']);
-- {[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 4@2000-01-04]}
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
  [Point(3 3)@2000-01-03, Point(4 4)@2000-01-04]}', '{[Point(4 4)@2000-01-04,
  Point(3 3)@2000-01-05], [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}']);
/* {[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], [Point(3 3)@2000-01-03,
   Point(4 4)@2000-01-04, Point(3 3)@2000-01-05],
  [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]} */
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02]}',
  '{[Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]}']);
-- [Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]
</programlisting>
			</listitem>

			<listitem id="shift">
				<indexterm><primary><varname>shift</varname></primary></indexterm>
				<para>Shift the timespan of the temporal value by an interval</para>
				<para><varname>shift(ttype,interval): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- {1@2001-01-02, 2@2001-01-04, 1@2001-01-06}
SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- [1@2001-01-02, 2@2001-01-04]
SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03],
  [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
/* {[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04],
   [POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]} */
</programlisting>
			</listitem>

			<listitem id="tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Scale the time span of the temporal value to an interval. If the time span of the temporal value is zero (for example, for a temporal instant), the result is the temporal value. The given interval must be strictly greater than zero.</para>
				<para><varname>tscale(ttype,interval): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tscale(tint '1@2001-01-01', '1 day');
-- 1@2001-01-01
SELECT tscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- {1@2001-01-01 00:00:00+01, 2@2001-01-01 12:00:00+01, 1@2001-01-02 00:00:00+01}
SELECT tscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- [1@2001-01-01, 2@2001-01-02]
SELECT asText(tscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
/* {[POINT(1 1)@2001-01-01 00:00:00+01, POINT(2 2)@2001-01-01 06:00:00+01,
   POINT(1 1)@2001-01-01 12:00:00+01], [POINT(2 2) @2001-01-01 18:00:00+01,
   POINT(1 1)@2001-01-02 00:00:00+01]} */
SELECT tscale(tint '1@2001-01-01', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem id="shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Shift and scale the time span of the temporal value to the two intervals. This function combines in a single step the functions <link linkend="shift"><varname>shift</varname></link> and <link linkend="tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale(ttype,interval,interval): ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shiftTscale(tint '1@2001-01-01', '1 day', '1 day');
-- 1@2001-01-02
SELECT shiftTscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day', '1 day');
-- {1@2001-01-02 00:00:00+01, 2@2001-01-02 12:00:00+01, 1@2001-01-03 00:00:00+01}
SELECT shiftTscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day', '1 day');
-- [1@2001-01-02, 2@2001-01-03]
SELECT asText(shiftTscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}',
  '1 day', '1 day'));
/* {[POINT(1 1)@2001-01-02 00:00:00+01, POINT(2 2)@2001-01-02 06:00:00+01,
   POINT(1 1)@2001-01-02 12:00:00+01], [POINT(2 2) @2001-01-02 18:00:00+01,
   POINT(1 1)@2001-01-03 00:00:00+01]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="restriction_functions">
		<title>Restriction Functions</title>

		<sect2>
			<title>Selection Functions</title>
			<para>These functions restrict the temporal value with respect to a value or a time extent.</para>

			<itemizedlist>
				<listitem id="atValue">
					<indexterm><primary><varname>atValue</varname></primary></indexterm>
					<para>Restrict to a value</para>
					<para><varname>atValue(ttype,base): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atValue(tint '[1@2001-01-01, 1@2001-01-15)', 1);
-- [1@2001-01-01, 1@2001-01-15)
SELECT asText(atValue(tgeompoint '[Point(0 0 0)@2001-01-01, Point(2 2 2)@2001-01-03)',
  'Point(1 1 1)'));
-- {[POINT Z (1 1 1)@2001-01-02]}
</programlisting>
				</listitem>

				<listitem id="atValues">
					<indexterm><primary><varname>atValues</varname></primary></indexterm>
					<para>Restrict to an array of values</para>
					<para><varname>atValues(ttype,base[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atValues(tfloat '[1@2001-01-01, 4@2001-01-4)', ARRAY[1, 3, 5]);
-- {[1@2001-01-01], [3@2001-01-03]}
SELECT asText(atValues(tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)',
  ARRAY[geometry 'Point(0 0)', 'Point(1 1)']));
-- {[POINT(0 0)@2001-01-01], [POINT(1 1)@2001-01-02]}
</programlisting>
			</listitem>

				<listitem id="atSpan">
					<indexterm><primary><varname>atSpan</varname></primary></indexterm>
					<para>Restrict to a span</para>
					<para><varname>atSpan(tnumber,numspan): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atSpan(tfloat '[1@2001-01-01, 4@2001-01-4)', floatspan '[1,3]');
-- [1@2001-01-01, 3@2001-01-03]
</programlisting>
				</listitem>

				<listitem id="atSpans">
					<indexterm><primary><varname>atSpans</varname></primary></indexterm>
					<para>Restrict to an array of spans</para>
					<para><varname>atSpans(tnumber,numspan[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atSpans(tfloat '[1@2001-01-01, 5@2001-01-05)',
  ARRAY[floatspan '[1,2]', '[3,4]']);
-- {[1@2001-01-01, 2@2001-01-02],[3@2001-01-03, 4@2001-01-04]}
</programlisting>
				</listitem>

				<listitem id="atMin">
					<indexterm><primary><varname>atMin</varname></primary></indexterm>
					<para>Restrict to the minimum value</para>
					<para><varname>atMin(torder): torder</varname></para>
					<para>The function returns null if the minimum value only happens at exclusive bounds.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT atMin(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}');
-- {1@2001-01-01, 1@2001-01-05}
SELECT atMin(tint '(1@2001-01-01, 3@2001-01-03]');
-- {(1@2001-01-01, 1@2001-01-03)}
SELECT atMin(tfloat '(1@2001-01-01, 3@2001-01-03]');
-- NULL
SELECT atMin(ttext '{(AA@2001-01-01, AA@2001-01-03), (BB@2001-01-03, AA@2001-01-05]}');
-- {(AA@2001-01-01, AA@2001-01-03), [AA@2001-01-05]}
</programlisting>
				</listitem>

				<listitem id="atMax">
					<indexterm><primary><varname>atMax</varname></primary></indexterm>
					<para>Restrict to the maximum value</para>
					<para><varname>atMax(torder): torder</varname></para>
					<para>The function returns null if the maximum value only happens at exclusive bounds.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT atMax(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- {3@2001-01-05}
SELECT atMax(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- NULL
SELECT atMax(tfloat '{(2@2001-01-01, 1@2001-01-03), [2@2001-01-03, 2@2001-01-05)}');
-- {[2@2001-01-03, 2@2001-01-05]}
SELECT atMax(ttext '{(AA@2001-01-01, AA@2001-01-03), (BB@2001-01-03, AA@2001-01-05]}');
-- {("BB"@2001-01-03, "BB"@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="atGeometry">
					<indexterm><primary><varname>atGeometry</varname></primary></indexterm>
					<para>Restrict to a geometry</para>
					<para><varname>atGeometry(tgeompoint,geometry): tgeompoint</varname></para>
					<para>Notice that it is allowed to mix 2D/3D geometries but the computation is only performed on 2D.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- {"[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-03]"}
SELECT astext(atGeometry(tgeompoint '[Point(0 0 0)@2000-01-01, Point(4 4 4)@2000-01-05]',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- {[POINT Z (1 1 1)@2000-01-02, POINT Z (2 2 2)@2000-01-03]}
</programlisting>
				</listitem>

				<listitem id="atTimestamp">
					<indexterm><primary><varname>atTimestamp</varname></primary></indexterm>
					<para>Restrict to a timestamp</para>
					<para><varname>atTimestamp(ttype,timestamptz): ttype_inst</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atTimestamp(tfloat '[1@2001-01-01, 5@2001-01-05)', '2001-01-02');
-- 2@2001-01-02
</programlisting>
				</listitem>

				<listitem id="atTimestampSet">
					<indexterm><primary><varname>atTimestampSet</varname></primary></indexterm>
					<para>Restrict to a timestamp set</para>
					<para><varname>atTimestampSet(ttype,timestampset): {ttype_inst,ttype_seq}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atTimestampSet(tint '[1@2001-01-01, 1@2001-01-15)',
  timestampset '{2001-01-01, 2001-01-03}');
-- {1@2001-01-01, 1@2001-01-03}
</programlisting>
				</listitem>

				<listitem id="atPeriod">
					<indexterm><primary><varname>atPeriod</varname></primary></indexterm>
					<para>Restrict to a period</para>
					<para><varname>atPeriod(ttype,period): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atPeriod(tfloat '{[1@2001-01-01, 3@2001-01-03), [3@2001-01-04, 1@2001-01-06)}',
  '[2001-01-02,2001-01-05)');
-- {[2@2001-01-02, 3@2001-01-03), [3@2001-01-04, 2@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="atPeriodSet">
					<indexterm><primary><varname>atPeriodSet</varname></primary></indexterm>
					<para>Restrict to a period set</para>
					<para><varname>atPeriodSet(ttype,periodset): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atPeriodSet(tint '[1@2001-01-01, 1@2001-01-15)',
  periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- {[1@2001-01-01, 1@2001-01-03),[1@2001-01-04, 1@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="atTbox">
					<indexterm><primary><varname>atTbox</varname></primary></indexterm>
					<para>Restrict to a <varname>tbox</varname></para>
					<para><varname>atTbox(tnumber,tbox): tnumber</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT atTbox(tfloat '[0@2001-01-01, 3@2001-01-04)',
  tbox 'TBOX XT((0,2),[2001-01-02, 2001-01-04])');
-- {[1@2001-01-02, 2@2001-01-03]}
</programlisting>
			</listitem>

				<listitem id="atStbox">
					<indexterm><primary><varname>atStbox</varname></primary></indexterm>
					<para>Restrict to an <varname>stbox</varname></para>
					<para><varname>atStbox(tgeompoint,stbox): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(atStbox(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  stbox 'STBOX XT(((0,0),(2,2))),[2001-01-02, 2001-01-04]'));
-- {[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-03]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Difference Functions</title>
			<para>These functions restrict the temporal value with respect to the complement of a value and/or a time extent.</para>
			<itemizedlist>
				<listitem id="minusValue">
					<indexterm><primary><varname>minusValue</varname></primary></indexterm>
					<para>Difference with a value</para>
					<para><varname>minusValue(ttype,base): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusValue(tint '[1@2001-01-01, 2@2001-01-02, 2@2001-01-03)', 1);
-- {[2@2001-01-02, 2@2001-01-03)}
SELECT asText(minusValue(tgeompoint '[Point(0 0 0)@2001-01-01, Point(2 2 2)@2001-01-03)',
  'Point(1 1 1)'));
/* {[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02),
   (POINT Z (1 1 1)@2001-01-02, POINT Z (2 2 2)@2001-01-03)} */
</programlisting>
				</listitem>

				<listitem id="minusValues">
					<indexterm><primary><varname>minusValues</varname></primary></indexterm>
					<para>Difference with an array of values</para>
					<para><varname>minusValues(ttype,base[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusValues(tfloat '[1@2001-01-01, 4@2001-01-4)', ARRAY[2, 3]);
/* {[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03),
   (3@2001-01-03, 4@2001-01-04)} */
SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2001-01-01, Point(3 3 3)@2001-01-04)',
  ARRAY[geometry 'Point(1 1 1)', 'Point(2 2 2)']));
/* {[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02),
   (POINT Z (1 1 1)@2001-01-02, POINT Z (2 2 2)@2001-01-03),
  (POINT Z (2 2 2)@2001-01-03, POINT Z (3 3 3)@2001-01-04)} */
</programlisting>
				</listitem>

				<listitem id="minusSpan">
					<indexterm><primary><varname>minusSpan</varname></primary></indexterm>
					<para>Difference with a span</para>
					<para><varname>minusSpan(tnumber,numspan): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusSpan(tfloat '[1@2001-01-01, 4@2001-01-4)', floatspan '[2,3]');
-- {[1@2001-01-01, 2@2001-01-02), (3@2001-01-03, 4@2001-01-04)}
</programlisting>
				</listitem>

				<listitem id="minusSpans">
					<indexterm><primary><varname>minusSpans</varname></primary></indexterm>
					<para>Difference with an array of spans</para>
					<para><varname>minusSpans(tnumber,numspan[]): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusSpans(tfloat '[1@2001-01-01, 5@2001-01-05)',
  ARRAY[floatspan '[1,2]', '[3,4]']);
-- {(2@2001-01-02, 3@2001-01-03), (4@2001-01-04, 5@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="minusMin">
					<indexterm><primary><varname>minusMin</varname></primary></indexterm>
					<para>Difference with the minimum value</para>
					<para><varname>minusMin(torder): torder</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusMin(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}');
-- {2@2001-01-03}
SELECT minusMin(tfloat '[1@2001-01-01, 3@2001-01-03]');
-- {(1@2001-01-01, 3@2001-01-03]}
SELECT minusMin(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- {(1@2001-01-01, 3@2001-01-03)}
SELECT minusMin(tint '{[1@2001-01-01, 1@2001-01-03), (1@2001-01-03, 1@2001-01-05)}');
-- NULL
</programlisting>
				</listitem>

				<listitem id="minusMax">
					<indexterm><primary><varname>minusMax</varname></primary></indexterm>
					<para>Difference with the maximum value</para>
					<para><varname>minusMax(torder): torder</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusMax(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- {1@2001-01-01, 2@2001-01-03}
SELECT minusMax(tfloat '[1@2001-01-01, 3@2001-01-03]');
-- {[1@2001-01-01, 3@2001-01-03)}
SELECT minusMax(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- {(1@2001-01-01, 3@2001-01-03)}
SELECT minusMax(tfloat '{[2@2001-01-01, 1@2001-01-03), [2@2001-01-03, 2@2001-01-05)}');
-- {(2@2001-01-01, 1@2001-01-03)}
SELECT minusMax(tfloat '{[1@2001-01-01, 3@2001-01-03), (3@2001-01-03, 1@2001-01-05)}');
-- {[1@2001-01-01, 3@2001-01-03), (3@2001-01-03, 1@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="minusGeometry">
					<indexterm><primary><varname>minusGeometry</varname></primary></indexterm>
					<para>Difference with a geometry</para>
					<para><varname>minusGeometry(tgeompoint,geometry): tgeompoint</varname></para>
					<para>Notice that it is allowed to mix 2D/3D geometries but the computation is only performed on 2D.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
/* {[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02), (POINT(2 2)@2001-01-03,
   POINT(3 3)@2001-01-04)} */
SELECT astext(minusGeometry(tgeompoint '[Point(0 0 0)@2000-01-01,
  Point(4 4 4)@2000-01-05]', geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
/* {[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02),
   (POINT Z (2 2 2)@2000-01-03, POINT Z (4 4 4)@2000-01-05]} */
</programlisting>
				</listitem>

				<listitem id="minusTimestamp">
					<indexterm><primary><varname>minusTimestamp</varname></primary></indexterm>
					<para>Difference with a timestamp</para>
					<para><varname>minusTimestamp(ttype,timestamptz): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusTimestamp(tfloat '[1@2001-01-01, 5@2001-01-05)', '2001-01-02');
-- {[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 5@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="minusTimestampSet">
					<indexterm><primary><varname>minusTimestampSet</varname></primary></indexterm>
					<para>Difference with a timestamp set</para>
					<para><varname>minusTimestampSet(ttype,timestampset): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusTimestampSet(tint '[1@2001-01-01, 1@2001-01-15)',
  timestampset '{2001-01-02, 2001-01-03}');
/* {[1@2001-01-01, 1@2001-01-02), (1@2001-01-02, 1@2001-01-03),
   (1@2001-01-03, 1@2001-01-15)} */
</programlisting>
				</listitem>

				<listitem id="minusPeriod">
					<indexterm><primary><varname>minusPeriod</varname></primary></indexterm>
					<para>Difference with a period</para>
					<para><varname>minusPeriod(ttype,period): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusPeriod(tfloat '{[1@2001-01-01, 3@2001-01-03), [3@2001-01-04, 1@2001-01-06)}',
  '[2001-01-02,2001-01-05)');
-- {[1@2001-01-01, 2@2001-01-02), [2@2001-01-05, 1@2001-01-06)}
</programlisting>
				</listitem>

				<listitem id="minusPeriodSet">
					<indexterm><primary><varname>minusPeriodSet</varname></primary></indexterm>
					<para>Difference with a period set</para>
					<para><varname>minusPeriodSet(ttype,periodset): ttype</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusPeriodSet(tint '[1@2001-01-01, 1@2001-01-15)',
  periodset '{[2001-01-02, 2001-01-03), [2001-01-04, 2001-01-05)}');
/* {[1@2001-01-01, 1@2001-01-02), [1@2001-01-03, 1@2001-01-04),
   [1@2001-01-05, 1@2001-01-15)} */
</programlisting>
				</listitem>

				<listitem id="minusTbox">
					<indexterm><primary><varname>minusTbox</varname></primary></indexterm>
					<para>Difference with a <varname>tbox</varname></para>
					<para><varname>minusTbox(tnumber,tbox): tnumber</varname></para>
					<para>Notice that when the bounding box has both value and time dimensions, the difference is computed by restricting the temporal number to the box using the function <varname>atTbox</varname>, computing the time extent of this restriction, and restricting the temporal number to the difference of the time extent. This is required to ensure that <varname>tnumber = merge(atTbox(tnumber,tbox), minusTbox(tnumber,tbox))</varname> (see the function <link linkend="merge"><varname>merge</varname></link>). In other words, while the function <varname>atTbox</varname> restricts the temporal number with respect to the span <emphasis>and</emphasis> the period defining the bounding box, the function <varname>minusTbox</varname> restricts the temporal number with respect to the span <emphasis>or</emphasis> the period. To obtain the restriction using an <emphasis>and</emphasis> semantics, both the <varname>minusSpan</varname> and <varname>minusPeriod</varname> functions must be applied.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT minusTbox(tfloat '[1@2001-01-01, 4@2001-01-04)',
  'TBOX XT((1,4),[2001-01-03, 2001-01-04])');
-- {[1@2001-01-01, 3@2001-01-03)}
WITH temp(temp, box) AS (SELECT tfloat '[1@2001-01-01, 4@2001-01-04)',
  'TBOX XT((1,2),[2001-01-03, 2001-01-04])' )
SELECT minusSpan(minusPeriod(temp, box::period), box::floatspan) FROM temp;
-- {[1@2001-01-01], [2@2001-01-02, 3@2001-01-03)}
</programlisting>
				</listitem>

				<listitem id="minusStbox">
					<indexterm><primary><varname>minusStbox</varname></primary></indexterm>
					<para>Difference with an <varname>stbox</varname></para>
					<para><varname>minusStbox(tgeompoint,stbox): tgeompoint</varname></para>
					<para>Similary to the function <link linkend="minusTbox"><varname>minusTbox</varname></link>, when the bounding box has both space and time dimensions, the function <varname>minusStbox</varname> restricts the temporal point with respect to the space <emphasis>or</emphasis> the time extents of the box. To obtain the restriction using an <emphasis>and</emphasis> semantics, both the <varname>minusGeometry</varname> and <varname>minusPeriod</varname> functions must be applied.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(minusStbox(tgeompoint '[Point(1 1)@2001-01-01, Point(4 4)@2001-01-04)',
  stbox 'STBOX XT(((1,1),(4,4)),[2001-01-03,2001-01-04])'));
-- {[POINT(1 1)@2001-01-01), POINT(3 3)@2001-01-03)}
WITH temp(temp, box) AS (SELECT 
  tgeompoint '[Point(1 1)@2001-01-01, Point(4 4)@2001-01-04)',
  stbox 'STBOX XT(((1,1),(2,2)),[2001-01-03,2001-01-04])')
SELECT asText(minusGeometry(minusPeriod(temp, box::period), box::geometry)) FROM temp;
-- {(POINT(2 2)@2001-01-02, POINT(3 3)@2001-01-03)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id="operators_temporal_types">
		<title>Comparison Operators</title>

		<sect2>
			<title>Traditional Comparison Operators</title>

			<para>The traditional comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right operands be of the same base type. Excepted equality  and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on temporal types. These operators compare the bounding periods (see <xref linkend="time_comp_operators" />), then the bounding boxes (see <xref linkend="comparison_box_types" />) and if those are equal, then the comparison depends on the subtype. For instant values, they compare first the timestamps and if those are equal, compare the values. For sequence values, they compare the first N instants, where N is the minimum of the number of composing instants of both values. Finally, for sequence set values, they compare the first N sequence values, where N is the minimum of the number of composing sequences of both values.</para>

			<para>The equality and inequality operators consider the equivalent representation for different subtypes as shown next.
				<programlisting language="sql" xml:space="preserve">
SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';
-- true
SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';
-- true
SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';
-- true
SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =
  tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';
-- true
SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =
  tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';
-- true
</programlisting>
			</para>

			<itemizedlist>
				<listitem id="ttype_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Are the temporal values equal?</para>
					<para><varname>ttype = ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' = tint '[2@2001-01-03, 2@2001-01-05)';
-- false
</programlisting>
				</listitem>

				<listitem id="ttype_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>Are the temporal values different?</para>
					<para><varname>ttype &lt;&gt; ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;&gt; tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>Is the first temporal value less than the second one?</para>
					<para><varname>ttype &lt; ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt; tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>Is the first temporal value greater than the second one?</para>
					<para><varname>ttype &gt; ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt; tint '[2@2001-01-03, 2@2001-01-05)'
-- false
</programlisting>
				</listitem>

				<listitem id="ttype_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>Is the first temporal value less than or equal to the second one?</para>
					<para><varname>ttype &lt;= ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;= tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
				<para>Is the first temporal value greater than or equal to the second one?</para>
					<para><varname>ttype &gt;= ttype: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt;= tint '[2@2001-01-03, 2@2001-01-05)'
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="ever_always_comparison">
			<title>Ever and Always Comparison Operators</title>
			<para>A possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types consists in determining whether the comparison is ever or always true. In this case, the result is a Boolean value. MobilityDB provides operators to test whether the comparison of a temporal value and a value of the base type is ever or always true. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Some examples are <varname>?=</varname>, <varname>%&lt;&gt;</varname>, or <varname>?&lt;=</varname>. Ever/always equality and non-equality are available for all temporal types, while ever/always inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>. The ever and always comparisons are inverse operators: for example, <varname>?=</varname> is the inverse of <varname>%&lt;&gt;</varname>, and <varname>?&gt;</varname> is the inverse of <varname>%&lt;=</varname>.</para>
			<itemizedlist>
				<listitem id="ttype_eveq">
					<indexterm><primary><varname>?=</varname></primary></indexterm>
					<para>Is the temporal value ever equal to the value?</para>
					<para><varname>ttype ?= base: boolean</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?= 2;
-- true
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' ?=
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_evne">
					<indexterm><primary><varname>?&lt;&gt;</varname></primary></indexterm>
					<para>Is the temporal value ever different from the value?</para>
					<para><varname>ttype ?&lt;&gt; base: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?&lt;&gt; 2;
-- false
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' ?&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' ?&lt;&gt;
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_evlt">
					<indexterm><primary><varname>?&lt;</varname></primary></indexterm>
					<para>Is the temporal value ever less than the value?</para>
					<para><varname>tnumber ?&lt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' ?&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' ?&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_evgt">
					<indexterm><primary><varname>?&gt;</varname></primary></indexterm>
					<para>Is the temporal value ever greater than the value?</para>
					<para><varname>tnumber ?&gt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-03, 1@2001-01-05)' ?&gt; 1;
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_evle">
					<indexterm><primary><varname>?&lt;=</varname></primary></indexterm>
					<para>Is the temporal value ever less than or equal to the value?</para>
					<para><varname>tnumber ?&lt;= number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' ?&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_evge">
					<indexterm><primary><varname>?&gt;=</varname></primary></indexterm>
					<para>Is the temporal value ever greater than or equal to the value?</para>
					<para><varname>tnumber ?&gt;= number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text ?&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_aleq">
					<indexterm><primary><varname>%=</varname></primary></indexterm>
					<para>Is the temporal value always equal to the value?</para>
					<para><varname>ttype %= base: boolean</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %= 2;
-- true
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' %=
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_alne">
					<indexterm><primary><varname>%&lt;&gt;</varname></primary></indexterm>
					<para>Is the temporal value always different to the value?</para>
					<para><varname>ttype %&lt;&gt; base: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %&lt;&gt; 2;
-- false
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' %&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' %&lt;&gt;
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_allt">
					<indexterm><primary><varname>%&lt;</varname></primary></indexterm>
					<para>Is the temporal value always less than the value?</para>
					<para><varname>tnumber %&lt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' %&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' %&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_algt">
					<indexterm><primary><varname>%&gt;</varname></primary></indexterm>
					<para>Is the temporal value always greater than the value?</para>
					<para><varname>tnumber %&gt; number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-03, 1@2001-01-05)' %&gt; 1;
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_alle">
					<indexterm><primary><varname>%&lt;=</varname></primary></indexterm>
					<para>Is the temporal value always less than or equal to the value?</para>
					<para><varname>tnumber %&lt;= number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' %&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_alge">
					<indexterm><primary><varname>%&gt;=</varname></primary></indexterm>
					<para>Is the temporal value always greater than or equal to the value?</para>
					<para><varname>tnumber %&gt;= number: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text %&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Temporal Comparison Operators</title>
			<para>Another possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types consists in determining whether the comparison is true or false at each instant. In this case, the result is a temporal Boolean. The temporal comparison operators are denoted by prefixing the traditional comparison operators with <varname>#</varname>. Some examples are <varname>#=</varname>  or <varname>#&lt;=</varname>. Temporal equality and non-equality are available for all temporal types, while temporal inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>.</para>

			<itemizedlist>
				<listitem id="ttype_teq">
					<indexterm><primary><varname>#=</varname></primary></indexterm>
					<para>Temporal equal</para>
					<para><varname>{base,ttype} #= {base,ttype}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 2@2001-01-04)' #= 3;
-- {[f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tint '[1@2001-01-01, 1@2001-01-04)';
-- {[t@2001-01-01], (f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tfloat '[4@2001-01-02, 1@2001-01-05)';
-- {[f@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  geometry 'Point(1 1)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  tgeompoint '[Point(0 2)@2001-01-01, Point(2 0)@2001-01-03)';
-- {[f@2001-01-01], (t@2001-01-01, t@2001-01-03)}
</programlisting>
				</listitem>

				<listitem id="ttype_tne">
					<indexterm><primary><varname>#&lt;&gt;</varname></primary></indexterm>
					<para>Temporal different</para>
					<para><varname>{base,ttype} #&lt;&gt; {base,ttype}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; 2;
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, 2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; tint '[2@2001-01-02, 2@2001-01-05)';
-- {[f@2001-01-02], (t@2001-01-02, t@2001-01-04)}
</programlisting>
				</listitem>

				<listitem id="ttype_tlt">
					<indexterm><primary><varname>#&lt;</varname></primary></indexterm>
					<para>Temporal less than</para>
					<para><varname>{base,torder} #&lt; {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' #&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_tgt">
					<indexterm><primary><varname>#&gt;</varname></primary></indexterm>
					<para>Temporal greater than</para>
					<para><varname>{base,torder} #&gt; {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 1 #&gt; tint '[1@2001-01-03, 1@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_tle">
					<indexterm><primary><varname>#&lt;=</varname></primary></indexterm>
					<para>Temporal less than or equal to</para>
					<para><varname>{base,torder} #&lt;= {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' #&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_tge">
					<indexterm><primary><varname>#&gt;=</varname></primary></indexterm>
					<para>Temporal greater than or equal to</para>
					<para><varname>{base,torder} #&gt;= {base,torder}: tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text #&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1>
		<title>Bounding Box Operators</title>

		<para>These operators test whether the bounding boxes of their arguments satisfy the predicate and result in a Boolean value. As stated in <xref linkend="temporal_types" />, the bounding box associated to a temporal type depends on the base type: It is the <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types, the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types, and the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types. Furthermore, as seen in <xref linkend="casting_box_types" />, many PostgreSQL, PostGIS, or MobilityDB types can be cast to the <varname>tbox</varname> and <varname>stbox</varname> types. For example, numeric and span types can be casted to type <varname>tbox</varname>, types <varname>geometry</varname> and <varname>geography</varname> can be casted to type <varname>stbox</varname>, and time types and temporal types can be casted to types <varname>tbox</varname> and <varname>stbox</varname>.</para>

		<para>A first set of operators consider the topological relationships between the bounding boxes. There are five topological operators: overlaps (<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), contained (<varname>&lt;@</varname>), same (<varname>~=</varname>), and adjacent (<varname>-|-</varname>). The arguments of these operators can be a base type, a box, or a temporal type and the operators verify the topological relationship taking into account the value and/or the time dimension depending on the type of the arguments.</para>

		<para>Another set of operators consider the relative position of the bounding boxes. The operators <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname> consider the value dimension for <varname>tint</varname> and <varname>tfloat</varname> types and the X coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider the Y coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider the Z coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, and the operators <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider the time dimension for all temporal types.</para>

		<para>Finally, it is worth noting that the bounding box operators allow to mix 2D/3D geometries but in that case, the computation is only performed on 2D.</para>

		<para>We refer to <xref linkend="box_topo_operators" /> and <xref linkend="box_relpos_operators" /> for the bounding box operators.</para>
	</sect1>

	<sect1>
		<title>Mathematical Functions and Operators</title>

		<itemizedlist>
			<listitem id="tnumber_add">
				<indexterm><primary><varname>+</varname></primary></indexterm>
				<para>Temporal addition</para>
				<para><varname>{number,tnumber} + {number,tnumber}: tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[2@2001-01-01, 2@2001-01-04)' + 1.5;
-- [3.5@2001-01-01, 3.5@2001-01-04)
SELECT tint '[2@2001-01-01, 2@2001-01-04)' + tfloat '[1@2001-01-01, 4@2001-01-04)';
-- [3@2001-01-01, 6@2001-01-04)
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' +
  tfloat '{[1@2001-01-01, 2@2001-01-02), [1@2001-01-02, 2@2001-01-04)}';
-- {[2@2001-01-01, 4@2001-01-04), [3@2001-01-02, 6@2001-01-04)}
</programlisting>
			</listitem>

			<listitem id="tnumber_sub">
				<indexterm><primary><varname>-</varname></primary></indexterm>
				<para>Temporal subtraction</para>
				<para><varname>{number,tnumber} - {number,tnumber}: tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' - tint '[2@2001-01-03, 2@2001-01-05)';
-- [-1@2001-01-03, -1@2001-01-04)
SELECT tfloat '[3@2001-01-01, 6@2001-01-04)' - tint '[2@2001-01-01, 2@2001-01-04)';
-- [1@2001-01-01, 4@2001-01-04)
</programlisting>
			</listitem>

			<listitem id="tnumber_mult">
				<indexterm><primary><varname>*</varname></primary></indexterm>
				<para>Temporal multiplication</para>
				<para><varname>{number,tnumber} * {number,tnumber}: tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' * 2;
-- [2@2001-01-01, 8@2001-01-04)
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' * tint '[2@2001-01-01, 2@2001-01-04)';
-- [2@2001-01-01, 8@2001-01-04)
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' * '[3@2001-01-01, 1@2001-01-03)'
-- {[3@2001-01-01, 4@2001-01-02, 3@2001-01-03)}
</programlisting>
			</listitem>

			<listitem id="tnumber_div">
				<indexterm><primary><varname>/</varname></primary></indexterm>
				<para>Temporal division</para>
				<para><varname>{number,tnumber} / {number,tnumber}: tnumber</varname></para>
				<para>The function will raise an error if the denominator will ever be equal to zero during the common timespan of the arguments.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT 2 / tfloat '[1@2001-01-01, 3@2001-01-04)';
-- [2@2001-01-01, 1@2001-01-02 12:00:00+00, 0.666666666666667@2001-01-04)
SELECT tfloat '[1@2001-01-01, 5@2001-01-05)' / '[5@2001-01-01, 1@2001-01-05)'
-- {[0.2@2001-01-01, 1@2001-01-03,2001-01-03, 5@2001-01-03,2001-01-05)}
SELECT 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'
-- ERROR:  Division by zero
SELECT tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'
-- [-2@2000-01-04, 1@2000-01-05]
</programlisting>
			</listitem>

			<listitem id="round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Round the values to a number of decimal places</para>
				<para><varname>round(tfloat,integer): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);
-- [0.79@2000-01-01, 2.36@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="degrees">
				<indexterm><primary><varname>degrees</varname></primary></indexterm>
				<para>Convert from radians to degrees</para>
				<para><varname>degrees(tfloat): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');
-- [45@2000-01-01, 135@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="derivative">
				<indexterm><primary><varname>derivative</varname></primary></indexterm>
				<para>Get the derivative over time of the temporal float in units per second</para>
				<para><varname>derivative(tfloat): tfloat</varname></para>
				<para>The temporal float must have linear interpolation</para>
				<programlisting language="sql" xml:space="preserve">
SELECT derivative(tfloat '{[0@2000-01-01, 10@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 0@2000-01-05]}') * 3600 * 24;
/* Interp=Stepwise;{[-10@2000-01-01, 5@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 1@2000-01-05]} */
SELECT derivative(tfloat 'Interp=Stepwise;[0@2000-01-01, 10@2000-01-02, 5@2000-01-03]');
-- ERROR:  The temporal value must have linear interpolation
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Boolean Operators</title>
		<itemizedlist>
			<listitem id="tbool_and">
				<indexterm><primary><varname>&amp;</varname></primary></indexterm>
				<para>Temporal and</para>
				<para><varname>{boolean,tbool} &amp; {boolean,tbool}: tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-03, true@2001-01-05)' &amp;
  tbool '[false@2001-01-03, false@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
SELECT tbool '[true@2001-01-03, true@2001-01-05)' &amp;
  tbool '{[false@2001-01-03, false@2001-01-04),
  [true@2001-01-04, true@2001-01-05)}';
-- {[f@2001-01-03, t@2001-01-04, t@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="tbool_or">
				<indexterm><primary><varname>|</varname></primary></indexterm>
				<para>Temporal or</para>
				<para><varname>{boolean,tbool} | {boolean,tbool}: tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-03, true@2001-01-05)' |
  tbool '[false@2001-01-03, false@2001-01-05)';
-- [t@2001-01-03, t@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="tbool_not">
				<indexterm><primary><varname>~</varname></primary></indexterm>
				<para>Temporal not</para>
				<para><varname>~tbool: tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ~tbool '[true@2001-01-03, true@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Text Functions and Operators</title>

		<itemizedlist>
			<listitem id="ttext_concat">
				<indexterm><primary><varname>||</varname></primary></indexterm>
				<para>Temporal text concatenation</para>
				<para><varname>{text,ttext} || {text,ttext}: ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ttext '[AA@2001-01-01, AA@2001-01-04)' || text 'B';
-- ["AAB"@2001-01-01, "AAB"@2001-01-04)
SELECT ttext '[AA@2001-01-01, AA@2001-01-04)' || ttext '[BB@2001-01-02, BB@2001-01-05)';
-- ["AABB"@2001-01-02, "AABB"@2001-01-04)
SELECT ttext '[A@2001-01-01, B@2001-01-03, C@2001-01-04]' ||
  ttext '{[D@2001-01-01, D@2001-01-02), [E@2001-01-02, E@2001-01-04)}';
-- {["DA"@2001-01-01, "EA"@2001-01-02, "EB"@2001-01-03, "EB"@2001-01-04)}
</programlisting>
			</listitem>

			<listitem id="ttext_upper">
				<indexterm><primary><varname>upper</varname></primary></indexterm>
				<para>Transform to uppercase</para>
				<para><varname>upper(ttext): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- ["AA"@2000-01-01, "BB"@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="ttext_lower">
				<indexterm><primary><varname>lower</varname></primary></indexterm>
				<para>Transform to lowercase</para>
				<para><varname>lower(ttext): ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- ["aa"@2000-01-01, "bb"@2000-01-02]
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	&spatial_functions;

	<sect1>
		<title>Similarity Functions</title>
		<itemizedlist>
			<listitem id="frechetDistance">
				<indexterm><primary><varname>frechetDistance</varname></primary></indexterm>
				<para>Get the discrete <ulink url="https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance">Frchet distance</ulink> between two temporal values &Z_support; &geography_support;</para>
				<para><varname>frechetDistance({tnumber, tgeo}, {tnumber, tgeo}): float</varname></para>
				<para>This function has a linear space complexity since only two rows of the distance matrix are allocated in memory. Nevertheless, its time complexity is quadratic in the number of instants of the temporal values. Therefore, the function will require considerable time for temporal values with large number of instants.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistance(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 0.5
SELECT round(frechetDistance(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 1.414214
</programlisting>
			</listitem>

			<listitem id="frechetDistancePath">
				<indexterm><primary><varname>frechetDistancePath</varname></primary></indexterm>
				<para>Get the correspondences between two temporal values with respect to the discrete Frchet distance &Z_support; &geography_support; &SRF;</para>
				<para><varname>frechetDistancePath({tnumber, tgeo}, {tnumber, tgeo}): pairs</varname></para>
				<para>This function requires to allocate in memory a distance matrix whose size is quadratic in the number of instants of the temporal values. Therefore, the function will fail for temporal values with large number of instants depending on the available memory.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistancePath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT frechetDistancePath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarp">
				<indexterm><primary><varname>dynamicTimeWarp</varname></primary></indexterm>
				<para>Get the <ulink url="https://en.wikipedia.org/wiki/Dynamic_time_warping">Dynamic Time Warp</ulink> (DTW) distance between two temporal values &Z_support; &geography_support;</para>
				<para><varname>dynamicTimeWarp({tnumber, tgeo}, {tnumber, tgeo}): float</varname></para>
				<para>This function has a linear space complexity since only two rows of the distance matrix are allocated in memory. Nevertheless, its time complexity is quadratic in the number of instants of the temporal values. Therefore, the function will require considerable time for temporal values with large number of instants.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarp(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 2
SELECT round(dynamicTimeWarp(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 3.380776
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarpPath">
				<indexterm><primary><varname>dynamicTimeWarpPath</varname></primary></indexterm>
				<para>Get the correspondences between two temporal values with respect to the discrete Frchet distance &Z_support; &geography_support; &SRF;</para>
				<para><varname>dynamicTimeWarpPath({tnumber, tgeo}, {tnumber, tgeo}): pairs</varname></para>
				<para>This function requires to allocate a distance matrix which is quadratic in the size of the number of instants of the temporal values. Therefore, memory allocation will fail for temporal values with large number of instants.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarpPath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT dynamicTimeWarpPath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Multidimensional Tiling</title>
		<para>Multidimensional tiling is the mechanism used to partition the domain of temporal values in buckets or tiles of varying number of dimensions. In the case of a single dimension, the domain can be partitioned by value or by time using buckets of the same size or duration, respectively. For temporal numbers, the domain can be partitioned in two-dimensional tiles of the same size for the value dimension and the same duration for the time dimension. For temporal points, the domain can be partitioned in space in two- or three-dimensional tiles, depending on the number of dimensions of the spatial coordinates. Finally, for temporal points, the domain can be partitioned in space and time using three- or four-dimensional tiles. Furthermore, the temporal values can also be fragmented according to a multidimensional grid defined over the underlying domain.</para>

		<para>Multidimensional tiling can be used for various purposes. For example, it can be used for computing multidimensional histograms, where the temporal values are aggregated according to the underlying partition of the domain. On the other hand, multidimensional tiling can be used for distributing a dataset across a cluster of servers, where each server contains a partition of the dataset. The advantage of this partition mechanism is that it preserves proximitity in space and time, unlike the traditional hash-based partition mechanisms used in big data environments.</para>

		<figure id="tiling" float="start">
			<title>Multidimensional tiling for temporal floats.</title>
			<mediaobject>
				<imageobject><imagedata format="PDF" scale='75' fileref="images/tiling.pdf"/></imageobject>
				<imageobject><imagedata format="SVG" scale='75' fileref="images/tiling.svg"/></imageobject>
				<imageobject><imagedata format="PNG" scale='75' fileref="images/tiling.png"/></imageobject>
			</mediaobject>
		</figure>

		<para>
			<xref linkend="tiling" /> illustrates multidimensional tiling for temporal floats. The two-dimensional domain is split into tiles having the same size for the value dimension and the same duration for the time dimension. Suppose that this tiling scheme is used for distribute a dataset across a cluster of six servers, as suggested by the gray pattern in the figure. In this case, the values are fragmented so each server will receive the data of contiguous tiles. This implies in particular that four nodes will receive one fragment of the temporal float depicted in the figure. One advantage of this distribution of data based on multidimensional tiling is that it reduces the data that needs to be exchanged between nodes when processing queries, a process typically referred to as <emphasis>reshuffling</emphasis>.
		</para>

		<para>Many of the functions in this section are <emphasis>set-returning functions</emphasis> (also known as a <emphasis>table functions</emphasis>) since they typically return more than one value. In this case, the functions are marked with the &SRF; symbol.</para>

		<sect2 id="bucket_functions">
			<title>Bucket Functions</title>

			<itemizedlist>
				<listitem id="bucketList">
					<indexterm><primary><varname>bucketList</varname></primary></indexterm>
					<para>Returns a set of couples (index, bucket) that cover the span or period with buckets of the same size or duration aligned with the origin. &SRF;</para>
					<para>If the origin is not specified, it is set by default to 0 for spans and Monday, January 3, 2000 for periods. The indices start by 1.</para>
					<para><varname>bucketList(bounds span,size number,origin number=0): setof index_span</varname></para>
					<para><varname>bucketList(bounds period,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  setof index_period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(tint '[15@2000-01-01, 25@2000-01-10]'::intspan, 2) AS bl) t;
-- 1 | [14,16)
-- 2 | [16,18)
-- 3 | [18,20)
-- ...
SELECT bucketList(tfloat '[-1@2000-01-01, -10@2000-01-10]'::floatspan, 2, -7);
-- (1,"[-11,-9)")
-- (2,"[-9,-7)")
-- (3,"[-7,-5)")
-- ...
SELECT (bl).index, (bl).period
FROM (SELECT bucketList(tfloat '[1@2000-01-15, 10@2000-01-25]'::period,'2 days') AS bl) t;
-- 1 | [2000-01-15, 2000-01-17)
-- 2 | [2000-01-17, 2000-01-19)
-- 3 | [2000-01-19, 2000-01-21)
-- ...
SELECT bucketList(tfloat '[1@2000-01-15, 10@2000-01-25]'::period, '2 days', '2000-01-02');
-- (1,"[2000-01-14, 2000-01-16)")
-- (2,"[2000-01-16, 2000-01-18)")
-- (3,"[2000-01-18, 2000-01-20)")
-- ...
</programlisting>
				</listitem>

				<listitem id="valueBucket">
					<indexterm><primary><varname>valueBucket</varname></primary></indexterm>
					<para> Returns the start value of the bucket that contains the input number.</para>
					<para>If the origin is not specified, it is set by default to 0.</para>
					<para><varname>valueBucket(value number,size number,origin number=0): number</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT valueBucket(3, 2);
-- 2
SELECT valueBucket(3.5, 2.5, 1.5);
-- 1.5
</programlisting>
				</listitem>

				<listitem id="spanBucket">
					<indexterm><primary><varname>spanBucket</varname></primary></indexterm>
					<para>Returns the span in the bucket space that contains the input number.</para>
					<para>If the origin is not specified, it is set by default to 0.</para>
					<para><varname>spanBucket(value number,size number,origin number=0): span</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT spanBucket(2, 2);
-- [2,4)
SELECT spanBucket(2, 2, 1);
-- [1,3)
SELECT spanBucket(2, 2.5);
-- [0,2.5)
SELECT spanBucket(2, 2.5, 1.5);
-- [1.5,4)
</programlisting>
				</listitem>

				<listitem id="timeBucket">
					<indexterm><primary><varname>timeBucket</varname></primary></indexterm>
					<para>Returns the start timestamp of the bucket that contains the input timestamp.</para>
					<para>If the origin is not specified, it is set by default to Monday, January 3, 2000.</para>
					<para><varname>timeBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  timestamptz</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days');
-- 2020-04-29 01:00:00+02
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days', timestamptz '2020-01-01');
-- 2020-04-30 01:00:00+02
</programlisting>
				</listitem>

				<listitem id="periodBucket">
					<indexterm><primary><varname>periodBucket</varname></primary></indexterm>
					<para>Returns the period in the bucket space that contains the input timestamp.</para>
					<para>If the origin is not specified, it is set by default to Monday, January 3, 2000.</para>
					<para><varname>periodBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodBucket('2000-01-04', interval '1 week');
-- [2000-01-03, 2000-01-10)
SELECT periodBucket('2000-01-04', interval '1 week', '2000-01-07');
-- [1999-12-31, 2000-01-07)
</programlisting>
				</listitem>

			</itemizedlist>
		</sect2>

		<sect2 id="grid_functions">
			<title>Grid Functions</title>

			<itemizedlist>
				<listitem id="multidimGrid">
					<indexterm><primary><varname>multidimGrid</varname></primary></indexterm>
					<para>Returns a set of couples (index, tile) that covers the box with multidimensional tiles of the same size and duration. &Z_support; &SRF;</para>
					<para>If the origin of the value and/or time dimensions are not specified, they are set by default to 0 or <varname>'Point(0 0 0)'</varname> for the value dimension (depending on the box type) and to Monday, January 3, 2000 for the time dimension.</para>
					<para><varname>multidimGrid(bounds tbox,size float,duration interval,vorigin float=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03'): setof index_box</varname></para>
					<para><varname>multidimGrid(bounds stbox,size float,sorigin geometry='Point(0 0 0)'):</varname></para>
					<para><varname>  setof index_box</varname></para>
					<para><varname>multidimGrid(bounds stbox,size float,duration interval,sorigin geometry='Point(0 0 0)',</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03'): setof index_box</varname></para>
					<para>In the case of a spatiotemporal grid, the SRID of the tile coordinates is determined by the input box and the size is given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (gr).index, (gr).box
FROM (SELECT multidimGrid(tfloat '[15@2000-01-15, 25@2000-01-25]'::tbox, 2.0, '2 days')
  AS gr) t;
-- 1 | TBOX XT([14,16),[2000-01-15,2000-01-17))
-- 2 | TBOX XT([16,18),[2000-01-15,2000-01-17))
-- 3 | TBOX XT([18,20),[2000-01-15,2000-01-17))
-- ...
SELECT multidimGrid(tfloat '[15@2000-01-15,25@2000-01-25]'::tbox, 2.0, '2 days', 11.5);
-- (1,"TBOX XT([13.5,15.5),[2000-01-15,2000-01-17))")
-- (2,"TBOX XT([15.5,17.5),[2000-01-15,2000-01-17))")
-- (3,"TBOX XT([17.5,19.5),[2000-01-15,2000-01-17))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0); 
-- (1,"STBOX X(((2,2),(4,4)))")
-- (2,"STBOX X(((4,2),(6,4)))")
-- (3,"STBOX X(((6,2),(8,4)))")
-- ...
SELECT multidimGrid(tgeompoint 'SRID=3812;[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3)');
-- (1,"SRID=3812;STBOX X(((3,3),(5,5)))")
-- (2,"SRID=3812;STBOX X(((5,3),(7,5)))")
-- (3,"SRID=3812;STBOX X(((7,3),(9,5)))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3 3)');
-- (1,"STBOX Z(((3,3,3),(5,5,5))")
-- (2,"STBOX Z(((5,3,3),(7,5,5))")
-- (3,"STBOX Z(((7,3,3),(9,5,5))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, interval '2 days');
-- (1,"STBOX XT(((2,2),(4,4)),[2000-01-15,2000-01-17))")
-- (2,"STBOX XT(((4,2),(6,4)),[2000-01-15,2000-01-17))")
-- (3,"STBOX XT(((6,2),(8,4)),[2000-01-15,2000-01-17))")
-- ...
SELECT multidimGrid(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, '2 days', 'Point(3 3 3)', '2000-01-15');
-- (1,"STBOX ZT(((3,3,3),(5,5,5)),[2000-01-15,2000-01-17))")
-- (2,"STBOX ZT(((5,3,3),(7,5,5))),[2000-01-15,2000-01-17)")
-- (3,"STBOX ZT(((7,3,3),(9,5,5))),[2000-01-15,2000-01-17)")
-- ...
</programlisting>
				</listitem>

				<listitem id="multidimTile">
					<indexterm><primary><varname>multidimTile</varname></primary></indexterm>
					<para>Returns the tile of the multidimensional grid that contains the value and the timestamp. &Z_support;</para>
					<para>If the origin of the value and/or time dimensions are not specified, they are set by default to 0 or <varname>Point(0 0 0)</varname> for the value dimension and Monday, January 3, 2000 for the time dimension, respectively.</para>
					<para><varname>multidimTile(value float,time timestamptz,size float,duration interval,</varname></para>
					<para><varname>  vorigin float=0.0,torigin timestamptz='2000-01-03'): tbox</varname></para>
					<para><varname>multidimTile(point geometry,size float,sorigin geometry='Point(0 0 0)'): stbox</varname></para>
					<para><varname>multidimTile(point geometry,time timestamptz,size float,duration interval,sorigin</varname></para>
					<para><varname>  geometry='Point(0 0 0)',torigin timestamptz='2000-01-03'): stbox</varname></para>
					<para>In the case of a spatiotemporal grid, the SRID of the tile coordinates is determined by the input point and the size is given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT multidimTile(15, '2000-01-15', 2, interval '2 days');
-- TBOX XT([14,16),[2000-01-15,2000-01-17))
SELECT multidimTile(15, '2000-01-15', 2, interval '2 days', 1, '2000-01-02');
-- TBOX XT([15,17),[2000-01-14,2000-01-16))
SELECT multidimTile(geometry 'Point(1 1 1)', 2.0);
-- STBOX Z(((0,0,0),(2,2,2)))
SELECT multidimTile(geometry 'Point(1 1)', '2000-01-01', 2.0, interval '2 days');
-- STBOX XT(((0,0),(2,2)),[2000-01-01, 2000-01-03))
SELECT multidimTile(geometry 'Point(1 1)', '2000-01-01', 2.0, '2 days', 'Point(1 1)',
  '2000-01-02');
-- STBOX XT(((1,1),(3,3)),[1999-12-31, 2000-01-02))
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="split_functions">
			<title>Split Functions</title>
			<para>These functions fragment a temporal value with respect to a sequence of buckets (see <xref linkend="bucket_functions" />) or a multidimensional grid (see <xref linkend="grid_functions" />).</para>
			<itemizedlist>
				<listitem id="valueSplit">
					<indexterm><primary><varname>valueSplit</varname></primary></indexterm>
					<para>Fragment the temporal number with respect to span buckets. &SRF;</para>
					<para><varname>valueSplit(value tnumber,size number,origin number=0): setof number_tnumber</varname></para>
					<para>If the origin of values is not specified, it is set by default to 0.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).tnumber
FROM (SELECT valueSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05, 10@2001-01-10]',
  2) AS sp) t;
--  0 | {[1@2001-01-01 00:00:00+01, 1@2001-01-02 00:00:00+01)}
--  2 | {[2@2001-01-02 00:00:00+01, 2@2001-01-05 00:00:00+01)}
--  4 | {[5@2001-01-05 00:00:00+01, 5@2001-01-10 00:00:00+01)}
-- 10 | {[10@2001-01-10 00:00:00+01]}
SELECT valueSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 2.0, 1.0);
-- (1,"{[1@2001-01-01 00:00:00+01, 3@2001-01-03 00:00:00+01)}")
-- (3,"{[3@2001-01-03 00:00:00+01, 5@2001-01-05 00:00:00+01)}")
-- (5,"{[5@2001-01-05 00:00:00+01, 7@2001-01-07 00:00:00+01)}")
-- (7,"{[7@2001-01-07 00:00:00+01, 9@2001-01-09 00:00:00+01)}")
-- (9,"{[9@2001-01-09 00:00:00+01, 10@2001-01-10 00:00:00+01)}")
</programlisting>
				</listitem>

				<listitem id="timeSplit">
					<indexterm><primary><varname>timeSplit</varname></primary></indexterm>
					<para>Fragment the temporal value with respect to time buckets. &Z_support; &SRF;</para>
					<para><varname>timeSplit(value ttype,duration interval,origin timestamptz='2000-01-03'):</varname></para>
					<para><varname>  setof time_temp</varname></para>
					<para>If the origin of time is not specified, it is set by default to Monday, January 3, 2000.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time, (ts).temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', '2 days') AS ts) t;
-- 2011-12-31 | [1@2001-01-01, 2@2001-01-02)
-- 2001-01-02 | [2@2001-01-02, 4@2001-01-04)
-- 2001-01-04 | [4@2001-01-04, 6@2001-01-06)
-- ...
SELECT (ts).time, astext((ts).temp) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-10]',
  '2 days', '2001-01-01') AS ts) AS t;
-- 2001-01-01 | [POINT Z (1 1 1)@2001-01-01, POINT Z (3 3 3)@2001-01-03)
-- 2001-01-03 | [POINT Z (3 3 3)@2001-01-03, POINT Z (5 5 5)@2001-01-05)
-- 2001-01-05 | [POINT Z (5 5 5)@2001-01-05, POINT Z (7 7 7)@2001-01-07)
-- ...
</programlisting>
					<para>Notice that we can fragment a temporal value in cyclic (instead of linear) time buckets. The following two examples show how to fragment a temporal value by hour and by day of the week.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time::time as hour, merge((ts).temp) as temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-03]', '1 hour') AS ts) t
GROUP BY hour ORDER BY hour;
/* 00:00:00 | {[1@2001-01-01 00:00:00+01, 1.1875@2001-01-01 01:00:00+01),
               [5.5@2001-01-02 00:00:00+01, 5.6875@2001-01-02 01:00:00+01)} */
/* 01:00:00 | {[1.1875@2001-01-01 01:00:00+01, 1.375@2001-01-01 02:00:00+01),
               [5.6875@2001-01-02 01:00:00+01, 5.875@2001-01-02 02:00:00+01)} */
/* 02:00:00 | {[1.375@2001-01-01 02:00:00+01, 1.5625@2001-01-01 03:00:00+01),
               [5.875@2001-01-02 02:00:00+01, 6.0625@2001-01-02 03:00:00+01)} */
/* 03:00:00 | {[1.5625@2001-01-01 03:00:00+01, 1.75@2001-01-01 04:00:00+01),
               [6.0625@2001-01-02 03:00:00+01, 6.25@2001-01-02 04:00:00+01)} */
/* ...  */
SELECT EXTRACT(DOW FROM (ts).time) as dow_no, TO_CHAR((ts).time, 'Dy') as dow,
  asText(round(merge((ts).temp), 2)) as temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-14)',
  '1 hour') AS ts) t
GROUP BY dow, dow_no ORDER BY dow_no;
/* 0 | Sun | {[POINT(1 1)@2001-01-01, POINT(1.69 1.69)@2001-01-02),
             [POINT(5.85 5.85)@2001-01-08, POINT(6.54 6.54)@2001-01-09)} */
/* 1 | Mon | {[POINT(1.69 1.69)@2001-01-02, POINT(2.38 2.38)@2001-01-03),
             [POINT(6.54 6.54)@2001-01-09, POINT(7.23 7.23)@2001-01-10)} */
/* 2 | Tue | {[POINT(2.38 2.38)@2001-01-03, POINT(3.08 3.08)@2001-01-04),
             [POINT(7.23 7.23)@2001-01-10, POINT(7.92 7.92)@2001-01-11)} */
/* ... */
</programlisting>
				</listitem>

				<listitem id="valueTimeSplit">
					<indexterm><primary><varname>valueTimeSplit</varname></primary></indexterm>
					<para>Fragment the temporal number with respect to the tiles in a value-time grid. &SRF;</para>
					<para><varname>valueTimeSplit(value tumber,size number,duration interval,vorigin number=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03'): setof number_time_tnumber</varname></para>
					<para>If the origin of values and/or time are not specified, they are set by default to 0 and to Monday, January 3, 2000, respectively.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05,
  10@2001-01-10]', 5, '5 days') AS sp) t;
--  0 | 2011-12-31 | [1@2001-01-01, 2@2001-01-02, 2@2001-01-05)
--  5 | 2001-01-05 | [5@2001-01-05, 5@2001-01-10)
-- 10 | 2001-01-10 | [10@2001-01-10]
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 5.0, '5 days', 1.0,
  '2001-01-01') AS sp) t;
-- 1 | 2001-01-01 | [1@2001-01-01, 6@2001-01-06)
-- 6 | 2001-01-06 | [6@2001-01-06, 10@2001-01-10)
</programlisting>
				</listitem>

				<listitem id="spaceSplit">
					<indexterm><primary><varname>spaceSplit</varname></primary></indexterm>
					<para>Fragment the temporal point with respect to the tiles in a spatial grid. &Z_support; &SRF;</para>
					<para><varname>spaceSplit(value tgeompoint,size float,origin geometry='Point(0 0 0)',</varname></para>
					<para><varname>  bitmatrix=true): setof point_tpoint</varname></para>
					<para>If the origin of the space dimension is not specified, it is set by default to <varname>'Point(0 0 0)'</varname>. If the argument <varname>bitmatrix</varname> is not specified, then the computation will use a bit matrix to speed up the process.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0) AS sp) t;
-- POINT(0 0) | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | {[POINT(2 2)@2020-03-02, POINT(4 4)@2020-03-04)}
-- POINT(4 4) | {[POINT(4 4)@2020-03-04, POINT(6 6)@2020-03-06)}
-- ...
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, 'Point(1 1 1)') AS sp) t;
-- POINT Z (1 1 1) | {[POINT Z (1 1 1)@2020-03-01, POINT Z (3 3 3)@2020-03-03)}
-- POINT Z (3 3 3) | {[POINT Z (3 3 3)@2020-03-03, POINT Z (5 5 5)@2020-03-05)}
-- POINT Z (5 5 5) | {[POINT Z (5 5 5)@2020-03-05, POINT Z (7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
				<listitem id="spaceTimeSplit">
					<indexterm><primary><varname>spaceTimeSplit</varname></primary></indexterm>
					<para>Fragment the temporal point with respect to the tiles in a spatiotemporal grid. &Z_support; &SRF;</para>
					<para><varname>spaceTimeSplit(value tgeompoint,size float,duration interval,sorigin </varname></para>
					<para><varname>  geometry='Point(0 0 0)',torigin timestamptz='2000-01-03', bitmatrix=true):</varname></para>
					<para><varname>  setof point_time_tpoint</varname></para>
					<para>If the origin of the space and time dimensions are not specified, they are set by default to <varname>'Point(0 0 0)'</varname> and Monday, January 3, 2000, respectively. If the argument <varname>bitmatrix</varname> is not specified, then the computation will use a bit matrix to speed up the process.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0, '2 days') AS sp) t;
-- POINT(0 0) | 2020-03-01 | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | 2020-03-01 | {[POINT(2 2)@2020-03-02, POINT(3 3)@2020-03-03]}
-- POINT(2 2) | 2020-03-03 | {[POINT(3 3)@2020-03-03, POINT(4 4)@2020-03-04)}
-- ...
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, '2 days', 'Point(1 1 1)', '2020-03-01') AS sp) t;
-- POINT Z(1 1 1) | 2020-03-01 | {[POINT Z(1 1 1)@2020-03-01, POINT Z(3 3 3)@2020-03-03)}
-- POINT Z(3 3 3) | 2020-03-03 | {[POINT Z(3 3 3)@2020-03-03, POINT Z(5 5 5)@2020-03-05)}
-- POINT Z(5 5 5) | 2020-03-05 | {[POINT Z(5 5 5)@2020-03-05, POINT Z(7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1>
		<title>Aggregate Functions</title>

		<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant in the <emphasis>union</emphasis> of the temporal extents of the values to aggregate. In contrast, recall that all other functions manipulating temporal types compute the value of the function at every instant in the <emphasis>intersection</emphasis> of the temporal extents of the arguments.</para>

		<para>The temporal aggregate functions are the following ones:</para>
		<itemizedlist>
			<listitem><para>For all temporal types, the function <varname>tcount</varname> generalize the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available objects (for example, number of cars in an area).</para></listitem>
			<listitem><para>For all temporal types, function <varname>extent</varname> returns a bounding box that encloses a set of temporal values. Depending on the base type, the result of this function can be a <varname>period</varname>, a <varname>tbox</varname> or an <varname>stbox</varname>.</para></listitem>
			<listitem><para>For the temporal Boolean type, the functions <varname>tand</varname> and <varname>tor</varname> generalize the traditional functions <varname>and</varname> and <varname>or</varname>.</para></listitem>
			<listitem><para>For temporal numeric types, there are two types of temporal aggregate functions. The functions <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname>, and <varname>tavg</varname> generalize the traditional functions <varname>min</varname>, <varname>max</varname>, <varname>sum</varname>, and <varname>avg</varname>. Furthermore, the functions <varname>wmin</varname>, <varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname>, and <varname>wavg</varname> are window (or cumulative) versions of the traditional functions that, given a time interval w, compute the value of the function at an instant t by considering the values during the interval [t-w, t]. All window aggregate functions are available for temporal integers, while for temporal floats only window minimum and maximum are meaningful.</para></listitem>
			<listitem><para>For the temporal text type, the functions <varname>tmin</varname> y <varname>tmax</varname> generalize the traditional functions <varname>min</varname> and <varname>max</varname>.</para></listitem>
			<listitem><para>Finally, for temporal point types, the function <varname>tcentroid</varname> generalizes the function <varname>ST_Centroid</varname> provided by PostGIS. For example, given set of objects that move together (that is, a convoy or a flock) the temporal centroid will produce a temporal point that represents at each instant the geometric center (or the center of mass) of all the moving objects.</para></listitem>
		</itemizedlist>

		<para>In the examples that follow, we suppose the tables <varname>Department</varname> and <varname>Trip</varname> contain the two tuples introduced in <xref linkend="examples_temporal_types" />.</para>
		<itemizedlist>
			<listitem id="tcount">
				<indexterm><primary><varname>tcount</varname></primary></indexterm>
				<para>Temporal count</para>
				<para><varname>tcount(ttype): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcount(NoEmps) FROM Department;
-- {[1@2001-01-01, 2@2001-02-01, 1@2001-08-01, 1@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="extent">
				<indexterm><primary><varname>extent</varname></primary></indexterm>
				<para>Bounding box extent</para>
				<para><varname>extent(temp): {period,tbox,stbox}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT extent(noEmps) FROM Department;
-- TBOX XT((4,12),[2001-01-01,2001-10-01])
SELECT extent(Trip) FROM Trips;
-- STBOX XT(((0,0),(3,3)),[2001-01-01 08:00:00+01, 2001-01-01 08:20:00+01))
</programlisting>
			</listitem>

			<listitem id="tand">
				<indexterm><primary><varname>tand</varname></primary></indexterm>
				<para>Temporal and</para>
				<para><varname>tand(tbool): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tand(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-04-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tor">
				<indexterm><primary><varname>tor</varname></primary></indexterm>
				<para>Temporal or</para>
				<para><varname>tor(tbool): tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tor(NoEmps #&gt; 6) FROM Department;
-- {[t@2001-01-01, f@2001-08-01, f@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmin">
				<indexterm><primary><varname>tmin</varname></primary></indexterm>
				<para>Temporal minimum</para>
				<para><varname>tmin(ttype): {ttype_seq,ttype_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmin(NoEmps) FROM Department;
-- {[10@2001-01-01, 4@2001-02-01, 6@2001-06-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tmax">
				<indexterm><primary><varname>tmax</varname></primary></indexterm>
				<para>Temporal maximum</para>
				<para><varname>tmax(ttype): {ttype_seq,ttype_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tmax(NoEmps) FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-01, 6@2001-10-01)}
</programlisting>
			</listitem>

			<listitem id="tsum">
				<indexterm><primary><varname>tsum</varname></primary></indexterm>
				<para>Temporal sum</para>
				<para><varname>tsum(tnumber): {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tsum(NoEmps) FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 16@2001-04-01, 18@2001-06-01, 6@2001-08-01,
   6@2001-10-01)} */
</programlisting>
			</listitem>

			<listitem id="tavg">
				<indexterm><primary><varname>tavg</varname></primary></indexterm>
				<para>Temporal average</para>
				<para><varname>tavg(tnumber): {tfloat_seq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tavg(NoEmps) FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8@2001-04-01, 8@2001-06-01), [9@2001-06-01, 9@2001-08-01),
   [6@2001-08-01, 6@2001-10-01) */
</programlisting>
			</listitem>

			<listitem id="wmin">
				<indexterm><primary><varname>wmin</varname></primary></indexterm>
				<para>Window minimum</para>
				<para><varname>wmin(tnumber,interval): {tnumber_seq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmin(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 4@2001-04-01, 6@2001-06-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wmax">
				<indexterm><primary><varname>wmax</varname></primary></indexterm>
				<para>Window maximum</para>
				<para><varname>wmax(tnumber,interval): {tnumber_discseq,tnumber_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wmax(NoEmps, interval '2 days') FROM Department;
-- {[10@2001-01-01, 12@2001-04-01, 6@2001-08-03, 6@2001-10-03)}
</programlisting>
			</listitem>

			<listitem id="wcount">
				<indexterm><primary><varname>wcount</varname></primary></indexterm>
				<para>Window count</para>
				<para><varname>wcount(tnumber,interval): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wcount(NoEmps, interval '2 days') FROM Department;
/* {[1@2001-01-01, 2@2001-02-01, 3@2001-04-01, 2@2001-04-03, 3@2001-06-01, 2@2001-06-03,
   1@2001-08-03, 1@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wsum">
				<indexterm><primary><varname>wsum</varname></primary></indexterm>
				<para>Window sum</para>
				<para><varname>wsum(tint,interval): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wsum(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 14@2001-02-01, 26@2001-04-01, 16@2001-04-03, 22@2001-06-01,
   18@2001-06-03, 6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="wavg">
				<indexterm><primary><varname>wavg</varname></primary></indexterm>
				<para>Window average</para>
				<para><varname>wavg(tint,interval): {tfloat_seq,tfloat_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT wavg(NoEmps, interval '2 days') FROM Department;
/* {[10@2001-01-01, 10@2001-02-01), [7@2001-02-01, 7@2001-04-01),
   [8.66666666666667@2001-04-01, 8.66666666666667@2001-04-03),
   [8@2001-04-03, 8@2001-06-01),
   [7.33333333333333@2001-06-01, 7.33333333333333@2001-06-03),
   [9@2001-06-03, 9@2001-08-03), [6@2001-08-03, 6@2001-10-03)} */
</programlisting>
			</listitem>

			<listitem id="tcentroid">
				<indexterm><primary><varname>tcentroid</varname></primary></indexterm>
				<para>Temporal centroid</para>
				<para><varname>tcentroid(tgeompoint): tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tcentroid(Trip) FROM Trips;
/* {[POINT(0 0)@2001-01-01 08:00:00+00, POINT(1 0)@2001-01-01 08:05:00+00),
   [POINT(0.5 0)@2001-01-01 08:05:00+00, POINT(1.5 0.5)@2001-01-01 08:10:00+00,
   POINT(2 1.5)@2001-01-01 08:15:00+00),
   [POINT(2 2)@2001-01-01 08:15:00+00, POINT(3 3)@2001-01-01 08:20:00+00)} */
</programlisting>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1>
		<title>Utility Functions</title>
		<itemizedlist>
			<listitem id="mobilitydb_version">
				<indexterm><primary><varname>mobilitydb_version</varname></primary></indexterm>
				<para>Version of the MobilityDB extension</para>
				<para><varname>mobilitydb_version(): text</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT mobilitydb_version();
-- MobilityDB 1.1
</programlisting>
			</listitem>

			<listitem id="mobilitydb_full_version">
				<indexterm><primary><varname>mobilitydb_full_version</varname></primary></indexterm>
				<para>Versions of the MobilityDB extension and its dependencies</para>
				<para><varname>mobilitydb_full_version(): text</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT mobilitydb_full_version();
-- MobilityDB 1.1.0, PostgreSQL 14.2, PostGIS 3.2.1
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="indexing_temporal_types">
		<title>Indexing of Temporal Types</title>
		<para>GiST and SP-GiST indexes can be created for table columns of temporal types. The GiST index implements an R-tree and the SP-GiST index implements an n-dimensional quad-tree. Examples of index creation are as follows:
			<programlisting language="sql" xml:space="preserve">
CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		</para>

		<para>The GiST and SP-GiST indexes store the bounding box for the temporal types. As explained in <xref linkend="temporal_types" />, these are
			<itemizedlist>
				<listitem>
					<para>the period <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>A GiST or SP-GiST index can accelerate queries involving the following operators (see <xref linkend="operators_temporal_types" /> for more information):
			<itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, which only consider the value dimension in temporal alphanumeric types,</para>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, and <varname>/&amp;&gt;</varname>, which only consider the spatial dimension in temporal point types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, which only consider the time dimension for all temporal types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, and <varname>|=|</varname>, which consider as many dimensions as they are shared by the indexed column and the query argument. These operators work on bounding boxes (that is, <varname>period</varname>, <varname>tbox</varname>, or <varname>stbox</varname>), not the entire values.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>For example, given the index defined above on the <varname>Department</varname> table and a query that involves a condition with the <varname>&amp;&amp;</varname> (overlaps) operator, if the right argument is a temporal float then both the value and the time dimensions are considered for filtering the tuples of the relation, while if the right argument is a float value, a float span, or a time type, then either the value or the time dimension will be used for filtering the tuples of the relation. Furthermore, a bounding box can be constructed from a value/span and/or a timestamp/period, which can be used for filtering the tuples of the relation. Examples of queries using the index on the <varname>Department</varname> table defined above are given next.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;
SELECT * FROM Department WHERE NoEmps &amp;&amp; intspan '[1, 5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2001-04-01';
SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2001-04-01, 2001-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tbox(intspan '[1, 5)', period '[2001-04-01, 2001-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;
  tfloat '{[1@2001-01-01, 1@2001-02-01), [5@2001-04-01, 5@2001-05-01)}';
</programlisting>
		</para>

		<para>Similarly, examples of queries using the index on the <varname>Trips</varname> table defined above are given next.
			<programlisting language="sql" xml:space="preserve">
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;
  stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;
  tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
</programlisting>
		</para>

		<para>Finally, B-tree indexes can be created for table columns of all temporal types. For this index type, the only useful operation is equality. There is a B-tree sort ordering defined for values of temporal types, with corresponding <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname>, <varname>&gt;=</varname> and operators, but the ordering is rather arbitrary and not usually useful in the real world. B-tree support for temporal types is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>

		<para>In order to speed up several of the functions in <xref linkend="manipulating_temporal_types" />, we can add in the <varname>WHERE</varname> clause of queries a bounding box comparison that make uses of the available indexes. For example, this would be typically the case for the functions that project the temporal types to the value/spatial and/or time dimensions. This will filter out the tuples with an index as shown in the following query.
			<programlisting language="sql" xml:space="preserve">
SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))
FROM Trips T
-- Bouding box index filtering
WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)
</programlisting>
		</para>

		<para>In the case of temporal points, all spatial relationships with the possible semantics (see <xref linkend="spatial_relationships_temporal_points" />) automatically include a bounding box comparison that will make use of any indexes that are available on the temporal points. For this reason, the first version of the relationships is typically used for filtering the tuples with the help of an index when computing the temporal relationships as shown in the following query.
			<programlisting language="sql" xml:space="preserve">
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Bouding box index filtering
WHERE intersects(T.Trip, R.Geom);
</programlisting>
		</para>
	</sect1>

	<sect1 id="statistics_temporal_types">
		<title>Statistics and Selectivity for Temporal Types</title>
		<sect2>
			<title>Statistics Collection</title>
			<para>The PostgreSQL planner relies on statistical information about the contents of tables in order to generate the most efficient execution plan for queries. These statistics include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. For large tables, a random sample of the table contents is taken, rather than examining every row. This enables large tables to be analyzed in a small amount of time. The statistical information is gathered by the <varname>ANALYZE</varname> command and stored in the <varname>pg_statistic</varname> catalog table. Since different kinds of statistics may be appropriate for different kinds of data, the table only stores very general statistics (such as number of null values) in dedicated columns. Everything else is stored in five &ldquo;slots&rdquo;, which are couples of array columns that store the statistics for a column of an arbitrary type.</para>

			<para>The statistics collected for time types and temporal types are based on those collected by PostgreSQL for scalar types and span types. For scalar types, such as <varname>float</varname>, the following statistics are collected:
				<orderedlist numeration="arabic">
					<listitem>
						<para>fraction of null values,</para>
					</listitem>
					<listitem>
						<para>average width, in bytes, of non-null values,</para>
					</listitem>
					<listitem>
						<para>number of different non-null values,</para>
					</listitem>
					<listitem>
						<para>array of most common values and array of their frequencies,</para>
					</listitem>
					<listitem>
						<para>histogram of values, where the most common values are excluded,</para>
					</listitem>
					<listitem>
						<para>correlation between physical and logical row ordering.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>For range types, like <varname>tstzrange</varname>, three additional histograms are collected:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>length histogram of non-empty ranges,</para>
					</listitem>
					<listitem>
						<para>histograms of lower and upper bounds.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>For geometries, in addition to (1)&#x2013;(3), the following statistics are collected:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>number of dimensions of the values, N-dimensional bounding box, number of rows in the table, number of rows in the sample, number of non-null values,</para>
					</listitem>
					<listitem>
						<para>N-dimensional histogram that divides the bounding box into a number of cells and keeps the proportion of values that intersects with each cell.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>The statistics collected for columns of the time and span types <varname>timestampset</varname>, <varname>period</varname>, <varname>periodset</varname>, <varname>intspan</varname>, and <varname>floatspan</varname> replicate those collected by PostgreSQL for the <varname>tstzrange</varname>. This is clear for the span types in MobilityDB, which are more efficient versions of the range types in PostgreSQL. For the <varname>timestampset</varname> and the <varname>periodset</varname> types, a value is converted into its bounding period, then the statistics for the <varname>period</varname> type are collected.</para>

			<para>The statistics collected for columns of temporal types depend on their subtype and their base type. In addition to statistics (1)&#x2013;(3) that are collected for all temporal types, statistics are collected for the time and the value dimensions independently. More precisely, the following statistics are collected for the time dimension:
				<itemizedlist>
					<listitem>
						<para>For columns of instant subtype, the statistics (4)&#x2013;(6) are collected for the timestamps.</para>
					</listitem>

					<listitem>
						<para>For columns of other subtype, the statistics (7)&#x2013;(8) are collected for the (bounding box) periods.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>The following statistics are collected for the value dimension:
				<itemizedlist>
					<listitem>
						<para>For columns of temporal types with stepwise interpolation (that is, <varname>tbool</varname>, <varname>ttext</varname>, or <varname>tint</varname>):
							<itemizedlist>
								<listitem>
									<para>For the instant subtype, the statistics (4)&#x2013;(6) are collected for the values.</para>
								</listitem>

								<listitem>
									<para>For all other subtypes, the statistics (7)&#x2013;(8) are collected for the values.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>For columns of the temporal float type (that is, <varname>tfloat</varname>):
							<itemizedlist>
								<listitem>
									<para>For the instant subtype, the statistics (4)&#x2013;(6) are collected for the values.</para>
								</listitem>
								<listitem>
									<para>For all other subtype, the statistics (7)&#x2013;(8) are collected for the (bounding) value spans.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>For columns of temporal point types (that is, <varname>tgeompoint</varname> and <varname>tgeogpoint</varname>) the statistics (9)&#x2013;(10) are collected for the points.</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Selectivity Estimation of Operators</title>

			<para>Boolean operators in PostgreSQL can be associated with two selectivity functions, which compute how likely a value of a given type will match a given criterion. These selectivity functions rely on the statistics collected. There are two types of selectivity functions. The <emphasis>restriction</emphasis> selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>column OP constant</varname>. On the other hand, the <emphasis>join</emphasis> selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>table1.column1 OP table2.column2</varname>.</para>

			<para>MobilityDB defines 23 classes of Boolean operators (such as <varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), each of which can have as left or right arguments a PostgreSQL type (such as <varname>integer</varname>, <varname>timestamptz</varname>, etc.) or a MobilityDB type (such as <varname>period</varname>, <varname>tint</varname>, etc.). As a consequence, there is a very high number of operators with different arguments to be considered for the selectivity functions. The approach taken was to group these combinations into classes corresponding to the value and time dimensions. The classes correspond to the type of statistics collected as explained in the previous section.</para>

			<para>MobilityDB estimates both restriction and join selectivity for time, span, and temporal types.</para>
		</sect2>
	</sect1>
</chapter>
