<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="manipulating_temporal_types_p1">
	<title>Manipulating Temporal Types: Part 1</title>
	<para>We present next the functions and operators for temporal types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this, we use the following notation:</para>

	<itemizedlist>
		<listitem>
			<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>tstzspan</varname>, <varname>tstzset</varname>, or <varname>tstzspanset</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>ttype</varname> represents any temporal type,</para>
		</listitem>

		<listitem>
			<para><varname>tdisc</varname> represents any temporal type with a discrete base type, that is, <varname>tbool</varname>, <varname>tint</varname>, or <varname>ttext</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tcont</varname> represents any temporal type with a continuous base type, that is, <varname>tfloat</varname>, <varname>tgeompoint</varname>, or <varname>tgeogpoint</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>torder</varname> represents any temporal type whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tnumber</varname> represents any temporal number type, that is, <varname>tint</varname> or <varname>tfloat</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tpoint</varname> represents a temporal point type, that is, <varname>tgeompoint</varname> or <varname>tgeogpoint</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_inst</varname> represents any temporal type with instant subtype,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_discseq</varname> represents any temporal type with sequence subtype and discrete interpolation,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_contseq</varname> represents any temporal type with sequence subtype and continuous interpolation,</para>
		</listitem>

		<listitem>
			<para><varname>ttype_seqset</varname> represents any temporal type with sequence set subtype,</para>
		</listitem>

		<listitem>
			<para><varname>base</varname> represents any base type of a temporal type, that is, <varname>boolean</varname>, <varname>integer</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname>, or <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>values</varname> represents any set of values of a base type of a temporal type, for example, <varname>integer</varname>, <varname>intset</varname>, <varname>intspan</varname>, and <varname>intspanset</varname> for the base type <varname>integer</varname></para>
		</listitem>

		<listitem>
			<para><varname>number</varname> represents any number base type, that is, <varname>integer</varname> or <varname>float</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>numspan</varname> represents any number span type, that is, either <varname>intspan</varname> or <varname>floatspan</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>geo</varname> represents the types <varname>geometry</varname> or <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>geompoint</varname> represents the type <varname>geometry</varname> restricted to a point.</para>
		</listitem>

		<listitem>
			<para><varname>point</varname> represents the types <varname>geometry</varname> or <varname>geography</varname> restricted to a point.</para>
		</listitem>

		<listitem>
			<para><varname>type[]</varname> represents an array of <varname>type</varname>.</para>
		</listitem>

		<listitem>
			<para><varname>&lt;type&gt;</varname> in the name of a function represents the functions obtained by replacing <varname>&lt;type&gt;</varname> by a specific <varname>type</varname>. For example, <varname>tint_discseq</varname> or <varname>tfloat_discseq</varname> are represented by <varname>&lt;ttype&gt;_discseq</varname>.</para>
		</listitem>
	</itemizedlist>

	<para>
		A common way to generalize the traditional operations to the temporal types is to apply the operation <emphasis>at each instant</emphasis>, which yields a temporal value as result. In that case, the operation is only defined on the intersection of the emporal extents of the operands; if the temporal extents are disjoint, then the result is null. For example, the temporal comparison operators, such as <varname>#&lt;</varname>, test whether the values taken by their operands at each instant satisfy the condition and return a temporal Boolean. Examples of the various generalizations of the operators are given next.
	</para>
	<programlisting language="sql" xml:space="preserve">
-- Temporal comparison
SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';
-- {[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';
-- NULL

-- Temporal addition
SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';
-- [3@2001-01-02, 3@2001-01-03)

-- Temporal intersects
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}

-- Temporal distance
SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;
  tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';
-- [0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)
</programlisting>

	<para>
		Another common requirement is to determine whether the operands <emphasis>ever</emphasis> or <emphasis>always</emphasis> satisfy a condition with respect to an operation. These can be obtained by applying the ever/always comparison operators. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Examples of ever and always comparison operators are given next.
	</para>
	<programlisting language="sql" xml:space="preserve">
-- Does the operands ever intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;
-- true

-- Does the operands always intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
  geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;
-- true

-- Is the left operand ever less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
  tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;
-- true

-- Is the left operand always less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
  tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;
-- true
</programlisting>
	<para>
		For efficiency reasons, some common operations with the ever or the always semantics are natively provided. For example, the <varname>intersects</varname> function determines whether there is an instant at which the two arguments spatially intersect.
	</para>

	<para>
		We describe next the functions and operators for temporal types. For conciseness, in the examples we mostly use sequences composed of two instants.
	</para>

	<sect1 id="input_output_temporal_types">
		<title>Input/Output of Temporal Types</title>
			<para>
				MobilityDB generalizes Open Geospatial Consortium's Well-Known Text (WKT), Well-Known Binary (WKB), and Moving Features JSON (MF-JSON) input/output format for all temporal types. We start by describing the WKT format.
			</para>

		<para>
			An <emphasis>instant value</emphasis> is a couple of the form <varname>v@t</varname>, where <varname>v</varname> is a value of the base type and <varname>t</varname> is a <varname>timestamptz</varname> value. The temporal extent of an instant value is a single timestamp. Examples of instant values are as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool 'true@2001-01-01 08:00:00';
SELECT tint '1@2001-01-01 08:00:00';
SELECT tfloat '1.5@2001-01-01 08:00:00';
SELECT ttext 'AAA@2001-01-01 08:00:00';
SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';
</programlisting>
		<para>
			A <emphasis>sequence value</emphasis> is a set of values <varname>v1@t1,...,vn@tn</varname> delimited by lower and upper bounds, which can be inclusive (represented by &lsquo;<varname>[</varname>&rsquo; and &lsquo;<varname>]</varname>&rsquo;) or exclusive (represented by &lsquo;<varname>(</varname>&rsquo; and &lsquo;<varname>)</varname>&rsquo;). A sequence value composed of a single couple <varname>v@t</varname> is called an <emphasis>instantaneous sequence</emphasis>. Sequence values have an associated <emphasis>interpolation function</emphasis> which may be discrete, linear, or stepwise. By definition, the lower and upper bounds of an instantaneous sequence or of a sequence value with discrete interpolation are inclusive. The temporal extent of a sequence value with discrete interpolation is a timestamp set. Examples of sequence values with discrete interpolation are as follows.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00}'; -- Instantaneous sequence
SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';
SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';
SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
</programlisting>
		<para>The temporal extent of a sequence value with linear or stepwise interpolation is a period defined by the first and last instants as well as the lower and upper bounds. Examples of sequence values with linear interpolation are as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';
SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';
SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';
SELECT tfloat '[1.5@2001-01-01 08:00:00]'; -- Instantaneous sequence
SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';
SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';
SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,
  Point(0 0)@2017-01-01 08:10:00)';
</programlisting>
		<para>Sequence values whose base type is continuous may specify that the interpolation is stepwise with the prefix <varname>Interp=Stepwise</varname>. If this is not specified, it is supposed that the interpolation is linear by default. Example of sequence values with stepwise interpolation are given next:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01 08:00:00, 3@2001-01-01 08:10:00]';
SELECT tgeompoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
  Point(1 1)@2017-01-01 08:05:00, Point(1 1)@2017-01-01 08:10:00)';
SELECT tgeompoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
 Point(1 1)@2017-01-01 08:05:00, Point(0 0)@2017-01-01 08:10:00)';
ERROR:  Invalid end value for temporal sequence with stepwise interpolation
SELECT tgeogpoint 'Interp=Stepwise;[Point(0 0)@2017-01-01 08:00:00,
  Point(1 1)@2017-01-01 08:10:00]';
</programlisting>
		<para>
			The last two instants of a sequence value with discrete interpolation and exclusive upper bound must have the same base value, as shown in the second and third examples above.
		</para>
		<para>
			A <emphasis>sequence set value</emphasis> is a set <varname>{v1,...,vn}</varname> where every <varname>vi</varname> is a sequence value. The interpolation of sequence set values can only be linear or stepwise, not discrete. All sequences composing a sequence set value must have the same interpolation. The temporal extent of a sequence set value is a set of periods. Examples of sequence set values with linear interpolation are as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),
  [true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';
SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),
  [2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,
  3@2001-01-06 08:00:00]}';
SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),
  [CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';
SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
  [Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
  [Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
</programlisting>
		<para>
			Sequence set values whose base type is continuous may specify that the interpolation is stepwise with the prefix <varname>Interp=Stepwise</varname>. If this is not specified, it is supposed that the interpolation is linear by default. Example of sequence set values with stepwise interpolation are given next:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tfloat 'Interp=Stepwise;{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00,
  2@2001-01-04 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tgeompoint 'Interp=Stepwise;{[Point(0 0)@2017-01-01 08:00:00,
  Point(0 1)@2017-01-01 08:05:00], [Point(0 1)@2017-01-01 08:10:00,
  Point(0 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint 'Interp=Stepwise;{[Point(0 0)@2017-01-01 08:00:00,
  Point(0 1)@2017-01-01 08:05:00], [Point(0 1)@2017-01-01 08:10:00,
  Point(0 1)@2017-01-01 08:15:00)}';
</programlisting>

		<para>
			For temporal points, it is possible to specify the spatial reference identifier (SRID) using the Extended Well-Known text (EWKT) representation as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'
</programlisting>
		<para>
			All component geometries of a temporal point will then be of the given SRID. Furthermore, each component geometry can specify its SRID with the EWKT format as in the following example
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'
</programlisting>
		<para>
			An error is raised if the component geometries are not all in the same SRID or if the SRID of a component geometry is different from the one of the temporal point, as shown below.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';
-- ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,
  SRID=4326;Point(0 1)@2000-01-02]';
-- ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
</programlisting>
		<para>
			If not specified, the default SRID for temporal geometric points is 0 (unknown) and for temporal geographic points is 4326 (WGS 84). Temporal points with stepwise interpolation may also specify the SRID, as shown next.
		</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint 'SRID=5435,Interp=Stepwise;[Point(0 0)@2000-01-01,
  Point(0 1)@2000-01-02]';
SELECT tgeogpoint 'Interp=Stepwise;[SRID=4326;Point(0 0)@2000-01-01,
  SRID=4326;Point(0 1)@2000-01-02]';
</programlisting>
		<para>
			We give below the input/output functions in Moving Features JSON (MF-JSON) and Well-Known Binary (WKB) format for temporal alphanumeric types. The corresponding functions for temporal points are detailed in <xref linkend="tpoint_inout" />.
		</para>

		<itemizedlist>
			<listitem id="temporal_asMFJSON">
				<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>Get the Moving Features JSON representation</para>
				<para><varname>asMFJSON(ttype,options integer=0,flags integer=0,maxdecdigits integer=15) → bytea</varname></para>
				<para>The <varname>options</varname> argument can be used to add a bounding box in the MFJSON output:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: MFJSON BBOX</para></listitem>
				</itemizedlist>
				<para>The <varname>flags</varname> argument can be used to customize the JSON output, for example, to produce an easy-to-read (for human readers) JSON output. Refer to the documentation of the <varname>json-c</varname> library for the possible values. Typical values are as follows:</para>
				<itemizedlist>
					<listitem><para>0: means no option (default value)</para></listitem>
					<listitem><para>1: JSON_C_TO_STRING_SPACED</para></listitem>
					<listitem><para>2: JSON_C_TO_STRING_PRETTY</para></listitem>
				</itemizedlist>
				<para>The <varname>maxdecdigits</varname> argument can be used to set the maximum number of decimal places in the output of floating point values (default 15).</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asMFJSON(tbool 't@2019-01-01 18:00:00', 1);
/* {"type":"MovingBoolean","stBoundedBy":{"period":{"begin":"2019-01-01 18:00:00+01",
   "end":"2019-01-01 18:00:00+01",'lower_inc':true,'upper_inc':true}},"values":true,
   "datetimes":"2019-01-01T18:00:00+01","interpolations":["Discrete"]} */
SELECT asMFJSON(tint '{10@2019-01-01 18:00:00, 25@2019-01-01 18:10:00}', 1);
/* {"type":"MovingInteger","stBoundedBy":{"bbox":[10,25],
   "period":{"begin":"2019-01-01 18:00:00+01","end":"2019-01-01 18:10:00+01"}},
   "values":[10,25],"datetimes":["2019-01-01T18:00:00+01","2019-01-01T18:10:00+01"],
   "interpolations":["Discrete"]} */
SELECT asMFJSON(tfloat '[10.5@2019-01-01 18:00:00+02, 25.5@2019-01-01 18:10:00+02]');
/* {"type":"MovingFloat","values":[10.5,25.5],
   "datetimes":["2019-01-01T17:00:00+01","2019-01-01T17:10:00+01"],
   "lower_inc":true,"upper_inc":true,"interpolations":["Linear"]} */
SELECT asMFJSON(ttext '{[walking@2019-01-01 18:00:00+02,
  driving@2019-01-01 18:10:00+02]}');
/* {"type":"MovingText","sequences":[{"values":["walking","driving"],
   "datetimes":["2019-01-01T17:00:00+01","2019-01-01T17:10:00+01"],
   "lower_inc":true,"upper_inc":true}],"interpolations":["Stepwise"]} */
</programlisting>
			</listitem>

			<listitem id="temporal_asBinary">
				<indexterm><primary><varname>asBinary</varname></primary></indexterm>
				<para>Get the Well-Known Binary (WKB) representation</para>
				<para><varname>asBinary(ttype,endian text='') → bytea</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asBinary(tbool 'true@2001-01-01');
-- \x010d000101009c57d3c11c0000
SELECT asBinary(tint '1@2001-01-01', 'XDR');
-- \x000016010000000100001cc1d3579c00
SELECT asBinary(tfloat '1.5@2001-01-01');
-- \x01130081000000000000f83f009c57d3c11c0000
SELECT asBinary(ttext 'AAA@2001-01-01');
-- \x01170001040000000000000041414100009c57d3c11c0000
</programlisting>
			</listitem>

			<listitem id="temporal_asHexWKB">
				<indexterm><primary><varname>asHexWKB</varname></primary></indexterm>
				<para>Get the Hexadecimal Well-Known Binary (WKB) representation as text</para>
				<para><varname>asHexWKB(ttype,endian text='') → text</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asHexWKB(tbool 'true@2001-01-01');
-- 010D000101009C57D3C11C0000
SELECT asHexWKB(tint '1@2001-01-01', 'XDR');
-- 000016010000000100001CC1D3579C00
SELECT asHexWKB(tfloat '1.5@2001-01-01');
-- 01130081000000000000F83F009C57D3C11C0000
SELECT asHexWKB(ttext 'AAA@2001-01-01');
-- 01170001040000000000000041414100009C57D3C11C0000
</programlisting>
			</listitem>

			<listitem id="tboolFromBinary">
				<indexterm><primary><varname>&lt;ttype&gt;FromBinary</varname></primary></indexterm>
				<para>Input a temporal value from its Well-Known Binary (WKB) representation</para>
				<para>There is one function per base type, the name of the function has as prefix the name of the base type, which is <varname>tbool</varname> or <varname>tint</varname> in the examples below.</para>
				<para><varname>&lt;ttype&gt;FromBinary(bytea) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tboolFromBinary('\x010d000101009c57d3c11c0000');
-- t@2001-01-01
SELECT tintFromBinary('\x000016010000000100001cc1d3579c00');
-- 1@2001-01-01
SELECT tfloatFromBinary('\x01130081000000000000f83f009c57d3c11c0000');
-- 1.5@2001-01-01
SELECT ttextFromBinary('\x01170001040000000000000041414100009c57d3c11c0000');
-- "AAA"@2001-01-01
</programlisting>
			</listitem>

			<listitem id="tboolFromHexWKB">
				<indexterm><primary><varname>&lt;ttype&gt;FromHexWKB</varname></primary></indexterm>
				<para>Input a temporal value from its Hexadecimal Extended Well-Known Binary (HexEWKB) representation</para>
				<para>There is one function per base type, the name of the function has as prefix the name of the base type, which is <varname>tbool</varname> or <varname>tint</varname> in the examples below.</para>
				<para><varname>&lt;ttype&gt;FromHexWKB(text) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tboolFromHexWKB('010D000101009C57D3C11C0000');
-- t@2001-01-01
SELECT tintFromHexWKB('000016010000000100001CC1D3579C00');
-- 1@2001-01-01
SELECT tfloatFromHexWKB('01130081000000000000F83F009C57D3C11C0000');
-- 1.5@2001-01-01
SELECT ttextFromHexWKB('01170001040000000000000041414100009C57D3C11C0000');
-- "AAA"@2001-01-01
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="constructor_temporal_tyes">
		<title>Constructor Functions</title>

		<para>
			Each temporal type has a constructor function with the same name as the type and optionally a suffix for the subtype, where the suffixes &lsquo;<varname>_inst</varname>&rsquo;, &lsquo;<varname>_discseq</varname>&rsquo;, &lsquo;<varname>_contseq</varname>&rsquo;, and &lsquo;<varname>_seqset</varname>&rsquo; correspond, respectively, to the subtypes instant, sequence with discrete interpolation, sequence with continuous interpolation (that is, linear or stepwise), and sequence set. Examples are <varname>tint</varname>, <varname>tint_discseq</varname>, or <varname>tgeompoint_seqset</varname>. Using the constructor function is frequently more convenient than writing a literal constant.
		</para>

		<itemizedlist>
			<listitem>
				<para>A first set of functions have two arguments, a base type and a time type, where the latter is a <varname>timestamptz</varname>, a <varname>tstzset</varname>, a <varname>tstzspan</varname>, or a <varname>tstzspanset</varname> value for constructing, respectively, an instant, a sequence with discrete interpolation, a sequence with linear or stepwise interpolation, or a sequence set value. The functions for sequence or sequence set values with continuous base type have in addition an optional third argument which is a Boolean for stating whether the resulting temporal value has linear or stepwise interpolation. By default this argument is true if it is not specified, that is, linear interpolation is assumed by default.</para>
			</listitem>

			<listitem>
				<para>Another set of functions for sequence values with discrete interpolation have a single argument, which is an array of values of the corresponding instant values.</para>
			</listitem>

			<listitem>
				<para>Another set of functions for sequence values with continuous interpolation have one argument for the array of values of the corresponding instant subtype and two optional Boolean arguments stating, respectively, whether the left and right bounds are inclusive or exclusive. It the these arguments are not specified they are assumed to be true by default. In addition, the functions for sequence values with continuous base type have an additional Boolean argument stating whether the interpolation is linear or not. It this argument is not specified it is assumed to be true by default.</para>
			</listitem>

			<listitem>
				<para>Another set of functions for sequence set values have a single argument, which is an array of values of the corresponding sequence values. For sequence values with continuous base type, the interpolation of the resulting temporal value depends on the interpolation of the composing sequences. An error is raised if the sequences composing the array have different interpolation.</para>
			</listitem>

			<listitem>
				<para>Finally, another set of functions for sequence set values have as first argument an array of values of the corresponding instant values, and two arguments stating a maximum distance and a maximum time interval such that a gap is introduced between composing sequences of the result whenever two consecutive input instants have a distance or a time gap greater than these values. For temporal points the distance is specified in units of the underlying SRID. These two gaps arguments are optional and if they are not given, a zero value is assumed, which is not taken into account for determining the gaps. In addition, the functions for sequence values with continuous base type have an additional Boolean argument stating whether the interpolation is linear or not. It this argument is not specified it is assumed to be true by default.</para>
			</listitem>
		</itemizedlist>

		<para>We give next the constructor functions for the various subtypes.</para>

		<itemizedlist>
			<listitem id="ttype_const">
				<indexterm><primary><varname>&lt;ttype&gt;</varname></primary></indexterm>
				<para>Constructor for temporal types from a base value and a time value</para>
				<para><varname>&lt;ttype&gt;(base,timestamptz) → ttype_inst</varname></para>
				<para><varname>&lt;ttype&gt;(base,tstzset) → ttype_discseq</varname></para>
				<para><varname>&lt;ttype&gt;(base,tstzspan,linear=true) → ttype_contseq</varname></para>
				<para><varname>&lt;ttype&gt;(base,tstzspanset,linear=true) → ttype_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool(true, timestamptz '2001-01-01');
SELECT tint(1, timestamptz '2001-01-01');
SELECT tfloat(1.5, tstzset '{2001-01-01, 2001-01-02}');
SELECT ttext('AAA', tstzset '{2001-01-01, 2001-01-02}');
SELECT tgeompoint('Point(0 0)', tstzspan '[2001-01-01, 2001-01-02]');
SELECT tgeogpoint('SRID=7844;Point(0 0)', tstzspanset '{[2001-01-01, 2001-01-02],
  [2001-01-03, 2001-01-04]}', false);
</programlisting>
			</listitem>

			<listitem id="ttype_discseq">
				<indexterm><primary><varname>&lt;ttype&gt;_discseq</varname></primary></indexterm>
				<para>Constructor for temporal types of sequence subtype and discrete interpolation</para>
				<para><varname>&lt;ttype&gt;_discseq(ttype_inst[]) → ttype_discseq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_discseq(ARRAY[tbool 'true@2001-01-01 08:00:00','false@2001-01-01 08:05:00']);
SELECT tint_discseq(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);
SELECT tfloat_discseq(ARRAY[tfloat '1.0@2001-01-01 08:00:00', '2.0@2001-01-01 08:05:00']);
SELECT ttext_discseq(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);
SELECT tgeompoint_discseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);
SELECT tgeogpoint_discseq(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',
  'Point(2 2)@2001-01-01 08:05:00']);
</programlisting>
			</listitem>

			<listitem id="ttype_contseq">
				<indexterm><primary><varname>&lt;ttype&gt;_contseq</varname></primary></indexterm>
				<para>Constructor for temporal types of sequence subtype and continuous interpolation</para>
				<para><varname>&lt;ttype&gt;_contseq(ttype_inst[],left_inc=true,right_inc=true,linear=true}) →</varname></para>
				<para><varname>  ttype_contseq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_contseq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],
  true, true);
SELECT tint_contseq(ARRAY[tint (2, timestamptz '2001-01-01 08:00:00'),
  tint(2, timestamptz '2001-01-01 08:10:00')], true, false);
SELECT tfloat_contseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
  '1@2001-01-03 08:10:00'], true, false);
SELECT tfloat_contseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
  '1@2001-01-03 08:10:00'], true, true, false);
SELECT ttext_contseq(ARRAY[ttext('AAA', timestamptz '2001-01-01 08:00:00'),
  ttext('BBB', timestamptz '2001-01-03 08:05:00'),
  ttext('BBB', timestamptz '2001-01-03 08:10:00')]);
SELECT tgeompoint_contseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);
SELECT tgeogpoint_contseq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',
  'Point(0 0)@2001-01-03 08:05:00'], true, true, false);
</programlisting>
			</listitem>

			<listitem id="ttype_seqset">
				<indexterm><primary><varname>&lt;ttype&gt;_seqset</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;tscalar&gt;_seqset_gaps</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;tdisc&gt;_seqset_gaps</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;tcont&gt;_seqset_gaps</varname></primary></indexterm>
				<para>Constructors for temporal types of sequence set subtype</para>
				<para><varname>&lt;ttype&gt;_seqset(ttype_contseq[]) → ttype_seqset</varname></para>
				<para><varname>&lt;tscalar&gt;_seqset_gaps(tint_inst[],maxt='0 minutes') → tscalar_seqset</varname></para>
				<para><varname>&lt;tdisc&gt;_seqset_gaps(tint_inst[],maxdist=0.0,maxt='0 minutes') → tdisc_seqset</varname></para>
				<para><varname>&lt;tcont&gt;_seqset_gaps(tcont_inst[],linear=true,maxdist=0.0,maxt='0 minutes') →</varname></para>
				<para><varname>  tcont_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_seqset(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',
  '[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);
SELECT tint_seqset(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,
  2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);
SELECT tfloat_seqset(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,
  2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT tfloat_seqset(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
  2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
  'Interp=Stepwise;[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT ttext_seqset(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',
  '[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);
SELECT tgeompoint_seqset(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,
  Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',
  '[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);
SELECT tgeogpoint_seqset(ARRAY[tgeogpoint
  'Interp=Stepwise;[Point(0 0)@2001-01-01 08:00:00, Point(0 0)@2001-01-01 08:05:00)',
  'Interp=Stepwise;[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);
SELECT tfloat_seqset(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
  2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
  '[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
-- ERROR:  Input sequences must have the same interpolation
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT tint_seqset_gaps(ARRAY[tint '1@2000-01-01', '3@2000-01-02', '4@2000-01-03',
  '5@2000-01-05'], 1, '1 day');
-- {[1@2000-01-01], [3@2000-01-02, 4@2000-01-03], [5@2000-01-05]}
SELECT ttext_seqset_gaps(ARRAY[ttext 'AA@2000-01-01', 'BB@2000-01-02', 'AA@2000-01-03',
'CC@2000-01-05'], '1 day');
-- {["AA"@2000-01-01, "BB"@2000-01-02, "AA"@2000-01-03], ["CC"@2000-01-05]}
SELECT asText(tgeompoint_seqset_gaps(ARRAY[tgeompoint 'Point(1 1)@2000-01-01',
  'Point(2 2)@2000-01-02', 'Point(3 2)@2000-01-03', 'Point(3 2)@2000-01-05'],
  true, 1, '1 day'));
/* {[POINT(1 1)@2000-01-01], [POINT(2 2)@2000-01-02, POINT(3 2)@2000-01-03],
   [POINT(3 2)@2000-01-05]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="casting_temporal_types">
		<title>Casting</title>

		<para>A temporal value can be converted into a compatible type using the notation <varname>CAST(ttype1 AS ttype2)</varname> or <varname>ttype1::ttype2</varname>.</para>
		<itemizedlist>
			<listitem id="ttype_bbox">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal value to a bounding box</para>
				<para><varname>ttype::tstzspan</varname></para>
				<para><varname>tnumber::{numspan,tbox}</varname></para>
				<para><varname>tpoint::stbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tstzspan;
-- [2001-01-01, 2001-01-03]
SELECT ttext '(A@2000-01-01, B@2000-01-03, C@2000-01-05]'::tstzspan;
-- (2000-01-01, 2000-01-05]
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]'::tstzspan;
-- [2001-01-01, 2001-01-03]
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::intspan;
-- [1, 3)
SELECT tfloat '(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::floatspan;
-- (1, 3]
SELECT tfloat 'Interp=Stepwise;(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::floatspan;
-- [1, 3]
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tbox;
-- TBOX XT((1,2),[2001-01-01,2001-01-03])
SELECT tfloat '(1@2000-01-01, 3@2000-01-03, 2@2000-01-05]'::tbox;
-- TBOX XT((1,3),[2001-01-01,2001-01-05])
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]'::stbox;
-- STBOX XT(((1,1),(3,3)),[2001-01-01, 2001-01-03])
SELECT tgeogpoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]'::stbox;
/* SRID=4326;GEODSTBOX XT(
   ((0.9972609281539917,0.017449747771024704,0.01745240643728351),
   (0.9996954202651978,0.05226423218846321,0.05233595624294383)),
   [2001-01-01, 2001-01-03]) */
</programlisting>
			</listitem>

			<listitem id="tint_tfloat">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast between a temporal integer and a temporal float</para>
				<para><varname>tint::tfloat</varname></para>
				<para><varname>tfloat::tint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;
-- [1@2001-01-01, 2@2001-01-03]
SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;
-- Interp=Stepwise;[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]
SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- [1@2001-01-01, 2@2001-01-03]
SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer
</programlisting>
			</listitem>

			<listitem id="tgeompoint_tgeogpoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal geometry point to a temporal geography point</para>
				<para><varname>tgeompoint::tgeogpoint</varname></para>
				<para><varname>tgeogpoint::tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);
-- {[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}
SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);
-- {POINT(0 0)@2001-01-01}
</programlisting>
			</listitem>
		</itemizedlist>

		<para>
			A common way to store temporal points in PostGIS is to represent them as geometries of type <varname>LINESTRING M</varname> and abuse the M dimension to encode timestamps as seconds since 1970-01-01 00:00:00. These time-enhanced geometries, called <emphasis>trajectories</emphasis>, can be validated with the function <varname>ST_IsValidTrajectory</varname> to verify that the M value is growing from each vertex to the next. Trajectories can be manipulated with the functions <varname>ST_ClosestPointOfApproach</varname>, <varname>ST_DistanceCPA</varname>, and <varname>ST_CPAWithin</varname>. Temporal point values can be converted to/from PostGIS trajectories.
		</para>

		<itemizedlist>
			<listitem id="tgeompoint_geometry">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast between a temporal point and a PostGIS trajectory</para>
				<para><varname>tpoint::geo</varname></para>
				<para><varname>geo::tpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);
-- POINT M (0 0 978307200)
SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
  Point(1 1)@2001-01-03}')::geometry);
-- MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)"
SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);
-- LINESTRING M (0 0 978307200,1 1 978393600)
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
  [Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
/* MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),
   (1 1 978652800,0 0 978739200)) */
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
  [Point(1 1)@2001-01-03],
  [Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
/* GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
   POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200)) */
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,
  1 1 978480000)'::tgeompoint);
-- [POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03];
SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
  POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);
/* {[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],
   [POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Accessor Functions</title>
		<itemizedlist>

			<listitem id="ttype_memSize">
				<indexterm><primary><varname>memSize</varname></primary></indexterm>
				<para>Get the memory size in bytes</para>
				<para><varname>memSize(ttype) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT memSize(tint '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- 280
</programlisting>
			</listitem>

			<listitem id="ttype_storeSize">
				<indexterm><primary><varname>storeSize</varname></primary></indexterm>
				<para>Get the storage (compressed) size in bytes</para>
				<para><varname>storeSize(ttype) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT storeSize(tint '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- 176
</programlisting>
			</listitem>

			<listitem id="tempSubtype">
				<indexterm><primary><varname>tempSubtype</varname></primary></indexterm>
				<para>Get the temporal type</para>
				<para><varname>tempSubtype(ttype) → {'Instant','Sequence','SequenceSet'}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tempSubtype(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Sequence
</programlisting>
			</listitem>

			<listitem id="interpolation">
				<indexterm><primary><varname>interpolation</varname></primary></indexterm>
				<para>Get the interpolation</para>
				<para><varname>interpolation(ttype) → {'Discrete','Stepwise','Linear'}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT interpolation(tfloat '{1@2001-01-01, 2@2001-01-02, 3@2001-01-03}');
-- Discrete
SELECT interpolation(tint '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Stepwise
SELECT interpolation(tfloat '[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Linear
SELECT interpolation(tfloat 'Interp=Stepwise;[1@2001-01-01, 2@2001-01-02, 3@2001-01-03]');
-- Stepwise
SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2001-01-01,
  Point(2 2)@2001-01-02, Point(3 3)@2001-01-03]');
-- Stepwise
</programlisting>
			</listitem>

			<listitem id="getValue">
				<indexterm><primary><varname>getValue</varname></primary></indexterm>
				<para>Get the value</para>
				<para><varname>getValue(ttype_inst) → base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getValue(tint '1@2001-01-01');
-- 1
SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2001-01-01'));
-- POINT(0 0)
</programlisting>
			</listitem>

			<listitem id="getValues">
				<indexterm><primary><varname>getValues</varname></primary></indexterm>
				<para>Get the values</para>
				<para><varname>getValues(ttype) → {bool[],set,geo}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getValues(tint '[1@2001-01-01, 2@2001-01-03]');
-- {1, 2}
SELECT getValues(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 4@2001-01-05)}');
-- {1, 2, 3, 4}
SELECT asText(getValues(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04)}'));
-- {"POINT(0 0)", "POINT(1 1)", "POINT(0 1)"}
</programlisting>
			</listitem>

			<listitem id="trajectory">
				<indexterm><primary><varname>trajectory</varname></primary></indexterm>
				<para>Get the base values traversed by the temporal value</para>
				<para><varname>trajectory(tcont) → {floatspanset,geo}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT trajectory(tfloat '[1@2001-01-01, 2@2001-01-03)');
-- {[1,2)}
SELECT trajectory(tfloat 'Interp=Stepwise;{[1@2001-01-01, 2@2001-01-02],
  [3@2001-01-03, 4@2001-01-05]}');
-- {[1, 1], [2, 2], [3, 3], [4, 4]}
SELECT ST_AsText(trajectory(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04)}'));
-- MULTILINESTRING((0 0,0 1),(0 1,1 1))
SELECT ST_AsText(trajectory(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2001-01-01,
  Point(0 1)@2001-01-02], [Point(0 1)@2001-01-03, Point(1 1)@2001-01-04]}'));
-- GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))
SELECT ST_AsText(trajectory(tgeompoint '{Point(0 0)@2001-01-01, Point(0 1)@2001-01-02}'));
-- MULTIPOINT(0 0,0 1)
SELECT ST_AsText(trajectory(tgeompoint '{[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02),
  [Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
  [Point(2 1)@2001-01-05, Point(2 2)@2001-01-06)}'));
-- GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))
</programlisting>
			</listitem>

			<listitem id="startValue">
				<indexterm><primary><varname>startValue</varname></primary></indexterm>
				<indexterm><primary><varname>endValue</varname></primary></indexterm>
				<para>Get the start/end value</para>
				<para><varname>startValue(ttype) → base</varname></para>
				<para><varname>endValue(ttype) → base</varname></para>
				<para>The functions do not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startValue(tfloat '(1@2001-01-01, 2@2001-01-03)');
-- 1
SELECT endValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</programlisting>
			</listitem>

			<listitem id="minValue">
				<indexterm><primary><varname>minValue</varname></primary></indexterm>
				<indexterm><primary><varname>maxValue</varname></primary></indexterm>
				<para>Get the minimum/maximum value</para>
				<para><varname>minValue(torder) → base</varname></para>
				<para><varname>maxValue(torder) → base</varname></para>
				<para>The functions do not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minValue(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1
SELECT maxValue(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5
</programlisting>
			</listitem>

			<listitem id="minInstant">
				<indexterm><primary><varname>minInstant</varname></primary></indexterm>
				<indexterm><primary><varname>maxInstant</varname></primary></indexterm>
				<para>Get the instant with the minimum/maximum value</para>
				<para><varname>minInstant(torder) → base</varname></para>
				<para><varname>maxInstant(torder) → base</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not. If several instants have the minimum value, the first one is returned.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minInstant(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- 1@2001-01-01
SELECT maxInstant(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- 5@2001-01-05
</programlisting>
			</listitem>

			<listitem id="valueSpan">
				<indexterm><primary><varname>valueSpan</varname></primary></indexterm>
				<para>Get the value span</para>
				<para><varname>valueSpan(tnumber) → numspan</varname></para>
				<para>The function does not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT valueSpan(tfloat '{[2@2001-01-01, 1@2001-01-03), [4@2001-01-03, 6@2001-01-05)}');
-- [1,6]
SELECT valueSpan(tfloat '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [1,3])
</programlisting>
			</listitem>

			<listitem id="valueAtTimestamp">
				<indexterm><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Get the value at a timestamp</para>
				<para><varname>valueAtTimestamp(ttype,timestamptz) → base</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT valueAtTimestamp(tfloat '[1@2001-01-01, 4@2001-01-04)', '2001-01-02');
-- 2
</programlisting>
			</listitem>

			<listitem id="getTimestamp">
				<indexterm><primary><varname>getTimestamp</varname></primary></indexterm>
				<para>Get the timestamp</para>
				<para><varname>getTimestamp(ttype_inst) → timestamptz</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getTimestamp(tint '1@2001-01-01');
-- 2001-01-01
</programlisting>
			</listitem>

			<listitem id="getTime">
				<indexterm><primary><varname>getTime</varname></primary></indexterm>
				<para>Get the time</para>
				<para><varname>getTime(ttype) → tstzspanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getTime(tint '[1@2001-01-01, 1@2001-01-15)');
-- {[2001-01-01, 2001-01-15)}
</programlisting>
			</listitem>

			<listitem id="ttype_duration">
				<indexterm><primary><varname>duration</varname></primary></indexterm>
				<para>Get the duration</para>
				<para><varname>duration(ttype, bool boundspan=FALSE) → interval</varname></para>
				<para>An additional parameter can be set to true to compute the duration of the bounding time span, thus ignoring the potential time gaps</para>
				<programlisting language="sql" xml:space="preserve">
SELECT duration(tfloat '{1@2001-01-01, 2@2001-01-03, 2@2001-01-05}');
-- 00:00:00
SELECT duration(tfloat '{1@2001-01-01, 2@2001-01-03, 2@2001-01-05}', true);
-- 4 days
SELECT duration(tfloat '[1@2001-01-01, 2@2001-01-03, 2@2001-01-05)');
-- 4 days
SELECT duration(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}');
-- 3 days
SELECT duration(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-05)}',
  true);
-- 4 days
</programlisting>
			</listitem>

			<listitem id="ttype_timespan">
				<indexterm><primary><varname>timespan</varname></primary></indexterm>
				<para>Get the time span on which the temporal value is defined ignoring the potential time gaps</para>
				<para><varname>timespan(ttype) → tstzspan</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timespan(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- [2001-01-01, 2001-01-05]
SELECT timespan(tfloat '{[1@2001-01-01, 1@2001-01-02), [2@2001-01-03, 3@2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</programlisting>
			</listitem>

			<listitem id="numInstants">
				<indexterm><primary><varname>numInstants</varname></primary></indexterm>
				<para>Get the number of different instants</para>
				<para><varname>numInstants(ttype) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3
</programlisting>
			</listitem>

			<listitem id="startInstant">
				<indexterm><primary><varname>startInstant</varname></primary></indexterm>
				<indexterm><primary><varname>endInstant</varname></primary></indexterm>
				<indexterm><primary><varname>instantN</varname></primary></indexterm>
				<para>Get the start/end/n-th instant</para>
				<para><varname>startInstant(ttype) → ttype_inst</varname></para>
				<para><varname>endInstant(ttype) → ttype_inst</varname></para>
				<para><varname>instantN(ttype,integer) → ttype_inst</varname></para>
				<para>The functions do not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02),
  (2@2000-01-02, 3@2000-01-03)}');
-- 1@2000-01-01
SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3@2000-01-03
SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);
-- 3@2000-01-03
</programlisting>
			</listitem>

			<listitem id="instants">
				<indexterm><primary><varname>instants</varname></primary></indexterm>
				<para>Get the different instants</para>
				<para><varname>instants(ttype) → ttype_inst[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- {"1@2000-01-01","2@2000-01-02","3@2000-01-03"}
</programlisting>
			</listitem>

			<listitem id="ttype_numTimestamps">
				<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
				<para>Get the number of different timestamps</para>
				<para><varname>numTimestamps(ttype) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numTimestamps(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 3
</programlisting>
			</listitem>

			<listitem id="ttype_startTimestamp">
				<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
				<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
				<indexterm><primary><varname>timestampN</varname></primary></indexterm>
				<para>Get the start/end/n-th timestamp</para>
				<para><varname>startTimestamp(ttype) → timestamptz</varname></para>
				<para><varname>endTimestamp(ttype) → timestamptz</varname></para>
				<para><varname>timestampN(ttype,integer) → timestamptz</varname></para>
				<para>The functions do not take into account whether the bounds are inclusive or not.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT startTimestamp(tfloat '[1@2001-01-01, 2@2001-01-03)');
-- 2001-01-01
SELECT endTimestamp(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2001-01-05
SELECT timestampN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 3);
-- 2001-01-05
</programlisting>
			</listitem>

			<listitem id="ttype_timestamps">
				<indexterm><primary><varname>timestamps</varname></primary></indexterm>
				<para>Get the different timestamps</para>
				<para><varname>timestamps(ttype) → timestamptz[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT timestamps(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"2001-01-01", "2001-01-03", "2001-01-05"}
</programlisting>
			</listitem>

			<listitem id="numSequences">
				<indexterm><primary><varname>numSequences</varname></primary></indexterm>
				<para>Get the number of sequences</para>
				<para><varname>numSequences({ttype_contseq,ttype_seqset}) → integer</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT numSequences(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- 2
</programlisting>
			</listitem>

			<listitem id="startSequence">
				<indexterm><primary><varname>startSequence</varname></primary></indexterm>
				<indexterm><primary><varname>endSequence</varname></primary></indexterm>
				<indexterm><primary><varname>sequenceN</varname></primary></indexterm>
				<para>Get the start/end/n-th sequence</para>
				<para><varname>startSequence({ttype_contseq,ttype_seqset}) → ttype_contseq</varname></para>
				<para><varname>endSequence({ttype_contseq,ttype_seqset}) → ttype_contseq</varname></para>
				<para><varname>sequenceN({ttype_contseq,ttype_seqset},integer) → ttype_contseq</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT startSequence(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}');
-- [1@2001-01-01, 2@2001-01-03)
SELECT endSequence(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- [3@2001-01-03, 5@2001-01-05)
SELECT sequenceN(tfloat '{[1@2001-01-01, 2@2001-01-03),
  [3@2001-01-03, 5@2001-01-05)}', 2);
-- [3@2001-01-03, 5@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="sequences">
				<indexterm><primary><varname>sequences</varname></primary></indexterm>
				<para>Get the sequences</para>
				<para><varname>sequences({ttype_contseq,ttype_seqset}) → ttype_contseq[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT sequences(tfloat '{[1@2001-01-01, 2@2001-01-03), [3@2001-01-03, 5@2001-01-05)}');
-- {"[1@2001-01-01, 2@2001-01-03)", "[3@2001-01-03, 5@2001-01-05)"}
</programlisting>
			</listitem>

			<listitem id="segments">
				<indexterm><primary><varname>segments</varname></primary></indexterm>
				<para>Get the segments</para>
				<para><varname>segments({ttype_contseq,ttype_seqset}) → ttype_contseq[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT segments(tint '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 1@2001-01-02)","[3@2001-01-02, 3@2001-01-03)","[2@2001-01-03]",
   "(3@2001-01-03, 3@2001-01-05)","[5@2001-01-05]"} */
SELECT segments(tfloat '{[1@2001-01-01, 3@2001-01-02, 2@2001-01-03],
  (3@2001-01-03, 5@2001-01-05]}');
/* {"[1@2001-01-01, 3@2001-01-02)","[3@2001-01-02, 2@2001-01-03]",
   "(3@2001-01-03, 5@2001-01-05]"} */
</programlisting>
			</listitem>

			<listitem id="integral">
				<indexterm><primary><varname>integral</varname></primary></indexterm>
				<para>Get the area under the curve</para>
				<para><varname>integral(tnumber) → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT  integral(tint '[1@2000-01-01,2@2000-01-02]') / (24 * 3600 * 1e6);
-- 1
SELECT integral(tfloat '[1@2000-01-01,2@2000-01-02]') / (24 * 3600 * 1e6);
-- 1.5
</programlisting>
			</listitem>

			<listitem id="twAvg">
				<indexterm><primary><varname>twAvg</varname></primary></indexterm>
				<para>Get the time-weighted average</para>
				<para><varname>twAvg(tnumber) → float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT twAvg(tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-04, 2@2001-01-06)}');
-- 1.75
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="transformation_functions">
		<title>Transformation Functions</title>
		<para>A temporal value can be transformed to another subtype. An error is raised if the subtypes are incompatible.</para>
		<itemizedlist>
			<listitem id="ttype_transform">
				<indexterm><primary><varname>&lt;ttype&gt;_inst</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;ttype&gt;_discseq</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;ttype&gt;_contseq</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;ttype&gt;_seqset</varname></primary></indexterm>
				<para>Transform a temporal value to another subtype</para>
				<para><varname>&lt;ttype&gt;_inst(ttype) → ttype_inst</varname></para>
				<para><varname>&lt;ttype&gt;_discseq(ttype) → ttype_discseq</varname></para>
				<para><varname>&lt;ttype&gt;_contseq(ttype) → ttype_contseq</varname></para>
				<para><varname>&lt;ttype&gt;_seqset(ttype) → ttype_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool_inst(tbool '{[true@2001-01-01]}');
-- t@2001-01-01
SELECT tbool_inst(tbool '{[true@2001-01-01, true@2001-01-02]}');
-- ERROR: Cannot transform input to a temporal instant
SELECT tbool_discseq(tbool 'true@2001-01-01');
-- {t@2001-01-01}
SELECT tint_contseq(tint '1@2001-01-01');
-- [1@2001-01-01]
SELECT tfloat_seqset(tfloat '2.5@2001-01-01');
-- {[2.5@2001-01-01]}
SELECT tfloat_seqset(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');
-- {[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}
</programlisting>
			</listitem>

			<listitem id="toLinear">
				<indexterm><primary><varname>toLinear</varname></primary></indexterm>
				<para>Transform a temporal value with continuous base type from stepwise to linear interpolation</para>
				<para><varname>toLinear(ttype) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02,
  1@2000-01-03, 2@2000-01-04]');
/* {[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03),
   [1@2000-01-03, 1@2000-01-04), [2@2000-01-04]} */
SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01,
  Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));
/* {[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02],
   [POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]} */
</programlisting>
			</listitem>

			<listitem id="shift">
				<indexterm><primary><varname>shift</varname></primary></indexterm>
				<para>Shift the timespan of the temporal value by an interval</para>
				<para><varname>shift(ttype,interval) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- {1@2001-01-02, 2@2001-01-04, 1@2001-01-06}
SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- [1@2001-01-02, 2@2001-01-04]
SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03],
  [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
/* {[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04],
   [POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]} */
</programlisting>
			</listitem>

			<listitem id="tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Scale the time span of the temporal value to an interval. If the time span of the temporal value is zero (for example, for a temporal instant), the result is the temporal value. The given interval must be strictly greater than zero.</para>
				<para><varname>tscale(ttype,interval) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tscale(tint '1@2001-01-01', '1 day');
-- 1@2001-01-01
SELECT tscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- {1@2001-01-01 00:00:00+01, 2@2001-01-01 12:00:00+01, 1@2001-01-02 00:00:00+01}
SELECT tscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- [1@2001-01-01, 2@2001-01-02]
SELECT asText(tscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
/* {[POINT(1 1)@2001-01-01 00:00:00+01, POINT(2 2)@2001-01-01 06:00:00+01,
   POINT(1 1)@2001-01-01 12:00:00+01], [POINT(2 2) @2001-01-01 18:00:00+01,
   POINT(1 1)@2001-01-02 00:00:00+01]} */
SELECT tscale(tint '1@2001-01-01', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem id="shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Shift and scale the time span of the temporal value to the two intervals. This function combines in a single step the functions <link linkend="shift"><varname>shift</varname></link> and <link linkend="tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale(ttype,interval,interval) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shiftTscale(tint '1@2001-01-01', '1 day', '1 day');
-- 1@2001-01-02
SELECT shiftTscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day', '1 day');
-- {1@2001-01-02 00:00:00+01, 2@2001-01-02 12:00:00+01, 1@2001-01-03 00:00:00+01}
SELECT shiftTscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day', '1 day');
-- [1@2001-01-02, 2@2001-01-03]
SELECT asText(shiftTscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}',
  '1 day', '1 day'));
/* {[POINT(1 1)@2001-01-02 00:00:00+01, POINT(2 2)@2001-01-02 06:00:00+01,
   POINT(1 1)@2001-01-02 12:00:00+01], [POINT(2 2) @2001-01-02 18:00:00+01,
   POINT(1 1)@2001-01-03 00:00:00+01]} */
</programlisting>
			</listitem>

			<listitem id="unnest">
				<indexterm><primary><varname>unnest</varname></primary></indexterm>
				<para>Transform a nonlinear temporal value into a set of rows, each one is a pair composed of a base value and a period set during which the temporal value has the base value.</para>
				<para><varname>unnest(ttype) → {(value,time)}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT (un).value, (un).time
FROM (SELECT unnest(tfloat '{1@2000-01-01, 2@2000-01-02, 1@2000-01-03}') AS un) t;
-- 1 | {[2000-01-01, 2000-01-01], [2000-01-03, 2000-01-03]}
-- 2 | {[2000-01-02, 2000-01-02]}
SELECT (un).value, (un).time
FROM (SELECT unnest(tint '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]') AS un) t;
-- 1 | {[2000-01-01, 2000-01-02), [2000-01-03, 2000-01-03]}
-- 2 | {[2000-01-02, 2000-01-03)}
SELECT (un).value, (un).time
FROM (SELECT unnest(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]') AS un) t;
-- ERROR:  The temporal value cannot have linear interpolation
SELECT ST_AsText((un).value), (un).time
FROM (SELECT unnest(tgeompoint 'Interp=Stepwise;[Point(1 1)@2000-01-01,
  Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]') AS un) t;
--  POINT(1 1) | {[2000-01-01, 2000-01-02), [2000-01-03, 2000-01-03]}
--  POINT(2 2) | {[2000-01-02, 2000-01-03)}</programlisting>
			</listitem>

	</itemizedlist>
	</sect1>

	<sect1 id="modification_functions">
		<title>Modification Functions</title>
		<para>We explain next the semantics of the modification operations (that is <varname>insert</varname>, <varname>update</varname>, and <varname>delete</varname>) for temporal types. These operations have similar semantics as the corresponding operations for application-time temporal tables introduced in the <ulink url="https://en.wikipedia.org/wiki/SQL:2011">SQL:2011</ulink> standard. The main difference is that SQL uses tuple timestamping (where timestamps are attached to tuples), while temporal values in MobilityDB use attribute timestamping (where timestamps are attached to attribute values).</para>

		<para>The <varname>insert</varname> operation adds to a temporal value the instants of another one without modifying the existing instants, as illustrated in <xref linkend="insert_fig" />.</para>

		<figure id="insert_fig" float="start">
			<title>Insert operation for temporal values.</title>
			<mediaobject>
				<imageobject><imagedata format="PDF" scale='100' fileref="images/insert.pdf"/></imageobject>
				<imageobject><imagedata format="SVG" scale='100' fileref="images/insert.svg"/></imageobject>
				<imageobject><imagedata format="PNG" scale='100' fileref="images/insert.png"/></imageobject>
			</mediaobject>
		</figure>

		<para>As shown in the figure, the temporal values may only intersect at their boundary, and in that case, they must have the same base value at their common timestamps, otherwise an error is raised. The result of the operation is the union of the instants for both temporal values, as shown in the first result of the figure. This is equivalent to a <varname>merge</varname> operation explained below. Alternatively, as shown in the second result of the figure, the inserted fragments that are disjoint with the original value are connected to the last instant before and the first instant after the fragment. A Boolean parameter <varname>connect</varname> is used to choose between the two results, and the parameter is set to true by default. Notice that this only applies to continuous temporal values.</para>

		<para>The <varname>update</varname> operation replaces the instants in the first temporal value with those of the second one as illustrated in <xref linkend="update_fig" />.</para>

		<figure id="update_fig" float="start">
			<title>Update operation for temporal values.</title>
			<mediaobject>
				<imageobject><imagedata format="PDF" scale='100' fileref="images/update.pdf"/></imageobject>
				<imageobject><imagedata format="SVG" scale='100' fileref="images/update.svg"/></imageobject>
				<imageobject><imagedata format="PNG" scale='100' fileref="images/update.png"/></imageobject>
			</mediaobject>
		</figure>

		<para>As in the case of an <varname>insert</varname> operation, an additional Boolean parameter determines whether the replaced disconnected fragments are connected in the resulting value, as shown in the two possible results in the figure. When the two temporal values are either disjoint or only overlap at their boundary, this corresponds to an <varname>insert</varname> operation as explained above. In this case, the <varname>update</varname> operation behaves as an <varname>upsert</varname> operation in SQL.</para>

		<para>The <varname>deleteTime</varname> operation removes the instants of a temporal value that intersect a time value. This operation can be used in two different situations, illustrated in <xref linkend="deleteTime_fig" />.</para>

		<figure id="deleteTime_fig" float="start">
			<title>Delete operation for temporal values.</title>
			<mediaobject>
				<imageobject><imagedata format="PDF" scale='100' fileref="images/delete.pdf"/></imageobject>
				<imageobject><imagedata format="SVG" scale='100' fileref="images/delete.svg"/></imageobject>
				<imageobject><imagedata format="PNG" scale='100' fileref="images/delete.png"/></imageobject>
			</mediaobject>
		</figure>

		<orderedlist>
			<listitem>
				<para>In the first case, shown as the top result in the figure, the meaning of operation is to introduce time gaps after removing the instants of the temporal value intersecting the time value. This is equivalent to the restriction operations (<xref linkend="restriction_functions" />), which restrict a temporal value to the complement of the time value.</para>
			</listitem>

			<listitem>
				<para>The second case, shown as the bottom result in the figure, is used for removing erroneous values (e.g., detected as outliers) without introducing a time gap, or for removing time gaps. In this case, the instants of the temporal value are deleted and the last instant before and the first instant after a removed fragment are connected. This behaviour is specified by setting an additional Boolean parameter of the operation. Notice that this only applies to continuous temporal values.</para>
			</listitem>
		</orderedlist>

		<figure id="modif_sql_fig" float="start">
			<title>Modification operations for temporal tables in SQL.</title>
			<mediaobject>
				<imageobject><imagedata format="PDF" scale='100' fileref="images/modif_sql.pdf"/></imageobject>
				<imageobject><imagedata format="SVG" scale='100' fileref="images/modif_sql.svg"/></imageobject>
				<imageobject><imagedata format="PNG" scale='100' fileref="images/modif_sql.png"/></imageobject>
			</mediaobject>
		</figure>

		<para>
			<xref linkend="modif_sql_fig" /> shows the equivalent modification operations for temporal tables in the SQL standard. Intuitively, these figures are obtained by rotating 90 degrees clockwise the corresponding figures for temporal values (<xref linkend="insert_fig" />, <xref linkend="update_fig" />, and <xref linkend="deleteTime_fig" />). This follows the fact that in SQL consecutive tuples ordered by time are typically connected through the <varname>LEAD</varname> and <varname>LAG</varname> window functions.
		</para>

		<itemizedlist>
			<listitem id="insert">
				<para>Insert a temporal value into another one</para>
				<para><varname>insert(ttype,ttype,connect boolean=true) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT insert(tint '{1@2000-01-01, 3@2000-01-03, 5@2000-01-05}',
  tint '{3@2000-01-03, 7@2000-01-07}');
-- {1@2000-01-01, 3@2000-01-03, 5@2000-01-05, 7@2000-01-07}
SELECT insert(tint '{1@2000-01-01, 3@2000-01-03, 5@2000-01-05}',
  tint '{5@2000-01-03, 7@2000-01-07}');
-- ERROR: The temporal values have different value at their overlapping instant 2000-01-03
SELECT insert(tfloat '[1@2000-01-01, 2@2000-01-02]',
  tfloat '[1@2000-01-03, 1@2000-01-05]');
-- [1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-05]
SELECT asText(insert(tgeompoint '{[Point(1 1 1)@2000-01-01, Point(2 2 2)@2000-01-02],
  [Point(3 3 3)@2000-01-04],[Point(1 1 1)@2000-01-05]}',
  tgeompoint 'Point(1 1 1)@2000-01-03'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02, POINT Z (1 1 1)@2000-01-03,
 POINT Z (3 3 3)@2000-01-04], [POINT Z (1 1 1)@2000-01-05]} */
</programlisting>
				</listitem>

				<listitem id="update">
				<para>Update a temporal value with another one</para>
				<para><varname>update(ttype,ttype,connect boolean=true) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT update(tint '{1@2000-01-01, 3@2000-01-03, 5@2000-01-05}',
  tint '{5@2000-01-03, 7@2000-01-07}');
-- {1@2000-01-01, 5@2000-01-03, 5@2000-01-05, 7@2000-01-07}
SELECT update(tfloat '[1@2000-01-01, 1@2000-01-05]',
  tfloat '[1@2000-01-02, 3@2000-01-03, 1@2000-01-04]');
-- {[1@2000-01-01, 1@2000-01-02, 3@2000-01-03, 1@2000-01-04, 1@2000-01-05]}
SELECT asText(update(tgeompoint '{[Point(1 1 1)@2000-01-01, Point(3 3 3)@2000-01-03,
  Point(1 1 1)@2000-01-05], [Point(1 1 1)@2000-01-07]}',
  tgeompoint '[Point(2 2 2)@2000-01-02, Point(2 2 2)@2000-01-04]'));
/*  {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02, POINT Z (2 2 2)@2000-01-04,
  POINT Z (1 1 1)@2000-01-05], [POINT Z (1 1 1)@2000-01-07]} */
</programlisting>
				</listitem>

				<listitem id="deleteTime">
					<para>Delete the instants of a temporal value that intersect a time value</para>
				<para><varname>deleteTime(ttype,time,connect boolean=true) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT deleteTime(tint '[1@2000-01-01, 1@2000-01-03]', timestamptz '2000-01-02', false);
-- {[1@2000-01-01, 1@2000-01-02), (1@2000-01-02, 1@2000-01-03]}
SELECT deleteTime(tint '[1@2000-01-01, 1@2000-01-03]', timestamptz '2000-01-02');
-- [1@2000-01-01, 1@2000-01-03]
SELECT deleteTime(tfloat '[1@2000-01-01, 4@2000-01-02, 2@2000-01-04, 5@2000-01-05]',
  tstzspan '[2000-01-02, 2000-01-04]');
-- [1@2000-01-01, 5@2000-01-05]
SELECT asText(deleteTime(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tstzspan '[2000-01-02, 2000-01-04]'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02, POINT Z (3 3 3)@2000-01-04,
  POINT Z (3 3 3)@2000-01-05]} */
</programlisting>
				</listitem>

			<listitem id="appendInstant">
				<indexterm><primary><varname>appendInstant</varname></primary></indexterm>
				<para>Append a temporal instant to a temporal value</para>
				<para><varname>appendInstant(ttype,ttype_inst) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');
-- {1@2000-01-01, 1@2000-01-02}
SELECT appendInstant(tint '[1@2000-01-01]', tint '1@2000-01-02');
-- [1@2000-01-01, 1@2000-01-02]
SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tgeompoint 'Point(1 1 1)@2000-01-06'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
   [POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05,
   POINT Z (1 1 1)@2000-01-06]} */
</programlisting>
			</listitem>

			<listitem id="appendSequence">
				<indexterm><primary><varname>appendSequence</varname></primary></indexterm>
				<para>Append a temporal sequence to a temporal value</para>
				<para><varname>appendSequence(ttype,ttype_seq) → {ttype_seq,ttype_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT appendSequence(tint '1@2000-01-01', tint '{2@2000-01-02, 3@2000-01-03}');
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03}
SELECT appendSequence(tint '[1@2000-01-01, 2@2000-01-02]',
  tint '[2@2000-01-02, 3@2000-01-03]');
-- [1@2000-01-01, 2@2000-01-02, 3@2000-01-03]
SELECT asText(appendSequence(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tgeompoint '[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
   [POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05,
   POINT Z (1 1 1)@2000-01-06]} */
</programlisting>
			</listitem>

			<listitem id="merge">
				<indexterm><primary><varname>merge</varname></primary></indexterm>
				<para>Merge the temporal values</para>
				<para><varname>merge(ttype,ttype) → ttype</varname></para>
				<para><varname>merge(ttype[]) → ttype</varname></para>
				<para>The temporal values may only intersect at their boundary and in that case, their base values at the common timestamps must be the same, otherwise an error is raised.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT merge(tint '1@2000-01-01', tint '1@2000-01-02');
-- {1@2000-01-01, 1@2000-01-02}
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[2@2000-01-02, 1@2000-01-03]');
-- [1@2000-01-01, 2@2000-01-02, 1@2000-01-03]
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[3@2000-01-03, 1@2000-01-04]');
-- {[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 1@2000-01-04]}
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[1@2000-01-02, 2@2000-01-03]');
-- ERROR:  Both arguments have different value at their overlapping timestamp
SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
  tgeompoint '{[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]}'));
/* {[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
   [POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05,
   POINT Z (1 1 1)@2000-01-06]} */

SELECT merge(ARRAY[tint '1@2000-01-01', '1@2000-01-02']);
-- {1@2000-01-01, 1@2000-01-02}
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{2@2000-01-02, 3@2000-01-03}']);
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03}
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{3@2000-01-03, 4@2000-01-04}']);
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04}
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[2@2000-01-02, 1@2000-01-03]']);
-- [1@2000-01-01, 2@2000-01-02, 1@2000-01-03]
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[3@2000-01-03, 4@2000-01-04]']);
-- {[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 4@2000-01-04]}
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
  [Point(3 3)@2000-01-03, Point(4 4)@2000-01-04]}', '{[Point(4 4)@2000-01-04,
  Point(3 3)@2000-01-05], [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}']);
/* {[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], [Point(3 3)@2000-01-03,
   Point(4 4)@2000-01-04, Point(3 3)@2000-01-05],
  [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]} */
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02]}',
  '{[Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]}']);
-- [Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]
</programlisting>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1 id="restriction_functions">
		<title>Restriction Functions</title>

		<para>There are two complementary sets of restriction functions. The first set functions restricts the temporal value with respect to a value or a time extent. Examples are <varname>atValues</varname> or <varname>atTime</varname>. The second set functions restricts the temporal value with respect to the <emphasis>complement</emphasis> of a value or a time extent. Examples are <varname>minusValues</varname> or <varname>minusTime</varname></para>

		<itemizedlist>
			<listitem id="atValues">
				<indexterm><primary><varname>atValues</varname></primary></indexterm>
				<indexterm><primary><varname>minusValues</varname></primary></indexterm>
				<para>Restrict to (the complement of) a set of values</para>
				<para><varname>atValues(ttype,values) → ttype</varname></para>
				<para><varname>minusValues(ttype,values) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atValues(tint '[1@2001-01-01, 1@2001-01-15)', 1);
-- [1@2001-01-01, 1@2001-01-15)
SELECT asText(atValues(tgeompoint '[Point(0 0 0)@2001-01-01, Point(2 2 2)@2001-01-03)',
  'Point(1 1 1)'));
-- {[POINT Z (1 1 1)@2001-01-02]}
SELECT atValues(tfloat '[1@2001-01-01, 4@2001-01-4)', floatset '{1, 3, 5}');
-- {[1@2001-01-01], [3@2001-01-03]}
SELECT asText(atValues(tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)',
  geomset '{"Point(0 0)", "Point(1 1)"}'));
-- {[POINT(0 0)@2001-01-01], [POINT(1 1)@2001-01-02]}
SELECT atValues(tfloat '[1@2001-01-01, 4@2001-01-4)', floatspan '[1,3]');
-- [1@2001-01-01, 3@2001-01-03]
SELECT atValues(tfloat '[1@2001-01-01, 5@2001-01-05)',
  floatspanset '{[1,2], [3,4]}');
-- {[1@2001-01-01, 2@2001-01-02],[3@2001-01-03, 4@2001-01-04]}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT minusValues(tint '[1@2001-01-01, 2@2001-01-02, 2@2001-01-03)', 1);
-- {[2@2001-01-02, 2@2001-01-03)}
SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2001-01-01, Point(2 2 2)@2001-01-03)',
  'Point(1 1 1)'));
/* {[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02),
   (POINT Z (1 1 1)@2001-01-02, POINT Z (2 2 2)@2001-01-03)} */
SELECT minusValues(tfloat '[1@2001-01-01, 4@2001-01-4)', floatset '{2, 3}');
/* {[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 3@2001-01-03),
   (3@2001-01-03, 4@2001-01-04)} */
SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2001-01-01, Point(3 3 3)@2001-01-04)',
  geomset '{"Point(1 1 1)', 'Point(2 2 2)"}'));
/* {[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02),
   (POINT Z (1 1 1)@2001-01-02, POINT Z (2 2 2)@2001-01-03),
  (POINT Z (2 2 2)@2001-01-03, POINT Z (3 3 3)@2001-01-04)} */
SELECT minusValues(tfloat '[1@2001-01-01, 4@2001-01-4)', floatspan '[2,3]');
-- {[1@2001-01-01, 2@2001-01-02), (3@2001-01-03, 4@2001-01-04)}
SELECT minusValues(tfloat '[1@2001-01-01, 5@2001-01-05)',
  floatspanset '{[1,2], [3,4]}');
-- {(2@2001-01-02, 3@2001-01-03), (4@2001-01-04, 5@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="atMin">
				<indexterm><primary><varname>atMin</varname></primary></indexterm>
				<indexterm><primary><varname>minusMin</varname></primary></indexterm>
				<para>Restrict to (the complement of) the minimum value</para>
				<para><varname>atMin(torder) → torder</varname></para>
				<para><varname>minusMin(torder) → torder</varname></para>
				<para>The function returns null if the minimum value only happens at exclusive bounds.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT atMin(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}');
-- {1@2001-01-01, 1@2001-01-05}
SELECT atMin(tint '(1@2001-01-01, 3@2001-01-03]');
-- {(1@2001-01-01, 1@2001-01-03)}
SELECT atMin(tfloat '(1@2001-01-01, 3@2001-01-03]');
-- NULL
SELECT atMin(ttext '{(AA@2001-01-01, AA@2001-01-03), (BB@2001-01-03, AA@2001-01-05]}');
-- {(AA@2001-01-01, AA@2001-01-03), [AA@2001-01-05]}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT minusMin(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}');
-- {2@2001-01-03}
SELECT minusMin(tfloat '[1@2001-01-01, 3@2001-01-03]');
-- {(1@2001-01-01, 3@2001-01-03]}
SELECT minusMin(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- {(1@2001-01-01, 3@2001-01-03)}
SELECT minusMin(tint '{[1@2001-01-01, 1@2001-01-03), (1@2001-01-03, 1@2001-01-05)}');
-- NULL
</programlisting>
			</listitem>

			<listitem id="atMax">
				<indexterm><primary><varname>atMax</varname></primary></indexterm>
				<indexterm><primary><varname>minusMax</varname></primary></indexterm>
				<para>Restrict to (the complement of) the maximum value</para>
				<para><varname>atMax(torder) → torder</varname></para>
				<para><varname>minusMax(torder) → torder</varname></para>
				<para>The function returns null if the maximum value only happens at exclusive bounds.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT atMax(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- {3@2001-01-05}
SELECT atMax(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- NULL
SELECT atMax(tfloat '{(2@2001-01-01, 1@2001-01-03), [2@2001-01-03, 2@2001-01-05)}');
-- {[2@2001-01-03, 2@2001-01-05]}
SELECT atMax(ttext '{(AA@2001-01-01, AA@2001-01-03), (BB@2001-01-03, AA@2001-01-05]}');
-- {("BB"@2001-01-03, "BB"@2001-01-05)}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT minusMax(tint '{1@2001-01-01, 2@2001-01-03, 3@2001-01-05}');
-- {1@2001-01-01, 2@2001-01-03}
SELECT minusMax(tfloat '[1@2001-01-01, 3@2001-01-03]');
-- {[1@2001-01-01, 3@2001-01-03)}
SELECT minusMax(tfloat '(1@2001-01-01, 3@2001-01-03)');
-- {(1@2001-01-01, 3@2001-01-03)}
SELECT minusMax(tfloat '{[2@2001-01-01, 1@2001-01-03), [2@2001-01-03, 2@2001-01-05)}');
-- {(2@2001-01-01, 1@2001-01-03)}
SELECT minusMax(tfloat '{[1@2001-01-01, 3@2001-01-03), (3@2001-01-03, 1@2001-01-05)}');
-- {[1@2001-01-01, 3@2001-01-03), (3@2001-01-03, 1@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="atGeometry">
				<indexterm><primary><varname>atGeometry</varname></primary></indexterm>
				<indexterm><primary><varname>minusGeometry</varname></primary></indexterm>
				<para>Restrict to (the complement of) a geometry</para>
				<para><varname>atGeometry(tgeompoint,geometry) → tgeompoint</varname></para>
				<para><varname>minusGeometry(tgeompoint,geometry) → tgeompoint</varname></para>
				<para>Notice that it is allowed to mix 2D/3D geometries but the computation is only performed on 2D.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- {"[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-03]"}
SELECT astext(atGeometry(tgeompoint '[Point(0 0 0)@2000-01-01, Point(4 4 4)@2000-01-05]',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- {[POINT Z (1 1 1)@2000-01-02, POINT Z (2 2 2)@2000-01-03]}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
/* {[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02), (POINT(2 2)@2001-01-03,
   POINT(3 3)@2001-01-04)} */
SELECT astext(minusGeometry(tgeompoint '[Point(0 0 0)@2000-01-01,
  Point(4 4 4)@2000-01-05]', geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
/* {[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02),
   (POINT Z (2 2 2)@2000-01-03, POINT Z (4 4 4)@2000-01-05]} */
</programlisting>
			</listitem>

			<listitem id="atTime">
				<indexterm><primary><varname>atTime</varname></primary></indexterm>
				<indexterm><primary><varname>minusTime</varname></primary></indexterm>
				<para>Restrict to (the complement of) a time value</para>
				<para><varname>atTime(ttype,time) → ttype</varname></para>
				<para><varname>minusTime(ttype,time) → ttype</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atTime(tfloat '[1@2001-01-01, 5@2001-01-05)', timestamptz '2001-01-02');
-- 2@2001-01-02
SELECT atTime(tint '[1@2001-01-01, 1@2001-01-15)',
  tstzset '{2001-01-01, 2001-01-03}');
-- {1@2001-01-01, 1@2001-01-03}
SELECT atTime(tfloat '{[1@2001-01-01, 3@2001-01-03), [3@2001-01-04, 1@2001-01-06)}',
  tstzspan '[2001-01-02,2001-01-05)');
-- {[2@2001-01-02, 3@2001-01-03), [3@2001-01-04, 2@2001-01-05)}
SELECT atTime(tint '[1@2001-01-01, 1@2001-01-15)',
  tstzspanset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- {[1@2001-01-01, 1@2001-01-03),[1@2001-01-04, 1@2001-01-05)}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT minusTime(tfloat '[1@2001-01-01, 5@2001-01-05)', '2001-01-02');
-- {[1@2001-01-01, 2@2001-01-02), (2@2001-01-02, 5@2001-01-05)}
SELECT minusTime(tint '[1@2001-01-01, 1@2001-01-15)',
  tstzset '{2001-01-02, 2001-01-03}');
/* {[1@2001-01-01, 1@2001-01-02), (1@2001-01-02, 1@2001-01-03),
   (1@2001-01-03, 1@2001-01-15)} */
SELECT minusTime(tfloat '{[1@2001-01-01, 3@2001-01-03), [3@2001-01-04, 1@2001-01-06)}',
  '[2001-01-02,2001-01-05)');
-- {[1@2001-01-01, 2@2001-01-02), [2@2001-01-05, 1@2001-01-06)}
SELECT minusTime(tint '[1@2001-01-01, 1@2001-01-15)',
  tstzspanset '{[2001-01-02, 2001-01-03), [2001-01-04, 2001-01-05)}');
/* {[1@2001-01-01, 1@2001-01-02), [1@2001-01-03, 1@2001-01-04),
   [1@2001-01-05, 1@2001-01-15)} */
</programlisting>
		</listitem>

			<listitem id="atTbox">
				<indexterm><primary><varname>atTbox</varname></primary></indexterm>
				<para>Restrict to (the complement of) a <varname>tbox</varname></para>
				<para><varname>atTbox(tnumber,tbox) → tnumber</varname></para>
				<para><varname>minusTbox(tnumber,tbox) → tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atTbox(tfloat '[0@2001-01-01, 3@2001-01-04)',
  tbox 'TBOX XT((0,2),[2001-01-02, 2001-01-04])');
-- {[1@2001-01-02, 2@2001-01-03]}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT minusTbox(tfloat '[1@2001-01-01, 4@2001-01-04)',
  'TBOX XT((1,4),[2001-01-03, 2001-01-04])');
-- {[1@2001-01-01, 3@2001-01-03)}
WITH temp(temp, box) AS (SELECT tfloat '[1@2001-01-01, 4@2001-01-04)',
  'TBOX XT((1,2),[2001-01-03, 2001-01-04])' )
SELECT minusSpan(minusPeriod(temp, box::tstzspan), box::floatspan) FROM temp;
-- {[1@2001-01-01], [2@2001-01-02, 3@2001-01-03)}
</programlisting>
			<para>Notice that when the bounding box has both value and time dimensions, the difference is computed by restricting the temporal number to the box using the function <varname>atTbox</varname>, computing the time extent of this restriction, and restricting the temporal number to the difference of the time extent. This is required to ensure that <varname>tnumber = merge(atTbox(tnumber,tbox), minusTbox(tnumber,tbox))</varname> (see the function <link linkend="merge"><varname>merge</varname></link>). In other words, while the function <varname>atTbox</varname> restricts the temporal number with respect to the span <emphasis>and</emphasis> the period defining the bounding box, the function <varname>minusTbox</varname> restricts the temporal number with respect to the span <emphasis>or</emphasis> the period. To obtain the restriction using an <emphasis>and</emphasis> semantics, both the <varname>minusValues</varname> and <varname>minusTime</varname> functions must be applied.</para>
		</listitem>

			<listitem id="atStbox">
				<indexterm><primary><varname>atStbox</varname></primary></indexterm>
				<para>Restrict to (the complement of) an <varname>stbox</varname></para>
				<para><varname>atStbox(tgeompoint,stbox) → tgeompoint</varname></para>
				<para><varname>minusStbox(tgeompoint,stbox) → tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(atStbox(tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)',
  stbox 'STBOX XT(((0,0),(2,2))),[2001-01-02, 2001-01-04]'));
-- {[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-03]}
</programlisting>

				<programlisting language="sql" xml:space="preserve">
SELECT asText(minusStbox(tgeompoint '[Point(1 1)@2001-01-01, Point(4 4)@2001-01-04)',
  stbox 'STBOX XT(((1,1),(4,4)),[2001-01-03,2001-01-04])'));
-- {[POINT(1 1)@2001-01-01), POINT(3 3)@2001-01-03)}
WITH temp(temp, box) AS (SELECT
  tgeompoint '[Point(1 1)@2001-01-01, Point(4 4)@2001-01-04)',
  stbox 'STBOX XT(((1,1),(2,2)),[2001-01-03,2001-01-04])')
SELECT asText(minusGeometry(minusTime(temp, box::tstzspan), box::geometry)) FROM temp;
-- {(POINT(2 2)@2001-01-02, POINT(3 3)@2001-01-03)}
</programlisting>
				<para>Similarly to function <link linkend="atTbox"><varname>minusTbox</varname></link>, when the bounding box has both space and time dimensions, the function <varname>minusStbox</varname> restricts the temporal point with respect to the space <emphasis>or</emphasis> the time extents of the box. To obtain the restriction using an <emphasis>and</emphasis> semantics, both the <varname>minusGeometry</varname> and <varname>minusTime</varname> functions must be applied.</para>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="operators_temporal_types">
		<title>Comparison Operators</title>

		<sect2>
			<title>Traditional Comparison Operators</title>

			<para>The traditional comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right operands be of the same base type. Excepted equality  and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on temporal types. These operators compare the bounding periods (see <xref linkend="setspan_comp_operators" />), then the bounding boxes (see <xref linkend="comparison_box_types" />) and if those are equal, then the comparison depends on the subtype. For instant values, they compare first the timestamps and if those are equal, compare the values. For sequence values, they compare the first N instants, where N is the minimum of the number of composing instants of both values. Finally, for sequence set values, they compare the first N sequence values, where N is the minimum of the number of composing sequences of both values.</para>

			<para>The equality and inequality operators consider the equivalent representation for different subtypes as shown next.
				<programlisting language="sql" xml:space="preserve">
SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';
-- true
SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';
-- true
SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';
-- true
SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =
  tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';
-- true
SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =
  tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';
-- true
</programlisting>
			</para>

			<itemizedlist>
				<listitem id="ttype_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Are the temporal values equal?</para>
					<para><varname>ttype = ttype → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' = tint '[2@2001-01-03, 2@2001-01-05)';
-- false
</programlisting>
				</listitem>

				<listitem id="ttype_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>Are the temporal values different?</para>
					<para><varname>ttype &lt;&gt; ttype → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;&gt; tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>Is the first temporal value less than the second one?</para>
					<para><varname>ttype &lt; ttype → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt; tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>Is the first temporal value greater than the second one?</para>
					<para><varname>ttype &gt; ttype → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt; tint '[2@2001-01-03, 2@2001-01-05)'
-- false
</programlisting>
				</listitem>

				<listitem id="ttype_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>Is the first temporal value less than or equal to the second one?</para>
					<para><varname>ttype &lt;= ttype → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &lt;= tint '[2@2001-01-03, 2@2001-01-05)'
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
				<para>Is the first temporal value greater than or equal to the second one?</para>
					<para><varname>ttype &gt;= ttype → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' &gt;= tint '[2@2001-01-03, 2@2001-01-05)'
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="ever_always_comparison">
			<title>Ever and Always Comparison Operators</title>
			<para>
				A possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types consists in determining whether the comparison is ever or always true. In this case, the result is a Boolean value. MobilityDB provides operators to test whether the comparison of a temporal value and a value of the base type is ever or always true. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Some examples are <varname>?=</varname>, <varname>%&lt;&gt;</varname>, or <varname>?&lt;=</varname>. Ever/always equality and non-equality are available for all temporal types, while ever/always inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>. The ever and always comparisons are inverse operators: for example, <varname>?=</varname> is the inverse of <varname>%&lt;&gt;</varname>, and <varname>?&gt;</varname> is the inverse of <varname>%&lt;=</varname>.
			</para>
			<itemizedlist>
				<listitem id="ttype_eveq">
					<indexterm><primary><varname>?=</varname></primary></indexterm>
					<indexterm><primary><varname>%=</varname></primary></indexterm>
					<para>Is the temporal value ever/always equal to the value?</para>
					<para><varname>ttype ?= base → boolean</varname></para>
					<para><varname>ttype %= base → boolean</varname></para>
					<para>The ever function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?= 2;
-- true
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' ?=
  geometry 'Point(1 1)';
-- true
</programlisting>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %= 2;
-- true
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-04)' %=
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_evne">
					<indexterm><primary><varname>?&lt;&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>%&lt;&gt;</varname></primary></indexterm>
					<para>Is the temporal value ever/always different from the value?</para>
					<para><varname>ttype ?&lt;&gt; base → boolean</varname></para>
					<para><varname>ttype %&lt;&gt; base → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' ?&lt;&gt; 2;
-- false
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' ?&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' ?&lt;&gt;
  geometry 'Point(1 1)';
-- true
</programlisting>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 3@2001-01-04)' %&lt;&gt; 2;
-- false
SELECT tfloat '[2@2001-01-01, 2@2001-01-04)' %&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2001-01-01, Point(1 1)@2001-01-04)' %&lt;&gt;
  geometry 'Point(1 1)';
-- true
</programlisting>
				</listitem>

				<listitem id="ttype_evlt">
					<indexterm><primary><varname>?&lt;</varname></primary></indexterm>
					<indexterm><primary><varname>%&lt;</varname></primary></indexterm>
					<para>Is the temporal value ever/always less than the value?</para>
					<para><varname>tnumber ?&lt; number → boolean</varname></para>
					<para><varname>tnumber %&lt; number → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' ?&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' ?&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' %&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' %&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_evgt">
					<indexterm><primary><varname>?&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>%&gt;</varname></primary></indexterm>
					<para>Is the temporal value ever/always greater than the value?</para>
					<para><varname>tnumber ?&gt; number → boolean</varname></para>
					<para><varname>tnumber %&gt; number → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-03, 1@2001-01-05)' ?&gt; 1;
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-03, 1@2001-01-05)' %&gt; 1;
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_evle">
					<indexterm><primary><varname>?&lt;=</varname></primary></indexterm>
					<indexterm><primary><varname>%&lt;=</varname></primary></indexterm>
					<para>Is the temporal value ever/always less than or equal to the value?</para>
					<para><varname>tnumber ?&lt;= number → boolean</varname></para>
					<para><varname>tnumber %&lt;= number → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' ?&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' %&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_evge">
					<indexterm><primary><varname>?&gt;=</varname></primary></indexterm>
					<indexterm><primary><varname>%&gt;=</varname></primary></indexterm>
					<para>Is the temporal value ever/always greater than or equal to the value?</para>
					<para><varname>tnumber ?&gt;= number → boolean</varname></para>
					<para><varname>tnumber %&gt;= number → boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text ?&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>

					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text %&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Temporal Comparison Operators</title>
			<para>Another possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types consists in determining whether the comparison is true or false at each instant. In this case, the result is a temporal Boolean. The temporal comparison operators are denoted by prefixing the traditional comparison operators with <varname>#</varname>. Some examples are <varname>#=</varname>  or <varname>#&lt;=</varname>. Temporal equality and non-equality are available for all temporal types, while temporal inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>.</para>

			<itemizedlist>
				<listitem id="ttype_teq">
					<indexterm><primary><varname>#=</varname></primary></indexterm>
					<para>Temporal equal</para>
					<para><varname>{base,ttype} #= {base,ttype} → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 2@2001-01-04)' #= 3;
-- {[f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tint '[1@2001-01-01, 1@2001-01-04)';
-- {[t@2001-01-01], (f@2001-01-01, f@2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #= tfloat '[4@2001-01-02, 1@2001-01-05)';
-- {[f@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  geometry 'Point(1 1)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(2 2)@2001-01-03)' #=
  tgeompoint '[Point(0 2)@2001-01-01, Point(2 0)@2001-01-03)';
-- {[f@2001-01-01], (t@2001-01-01, t@2001-01-03)}
</programlisting>
				</listitem>

				<listitem id="ttype_tne">
					<indexterm><primary><varname>#&lt;&gt;</varname></primary></indexterm>
					<para>Temporal different</para>
					<para><varname>{base,ttype} #&lt;&gt; {base,ttype} → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; 2;
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, 2001-01-04)}
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt;&gt; tint '[2@2001-01-02, 2@2001-01-05)';
-- {[f@2001-01-02], (t@2001-01-02, t@2001-01-04)}
</programlisting>
				</listitem>

				<listitem id="ttype_tlt">
					<indexterm><primary><varname>#&lt;</varname></primary></indexterm>
					<para>Temporal less than</para>
					<para><varname>{base,torder} #&lt; {base,torder} → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' #&lt; 2;
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-04)}
SELECT tint '[2@2001-01-01, 2@2001-01-05)' #&lt; tfloat '[1@2001-01-03, 3@2001-01-05)';
-- {[f@2001-01-03, f@2001-01-04], (t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttype_tgt">
					<indexterm><primary><varname>#&gt;</varname></primary></indexterm>
					<para>Temporal greater than</para>
					<para><varname>{base,torder} #&gt; {base,torder} → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 1 #&gt; tint '[1@2001-01-03, 1@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
				</listitem>

				<listitem id="ttype_tle">
					<indexterm><primary><varname>#&lt;=</varname></primary></indexterm>
					<para>Temporal less than or equal to</para>
					<para><varname>{base,torder} #&lt;= {base,torder} → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-05)' #&lt;= tfloat '{2@2001-01-03, 3@2001-01-04}';
-- {t@2001-01-03, t@2001-01-04}
</programlisting>
				</listitem>

				<listitem id="ttype_tge">
					<indexterm><primary><varname>#&gt;=</varname></primary></indexterm>
					<para>Temporal greater than or equal to</para>
					<para><varname>{base,torder} #&gt;= {base,torder} → tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 'AAA'::text #&gt; ttext '{[AAA@2001-01-01, AAA@2001-01-03),
  [BBB@2001-01-04, BBB@2001-01-05)}';
-- {[f@2001-01-01, f@2001-01-03), [t@2001-01-04, t@2001-01-05)}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1>
		<title>Bounding Box Operators</title>

		<para>These operators test whether the bounding boxes of their arguments satisfy the predicate and result in a Boolean value. As stated in <xref linkend="temporal_types" />, the bounding box associated to a temporal type depends on the base type: It is the <varname>tstzspan</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types, the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types, and the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types. Furthermore, as seen in <xref linkend="casting_box_types" />, many PostgreSQL, PostGIS, or MobilityDB types can be cast to the <varname>tbox</varname> and <varname>stbox</varname> types. For example, numeric and span types can be casted to type <varname>tbox</varname>, types <varname>geometry</varname> and <varname>geography</varname> can be casted to type <varname>stbox</varname>, and time types and temporal types can be casted to types <varname>tbox</varname> and <varname>stbox</varname>.</para>

		<para>A first set of operators consider the topological relationships between the bounding boxes. There are five topological operators: overlaps (<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), contained (<varname>&lt;@</varname>), same (<varname>~=</varname>), and adjacent (<varname>-|-</varname>). The arguments of these operators can be a base type, a box, or a temporal type and the operators verify the topological relationship taking into account the value and/or the time dimension depending on the type of the arguments.</para>

		<para>Another set of operators consider the relative position of the bounding boxes. The operators <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname> consider the value dimension for <varname>tint</varname> and <varname>tfloat</varname> types and the X coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider the Y coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider the Z coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, and the operators <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider the time dimension for all temporal types.</para>

		<para>Finally, it is worth noting that the bounding box operators allow to mix 2D/3D geometries but in that case, the computation is only performed on 2D.</para>

		<para>We refer to <xref linkend="box_topo_operators" /> and <xref linkend="box_relpos_operators" /> for the bounding box operators.</para>
	</sect1>

	<sect1>
		<title>Mathematical Functions and Operators</title>

		<itemizedlist>
			<listitem id="tnumber_add">
				<indexterm><primary><varname>+</varname></primary></indexterm>
				<para>Temporal addition</para>
				<para><varname>{number,tnumber} + {number,tnumber} → tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[2@2001-01-01, 2@2001-01-04)' + 1.5;
-- [3.5@2001-01-01, 3.5@2001-01-04)
SELECT tint '[2@2001-01-01, 2@2001-01-04)' + tfloat '[1@2001-01-01, 4@2001-01-04)';
-- [3@2001-01-01, 6@2001-01-04)
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' +
  tfloat '{[1@2001-01-01, 2@2001-01-02), [1@2001-01-02, 2@2001-01-04)}';
-- {[2@2001-01-01, 4@2001-01-04), [3@2001-01-02, 6@2001-01-04)}
</programlisting>
			</listitem>

			<listitem id="tnumber_sub">
				<indexterm><primary><varname>-</varname></primary></indexterm>
				<para>Temporal subtraction</para>
				<para><varname>{number,tnumber} - {number,tnumber} → tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tint '[1@2001-01-01, 1@2001-01-04)' - tint '[2@2001-01-03, 2@2001-01-05)';
-- [-1@2001-01-03, -1@2001-01-04)
SELECT tfloat '[3@2001-01-01, 6@2001-01-04)' - tint '[2@2001-01-01, 2@2001-01-04)';
-- [1@2001-01-01, 4@2001-01-04)
</programlisting>
			</listitem>

			<listitem id="tnumber_mult">
				<indexterm><primary><varname>*</varname></primary></indexterm>
				<para>Temporal multiplication</para>
				<para><varname>{number,tnumber} * {number,tnumber} → tnumber</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' * 2;
-- [2@2001-01-01, 8@2001-01-04)
SELECT tfloat '[1@2001-01-01, 4@2001-01-04)' * tint '[2@2001-01-01, 2@2001-01-04)';
-- [2@2001-01-01, 8@2001-01-04)
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' * '[3@2001-01-01, 1@2001-01-03)'
-- {[3@2001-01-01, 4@2001-01-02, 3@2001-01-03)}
</programlisting>
			</listitem>

			<listitem id="tnumber_div">
				<indexterm><primary><varname>/</varname></primary></indexterm>
				<para>Temporal division</para>
				<para><varname>{number,tnumber} / {number,tnumber} → tnumber</varname></para>
				<para>The function will raise an error if the denominator will ever be equal to zero during the common timespan of the arguments.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT 2 / tfloat '[1@2001-01-01, 3@2001-01-04)';
-- [2@2001-01-01, 1@2001-01-02 12:00:00+00, 0.666666666666667@2001-01-04)
SELECT tfloat '[1@2001-01-01, 5@2001-01-05)' / '[5@2001-01-01, 1@2001-01-05)'
-- {[0.2@2001-01-01, 1@2001-01-03,2001-01-03, 5@2001-01-03,2001-01-05)}
SELECT 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'
-- ERROR:  Division by zero
SELECT tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'
-- [-2@2000-01-04, 1@2000-01-05]
</programlisting>
			</listitem>

			<listitem id="round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Round the values to a number of decimal places</para>
				<para><varname>round(tfloat,integer) → tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);
-- [0.79@2000-01-01, 2.36@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="degrees">
				<indexterm><primary><varname>degrees</varname></primary></indexterm>
				<indexterm><primary><varname>radians</varname></primary></indexterm>
				<para>Convert between radians and degrees</para>
				<para><varname>degrees(tfloat) → tfloat</varname></para>
				<para><varname>radians(tfloat) → tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');
-- [45@2000-01-01, 135@2000-01-02]
SELECT radians(tfloat '[45@2000-01-01, 135@2000-01-02]');
-- [0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]
</programlisting>
			</listitem>

			<listitem id="derivative">
				<indexterm><primary><varname>derivative</varname></primary></indexterm>
				<para>Get the derivative over time of the temporal float in units per second</para>
				<para><varname>derivative(tfloat) → tfloat</varname></para>
				<para>The temporal float must have linear interpolation</para>
				<programlisting language="sql" xml:space="preserve">
SELECT derivative(tfloat '{[0@2000-01-01, 10@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 0@2000-01-05]}') * 3600 * 24;
/* Interp=Stepwise;{[-10@2000-01-01, 5@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 1@2000-01-05]} */
SELECT derivative(tfloat 'Interp=Stepwise;[0@2000-01-01, 10@2000-01-02, 5@2000-01-03]');
-- ERROR:  The temporal value must have linear interpolation
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Boolean Functions and Operators</title>
		<itemizedlist>
			<listitem id="tbool_and">
				<indexterm><primary><varname>&amp;</varname></primary></indexterm>
				<para>Temporal and</para>
				<para><varname>{boolean,tbool} &amp; {boolean,tbool} → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-03, true@2001-01-05)' &amp;
  tbool '[false@2001-01-03, false@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
SELECT tbool '[true@2001-01-03, true@2001-01-05)' &amp;
  tbool '{[false@2001-01-03, false@2001-01-04),
  [true@2001-01-04, true@2001-01-05)}';
-- {[f@2001-01-03, t@2001-01-04, t@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="tbool_or">
				<indexterm><primary><varname>|</varname></primary></indexterm>
				<para>Temporal or</para>
				<para><varname>{boolean,tbool} | {boolean,tbool} → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tbool '[true@2001-01-03, true@2001-01-05)' |
  tbool '[false@2001-01-03, false@2001-01-05)';
-- [t@2001-01-03, t@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="tbool_not">
				<indexterm><primary><varname>~</varname></primary></indexterm>
				<para>Temporal not</para>
				<para><varname>~tbool → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ~tbool '[true@2001-01-03, true@2001-01-05)';
-- [f@2001-01-03, f@2001-01-05)
</programlisting>
			</listitem>

			<listitem id="whenTrue">
				<indexterm><primary><varname>whenTrue</varname></primary></indexterm>
				<para>Get the time when the temporal Boolean takes the value true</para>
				<para><varname>whenTrue(tbool) → tstzspanset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT whenTrue(tfloat '[1@2000-01-01, 4@2000-01-04, 1@2000-01-07]' #> 2);
-- {(2000-01-02, 2000-01-06)}
SELECT whenTrue(tdwithin(tgeompoint '[Point(1 1)@2000-01-01, Point(4 4)@2000-01-04,
  Point(1 1)@2000-01-07]', geometry 'Point(1 1)', sqrt(2)));
-- {[2000-01-01, 2000-01-02], [2000-01-06, 2000-01-07]}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Text Functions and Operators</title>

		<itemizedlist>
			<listitem id="ttext_concat">
				<indexterm><primary><varname>||</varname></primary></indexterm>
				<para>Temporal text concatenation</para>
				<para><varname>{text,ttext} || {text,ttext} → ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT ttext '[AA@2001-01-01, AA@2001-01-04)' || text 'B';
-- ["AAB"@2001-01-01, "AAB"@2001-01-04)
SELECT ttext '[AA@2001-01-01, AA@2001-01-04)' || ttext '[BB@2001-01-02, BB@2001-01-05)';
-- ["AABB"@2001-01-02, "AABB"@2001-01-04)
SELECT ttext '[A@2001-01-01, B@2001-01-03, C@2001-01-04]' ||
  ttext '{[D@2001-01-01, D@2001-01-02), [E@2001-01-02, E@2001-01-04)}';
-- {["DA"@2001-01-01, "EA"@2001-01-02, "EB"@2001-01-03, "EB"@2001-01-04)}
</programlisting>
			</listitem>

			<listitem id="ttext_lower">
				<indexterm><primary><varname>lower</varname></primary></indexterm>
				<indexterm><primary><varname>upper</varname></primary></indexterm>
				<para>Transform between lowercase and uppercase</para>
				<para><varname>upper(ttext) → ttext</varname></para>
				<para><varname>lower(ttext) → ttext</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- ["aa"@2000-01-01, "bb"@2000-01-02]
SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- ["AA"@2000-01-01, "BB"@2000-01-02]
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

</chapter>
