<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="set_span_types">
	<title>Set and Span Types</title>

	<para>
		MobilityDB has four <emphasis>set</emphasis> types, namely <varname>intset</varname>, <varname>bigintset</varname>, <varname>floatset</varname>, and <varname>timestampset</varname>, for representing, respectively, set of distinct <varname>integer</varname>, <varname>bigint</varname>, <varname>float</varname>, and <varname>timestamptz</varname> (timestamp with time zone) values. These set types enable efficient operations for manipulating set of distinct values.
	</para>

	<para>
		MobilityDB has four <emphasis>span</emphasis> types, namely <varname>intspan</varname>, <varname>bigintspan</varname>, <varname>floatspan</varname>, and <varname>period</varname>, for representing, respectively, ranges of <varname>integer</varname>, <varname>bigint</varname>, <varname>float</varname>, and <varname>timestamptz</varname> (timestamp with time zone) values. Furthermore, MobilityDB has the corresponding <emphasis>span set</emphasis> types, namely <varname>intspanset</varname>, <varname>bigintspanset</varname>, <varname>floatspanset</varname>, and <varname>periodset</varname>, for representing set of disjoint spans.
	</para>

	<para>
		The span and span set types in MobilityDB correspond to the range and multirange types in PostgreSQL,<footnote><para>Notice that multirange types require PostgreSQL version 14 or higher.</para></footnote> where the types <varname>intspan</varname>, <varname>intspanset</varname>, <varname>period</varname>, and <varname>periodset</varname> correspond, respectively, to the types <varname>int4range</varname>, <varname>int4multirange</varname>, <varname>tstzrange</varname>, and <varname>tstzmultirange</varname> types. However, span and span set types in MobilityDB have a more efficient implementation than the range and multirange types in PostgreSQL. In particular, span types in MobilityDB are of fixed length while the range types in PostgreSQL are of variable length. Furthermore, empty ranges and infinite bounds are allowed in range values in PostgreSQL, while this is not allowed for span values in MobilityDB.
	</para>

	<para>
		In what follows, since span and span set types have similar functions and operators, when we speak about span types we mean both span and span set types, unless we explicitly refer to <emphasis>unit</emphasis> span types and span <emphasis>set</emphasis> types to distinguish them.
	</para>

	<sect1 id ="functions_operations_set_span_types">
		<title>Functions and Operators for Set and Span Types</title>

		<para>
			We present next the functions and operators for set and span types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this in the signature of the operators, we use the following notation:
		</para>
		<itemizedlist>
			<listitem>
				<para><varname>set</varname> represents any set type, that is, <varname>intset</varname>, <varname>bigintset</varname>, <varname>floatset</varname>, or <varname>timestampset</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>span</varname> represents any span or span set type, that is, <varname>intspan</varname>, <varname>bigintspan</varname>, <varname>floatspan</varname>, or <varname>period</varname> and the corresponding span set types.</para>
			</listitem>
			<listitem>
				<para><varname>spanset</varname> represents any span set type, that is, <varname>intspanset</varname>, <varname>bigintspanset</varname>, <varname>floatspanset</varname>, or <varname>periodset</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>numspan</varname> represents any numeric span type, that is, <varname>intspan</varname>, <varname>bigintspan</varname>, or <varname>floatspan</varname> and the corresponding span set types.</para>
			</listitem>
			<listitem>
				<para><varname>base</varname> represents any base type of a set or span type, that is, <varname>integer</varname>, <varname>bigint</varname>, <varname>float</varname>, or <varname>timestamptz</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>number</varname> represents any base type of a numeric span type, that is, <varname>integer</varname>, <varname>bigint</varname>, or <varname>float</varname>,</para>
			</listitem>
			<listitem>
				<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
			</listitem>
			<listitem>
				<para>A set of types such as <varname>{period,timestampset,periodset}</varname> represents any of the types listed,</para>
			</listitem>
			<listitem>
				<para><varname>type[]</varname> represents an array of <varname>type</varname>.</para>
			</listitem>
		</itemizedlist>

		<para>
			As an example, the signatures of the contains operator (<varname>@&gt;</varname>) are as follows:
		</para>
		<programlisting language="sql" xml:space="preserve">
numspan @&gt; {numspan,number}: boolean
{timestampset,period,periodset} @&gt; time: boolean
</programlisting>
		<para>
			In the following, for conciseness, the time part of the timestamps is omitted in the examples. Recall that in that case PostgreSQL assumes the time <varname>00:00:00</varname>.
		</para>

		<sect2>
			<title>Input/Output Functions</title>

			<para>
				MobilityDB generalizes Open Geospatial Consortium's (<ulink url="https://www.ogc.org/">OGC</ulink>) Well-Known Text (<ulink url="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">WKT</ulink>) and Well-Known Binary (<ulink url="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary">WKB</ulink>) input/output format for all its types. In this way, applications can exchange data between them using a standardized exchange format. The WKT format is human-readable while the WKB format is more compact and more efficient than the WKT format. The WKB format can be output either as a binary string or as a character string encoded in hexadecimal ASCII.
			</para>

			<para>
				A value of a unit span type has two bounds, the <emphasis>lower bound</emphasis> and the <emphasis>upper bound</emphasis>, which are values of the underlying <emphasis>base type</emphasis>. For example, a value of the <varname>period</varname> type has two bounds, which are <varname>timestamptz</varname> values. The bounds can be inclusive or exclusive. An inclusive bound means that the boundary instant is included in the span, while an exclusive bound means that the boundary instant is not included in the span. In the text form of a span value, inclusive and exclusive lower bounds are represented, respectively, by &ldquo;<varname>[</varname>&rdquo; and &ldquo;<varname>(</varname>&rdquo;. Likewise, inclusive and exclusive upper bounds are represented, respectively, by &ldquo;<varname>]</varname>&rdquo; and &ldquo;<varname>)</varname>&rdquo;. In a span value, the lower bound must be less than or equal to the upper bound. A span value with equal and inclusive bounds is called an <emphasis>instantaneous span</emphasis> and corresponds to a base type value. Examples of span values are as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)';
SELECT floatspan '[1.5, 3.5]';
SELECT period '[2001-01-01 08:00:00, 2001-01-03 09:30:00)';
-- Instant spans
SELECT intspan '[1, 1]';
SELECT floatspan '[1.5, 1.5]';
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:00:00]';
-- Erroneous span: invalid bounds
SELECT period '[2001-01-01 08:10:00, 2001-01-01 08:00:00]';
-- Erroneous span: empty span
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:00:00)';
</programlisting>

			<para>
				A value of a span set type represents an ordered set of disjoint span values. A span set value must contain at least one element, in which case it corresponds to a single span value. Examples of span set values are as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT floatspanset '{[8.1, 8.5],[9.2, 9.4]}';
-- Singleton spanset
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Erroneous spanset: unordered elements
SELECT intspanset '{[3,4],[1,2]}';
-- Erroneous spanset: overlapping elements
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:05:00, 2001-01-01 08:15:00]}';
</programlisting>

			<para>
				Values of the span set types are converted into <emphasis>normal form</emphasis> so that equivalent values have identical representations. For this, consecutive adjacent span values are merged when possible. Examples of transformation into normal form are as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT intspanset '{[1,2],[3,4]}';
-- {[1, 5)}
SELECT floatspanset '{[1.5,2.5],(2.5,4.5]}';
-- {[1.5, 4.5]}
SELECT periodset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00),
  [2001-01-01 08:10:00, 2001-01-01 08:10:00], (2001-01-01 08:10:00, 2001-01-01 08:20:00]}';
-- {[2001-01-01 08:00:00+00,2001-01-01 08:20:00+00]}
</programlisting>

			<para>
				Finally, the <varname>timestampset</varname> type represents an ordered set of different <varname>timestamptz</varname> values. A <varname>timestampset</varname> value must contain at least one element, in which case it corresponds to a <varname>timestamptz</varname> value. Examples of <varname>timestampset</varname> values are as follows:
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT timestampset '{2001-01-01 08:00:00, 2001-01-03 09:30:00}';
-- Singleton timestampset
SELECT timestampset '{2001-01-01 08:00:00}';
-- Erroneous timestampset: unordered elements
SELECT timestampset '{2001-01-01 08:10:00, 2001-01-01 08:00:00}';
-- Erroneous timestampset: duplicate elements
SELECT timestampset '{2001-01-01 08:00:00, 2001-01-01 08:00:00}';
</programlisting>

			<para>
				We give next the functions for input/output of span and time types in Well-Known Binary format.
			</para>

			<itemizedlist>
				<listitem id="spantime_asBinary">
					<indexterm><primary><varname>asBinary</varname></primary></indexterm>
					<para>Get the Well-Known Binary (WKB) representation of a span or time type</para>
					<para><varname>asBinary({span,timestampset},endian text=''): bytea</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asBinary(intspan '[1, 2]');
-- \x010900010100000003000000
SELECT asBinary(intspanset '{[1, 2], [4, 5]}', 'XDR');
 \x00000a00000002010000000100000003010000000400000006
SELECT asBinary(floatspan '[1.5, 2.5)');
-- \x01060001000000000000f83f0000000000000440
SELECT asBinary(period '[2001-01-01, 2001-01-03]');
-- \x010c0003009c57d3c11c0000005c060fea1c0000
SELECT asBinary(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}');
-- \x010d000200000003009c57d3c11c0000005c060fea1c00000300bcdd2cfe1c0000001cb54a121d0000
SELECT asBinary(timestampset '{2001-01-01, 2001-01-03}');
-- \x0102000000009c57d3c11c0000005c060fea1c0000
</programlisting>
				</listitem>

				<listitem id="spantime_asHexWKB">
					<indexterm><primary><varname>asHexWKB</varname></primary></indexterm>
					<para>Get the Hexadecimal Well-Known Binary (HexWKB) representation as text of a span or time type</para>
					<para><varname>asHexWKB({span,timestampset},endian text=''): text</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then NDR is used.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asHexWKB(intspan '[1, 2]');
-- 010900010100000003000000
SELECT asHexWKB(intspanset '{[1, 2], [4, 5]}', 'XDR');
-- 00000A00000002010000000100000003010000000400000006
SELECT asHexWKB(floatspan '[1.5, 2.5)');
-- 01060001000000000000F83F0000000000000440
SELECT asHexWKB(period '[2001-01-01, 2001-01-03]');
-- 010C0003009C57D3C11C0000005C060FEA1C0000
SELECT asHexWKB(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}');
-- 010D000200000003009C57D3C11C0000005C060FEA1C00000300BCDD2CFE1C0000001CB54A121D0000
SELECT asHexWKB(timestampset '{2001-01-01, 2001-01-03}');
-- 0102000000009C57D3C11C0000005C060FEA1C0000
</programlisting>
				</listitem>

				<listitem id="spantime_FromBinary">
					<indexterm><primary><varname>intspanFromBinary</varname></primary></indexterm>
					<indexterm><primary><varname>intspansetFromBinary</varname></primary></indexterm>
					<indexterm><primary><varname>floatspanFromBinary</varname></primary></indexterm>
					<indexterm><primary><varname>floatspansetFromBinary</varname></primary></indexterm>
					<indexterm><primary><varname>periodFromBinary</varname></primary></indexterm>
					<indexterm><primary><varname>periodsetFromBinary</varname></primary></indexterm>
					<indexterm><primary><varname>timestampsetFromBinary</varname></primary></indexterm>
					<para>Input a span or time type from a Well-Known Binary (WKB) representation</para>
					<para><varname>intspanFromBinary(bytea): intspan</varname></para>
					<para><varname>intspansetFromBinary(bytea): intspanset</varname></para>
					<para><varname>floatspanFromBinary(bytea): floatspan</varname></para>
					<para><varname>floatspansetFromBinary(bytea): floatspanset</varname></para>
					<para><varname>periodFromBinary(bytea): period</varname></para>
					<para><varname>periodsetFromBinary(bytea): periodset</varname></para>
					<para><varname>timestampsetFromBinary(bytea): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanFromBinary('\x010800010100000003000000');
-- [1, 3)
SELECT periodsetFromBinary(
  '\x01020000000300fce0136a58010000bc8f4f9258010003001c676da6580100007c3e8bba580100');
-- {[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}
SELECT timestampsetFromBinary('\x01020000000fce0136a58010000bc8f4f92580100');
-- {2001-01-01, 2001-01-03}
</programlisting>
				</listitem>

				<listitem id="spantime_FromHexWKB">
					<indexterm><primary><varname>intspanFromHexWKB</varname></primary></indexterm>
					<indexterm><primary><varname>intspansetFromHexWKB</varname></primary></indexterm>
					<indexterm><primary><varname>floatspanFromHexWKB</varname></primary></indexterm>
					<indexterm><primary><varname>floatspansetFromHexWKB</varname></primary></indexterm>
					<indexterm><primary><varname>periodFromHexWKB</varname></primary></indexterm>
					<indexterm><primary><varname>periodsetFromHexWKB</varname></primary></indexterm>
					<indexterm><primary><varname>timestampsetFromHexWKB</varname></primary></indexterm>
					<para>Input a span or time time from an Hexadecimal Well-Known Binary (HexWKB) representation</para>
					<para><varname>intspanFromHexWKB(text): intspan</varname></para>
					<para><varname>intspansetFromHexWKB(text): intspanset</varname></para>
					<para><varname>floatspanFromHexWKB(text): floatspan</varname></para>
					<para><varname>floatspansetFromHexWKB(text): floatspanset</varname></para>
					<para><varname>periodFromHexWKB(text): period</varname></para>
					<para><varname>periodsetFromHexWKB(text): periodset</varname></para>
					<para><varname>timestampsetFromHexWKB(text): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanFromHexWKB('010800010100000003000000');
-- [1, 3)
SELECT floatspanFromHexWKB('01060001000000000000F83F0000000000000440');
-- [1.5, 2.5)
SELECT periodFromHexWKB('010A000300FCE0136A58010000BC8F4F92580100');
-- [2001-01-01, 2001-01-03]
SELECT periodsetFromHexWKB(
  '01020000000300FCE0136A58010000BC8F4F9258010003001C676DA6580100007C3E8BBA580100');
-- {[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}
SELECT timestampsetFromHexWKB('010200000000FCE0136A58010000BC8F4F92580100');
-- {2001-01-01, 2001-01-03}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Constructor Functions</title>

			<para>The unit span types have a constructor function that accepts four arguments. The first two arguments specify, respectively, the lower and upper bound, and the last two arguments are Boolean values stating, respectively, whether the lower and upper bounds are inclusive or not. The last two arguments are assumed to be, respectively, true and false if not specified. Notice that integer spans are always transformed into <emphasis>normal form</emphasis>, that is, with inclusive lower bound and exclusive upper bound.
			</para>
			<itemizedlist>
				<listitem id="span">
					<indexterm><primary><varname>span</varname></primary></indexterm>
					<para>Constructor for span types</para>
					<para><varname>intspan(integer,integer,left_inc=true,right_inc=false): intspan</varname></para>
					<para><varname>floatspan(float,float,left_inc=true,right_inc=false): floatspan</varname></para>
					<para><varname>period(timestamptz,timestamptz,left_inc=true,right_inc=false): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
-- Float span defined with two arguments
SELECT floatspan(20.5, 25);
-- [20.5, 25)
-- Integer span defined with four arguments
SELECT SELECT intspan (20, 25, false, true);
-- [21, 26)
-- Period defined with four arguments
SELECT period('2001-01-01 08:00:00', '2001-01-03 09:30:00', false, true);
-- (2001-01-01 08:00:00+01, 2001-01-03 09:30:00+01]
</programlisting>
				</listitem>
			</itemizedlist>

			<para>The constructor function for span set types have a single argument that is an array of span values of the same subtype.
			</para>
			<itemizedlist>
				<listitem id="spanset">
					<indexterm><primary><varname>intspanset</varname></primary></indexterm>
					<indexterm><primary><varname>floatspanset</varname></primary></indexterm>
					<indexterm><primary><varname>periodset</varname></primary></indexterm>
					<para>Constructor for span set types</para>
					<para><varname>intspanset(intspan[]): intspanset</varname></para>
					<para><varname>floatspanset(floatspan[]): floatspanset</varname></para>
					<para><varname>periodset(period[]): periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanset(ARRAY[intspan '[10,12]', '[13,15]']);
-- {[10, 16)}
SELECT floatspanset(ARRAY[floatspan '[10.5,12.5]', '[13.5,15.5]']);
-- {[10.5, 12.5], [13.5, 15.5]}
SELECT periodset(ARRAY[period '[2001-01-01 08:00, 2001-01-01 08:10]',
  '[2001-01-01 08:20, 2001-01-01 08:40]']);
-- {[2001-01-01 08:00, 2001-01-01 08:10], [2001-01-01 08:20, 2001-01-01 08:40]};
</programlisting>
				</listitem>
			</itemizedlist>

			<para>The constructor function for the <varname>timestampset</varname> type has a single argument that is an array of <varname>timestamptz</varname> values.
			</para>
			<itemizedlist>
				<listitem id="timestampset">
					<indexterm><primary><varname>timestampset</varname></primary></indexterm>
					<para>Constructor for <varname>timestampset</varname></para>
					<para><varname>timestampset(timestamptz[]): timestampset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampset(ARRAY[timestamptz '2001-01-01 08:00:00', '2001-01-03 09:30:00']);
-- {2001-01-01 08:00:00+00, 2001-01-03 09:30:00+00}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Casting</title>
			<para>
				Values of MobilityDB span types, the <varname>timestampset</varname> type, and PostgreSQL range types can be converted to one another using the function <varname>CAST</varname> or using the <varname>::</varname> notation.
			</para>

			<itemizedlist>
				<listitem id="timestamptz_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestamptz</varname> value to another time type</para>
					<para><varname>timestamptz::{timestampset,period,periodset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS timestampset);
-- {2001-01-01 08:00:00+01}
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS period);
-- [2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01]
SELECT CAST(timestamptz '2001-01-01 08:00:00' AS periodset);
-- {[2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01]}
</programlisting>
				</listitem>
				<listitem id="timestampset_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestampset</varname> value to a <varname>periodset</varname> value</para>
					<para><varname>timestampset::periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT CAST(timestampset '{2001-01-01 08:00:00, 2001-01-01 08:15:00,
  2001-01-01 08:25:00}' AS periodset);
/* {[2001-01-01 08:00:00+01, 2001-01-01 08:00:00+01],
   [2001-01-01 08:15:00+01, 2001-01-01 08:15:00+01],
   [2001-01-01 08:25:00+01, 2001-01-01 08:25:00+01]} */
</programlisting>
				</listitem>
				<listitem id="setspan_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a span value to a span set value</para>
					<para><varname>intspan::intspanset</varname></para>
					<para><varname>floatspan::floatspanset</varname></para>
					<para><varname>period::periodset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1,2]'::intspanset;
-- {[1, 3)}
SELECT floatspan '[1.5,2.5]'::floatspanset;
-- {[1.5, 2.5]}
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::periodset;
-- {[2001-01-01 08:00:00+01, 2001-01-01 08:30:00+01)}
</programlisting>
				</listitem>

				<listitem id="setspan_cast_range">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a span value to a PostgreSQL range value</para>
					<para><varname>intspan::int4range</varname></para>
					<para><varname>intspanset::int4multirange</varname></para>
					<para><varname>period::tstzrange</varname></para>
					<para><varname>periodset::tstzmultirange</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[10, 20)'::int4range;
-- [10,20)
SELECT intspanset '{[1,2],[4,5]}'::int4multirange;
-- {[1,3),[4,6)}
SELECT period '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::tstzrange;
-- ["2001-01-01 08:00:00+01","2001-01-01 08:30:00+01")
SELECT periodset '{[2000-01-01,2000-01-02],[2000-01-04,2000-01-05]}'::tstzmultirange;
-- {[2000-01-01,2000-01-02],[2000-01-04,2000-01-05]}
</programlisting>
				</listitem>
				<listitem id="range_cast_span">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a PostgreSQL range value to a span value</para>
					<para><varname>int4range::intspan</varname></para>
					<para><varname>int4multirange::intspanset</varname></para>
					<para><varname>tstzrange::period</varname></para>
					<para><varname>tstzmultirange::period</varname></para>
					<para>Notice that PostgreSQL range values accept empty ranges and ranges with infinite values, which are not allowed as span values in MobilityDB</para>
					<programlisting language="sql" xml:space="preserve">
SELECT int4range '[10, 20)'::intspan;
-- [10,20)
SELECT int4range 'empty'::intspan;
-- ERROR:  Range cannot be empty
SELECT int4range '[10,)'::intspan;
-- ERROR:  Range bounds cannot be infinite
SELECT int4multirange '{[1,2],[4,5]}'::intspanset;
-- {[1, 3), [4, 6)}
SELECT tstzrange '[2001-01-01 08:00:00, 2001-01-01 08:30:00)'::period;
-- [2001-01-01 08:00:00+01, 2001-01-01 08:30:00+01)
SELECT tstzmultirange '{[2000-01-01,2000-01-02],[2000-01-04,2000-01-05]}'::periodset;
-- {[2000-01-01, 2000-01-02], [2000-01-04, 2000-01-05]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Accessor Functions</title>

			<itemizedlist>
				<listitem id="setspan_memorySize">
					<indexterm><primary><varname>memorySize</varname></primary></indexterm>
					<para>Get the memory size in bytes</para>
					<para><varname>memorySize({spanset,timestampset}): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT memorySize(timestampset '{2001-01-01, 2001-01-02, 2001-01-03}');
-- 104
SELECT memorySize(periodset '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04],
  [2001-01-05, 2001-01-06]}');
-- 136
</programlisting>
				</listitem>

				<listitem id="setspan_storageSize">
					<indexterm><primary><varname>storageSize</varname></primary></indexterm>
					<para>Get the storage (compressed) size in bytes</para>
					<para><varname>storageSize({spanset,timestampset}): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT storageSize(timestampset '{2001-01-01, 2001-01-02, 2001-01-03}');
-- 56
SELECT storageSize(periodset '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04],
  [2001-01-05, 2001-01-06]}');
-- 112
</programlisting>
				</listitem>

				<listitem id="lower">
					<indexterm><primary><varname>lower</varname></primary></indexterm>
					<para>Get the lower bound</para>
					<para><varname>lower(span): base</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT lower(intspan '[20, 25)');
-- 20
SELECT lower(intspanset '{[1,2],[4,5]}');
--  1
SELECT lower(period '[2011-01-01, 2011-01-05)');
-- 2011-01-01
</programlisting>
				</listitem>

				<listitem id="upper">
					<indexterm><primary><varname>upper</varname></primary></indexterm>
					<para>Get the upper bound</para>
					<para><varname>upper(span): base</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT upper(intspanset '{[1,2],[4,5]}');
--  6
SELECT upper(floatspan '[20.5, 25.3)');
-- 25.3
SELECT upper(period '[2011-01-01, 2011-01-05)');
-- 2011-01-05
</programlisting>
				</listitem>

				<listitem id="lower_inc">
					<indexterm><primary><varname>lower_inc</varname></primary></indexterm>
					<para>Is the lower bound inclusive?</para>
					<para><varname>lower_inc(span): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT lower_inc(intspan '[20, 25)');
-- true
SELECT lower_inc(intspanset '{[1,2],[4,5]}');
-- true
SELECT lower_inc(period '[2011-01-01, 2011-01-05)');
-- true
</programlisting>
				</listitem>

				<listitem id="upper_inc">
					<indexterm><primary><varname>upper_inc</varname></primary></indexterm>
					<para>Is the upper bound inclusive?</para>
					<para><varname>upper_inc(span): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT upper_inc(intspanset '{[1,2],[4,5]}');
-- false
SELECT upper(floatspan '[20.5, 25.3]');
-- true
SELECT upper_inc(period '[2011-01-01, 2011-01-05)');
-- false
</programlisting>
				</listitem>

				<listitem id="width">
					<indexterm><primary><varname>width</varname></primary></indexterm>
					<para>Get the width of the span as a float</para>
					<para><varname>width(numspan): float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT width(intspan '[1, 3)');
-- 2
SELECT width(floatspan '[1, 3.5)');
-- 2.5
SELECT width(intspanset '{[1,2],[4,5]}');
-- 4
</programlisting>
				</listitem>

				<listitem id="setspan_duration">
					<indexterm><primary><varname>duration</varname></primary></indexterm>
					<para>Get the duration</para>
					<para><varname>duration({period,periodset}): interval</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT duration(period '[2001-01-01, 2001-01-03)');
-- 2 days
SELECT duration(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- 3 days
</programlisting>
				</listitem>

				<listitem id="setspan_timespan">
					<indexterm><primary><varname>timespan</varname></primary></indexterm>
					<para>Get the timespan ignoring the potential time gaps</para>
					<para><varname>timespan({timestampset,periodset}): interval</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT timespan(timestampset '{2001-01-01, 2001-01-03}');
-- 2 days
SELECT timespan(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-05)}');
-- 4 days
</programlisting>
				</listitem>

				<listitem id="setspan_period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Get the period on which the timestamp set or period set is defined ignoring the potential time gaps</para>
					<para><varname>period({timestampset,periodset}): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}');
-- [2001-01-01, 2001-01-05]
SELECT period(periodset '{[2001-01-01, 2001-01-02), [2001-01-03, 2001-01-04)}');
-- [2001-01-01, 2001-01-04)
</programlisting>
				</listitem>

				<listitem id="setspan_numTimestamps">
					<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
					<para>Get the number of different timestamps</para>
					<para><varname>numTimestamps({timestampset,periodset}): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT numTimestamps(timestampset '{2001-01-01, 2001-01-03, 2001-01-04}');
-- 3
SELECT numTimestamps(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="setspan_startTimestamp">
					<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
					<para>Get the start timestamp</para>
					<para><varname>startTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT startTimestamp(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-01
</programlisting>
				</listitem>

				<listitem id="setspan_endTimestamp">
					<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
					<para>Get the end timestamp</para>
					<para><varname>endTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT endTimestamp(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- 2001-01-05
</programlisting>
				</listitem>

				<listitem id="setspan_timestampN">
					<indexterm><primary><varname>timestampN</varname></primary></indexterm>
					<para>Get the n-th different timestamp</para>
					<para><varname>timestampN({timestampset,periodset},integer): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestampN(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}', 3);
-- 2001-01-04
</programlisting>
				</listitem>

				<listitem id="setspan_timestamps">
					<indexterm><primary><varname>timestamps</varname></primary></indexterm>
					<para>Get the different timestamps</para>
					<para><varname>timestamps({timestampset,periodset}): timestampset</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT timestamps(periodset '{[2001-01-01, 2001-01-03), (2001-01-03, 2001-01-05)}');
-- {"2001-01-01", "2001-01-03", "2001-01-05"}
</programlisting>
				</listitem>

				<listitem id="numSpans">
					<indexterm><primary><varname>numSpans</varname></primary></indexterm>
					<indexterm><primary><varname>numPeriods</varname></primary></indexterm>
					<para>Get the number of spans or periods</para>
					<para><varname>numSpans(spanset): integer</varname></para>
					<para><varname>numPeriods(periodset): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT numSpans(intspanset '{[1,3),[4,4],[6,7)}');
-- 3
SELECT numPeriods(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="startSpan">
					<indexterm><primary><varname>startSpan</varname></primary></indexterm>
					<indexterm><primary><varname>startPeriod</varname></primary></indexterm>
					<para>Get the start span or period</para>
					<para><varname>startSpan(spanset): span</varname></para>
					<para><varname>startPeriod(periodset): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT startSpan(intspanset '{[1,3),[4,4],[6,7)}');
-- [1,3)
SELECT startPeriod(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- [2001-01-01,2001-01-03)
</programlisting>
				</listitem>

				<listitem id="endSpan">
					<indexterm><primary><varname>endSpan</varname></primary></indexterm>
					<indexterm><primary><varname>endPeriod</varname></primary></indexterm>
					<para>Get the end period</para>
					<para><varname>endSpan(spanset): span</varname></para>
					<para><varname>endPeriod(periodset): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT endSpan(floatspanset '{[1,3),[4,4],[6,7)}');
-- [6,7)
SELECT endPeriod(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- [2001-01-05,2001-01-06)
</programlisting>
				</listitem>

				<listitem id="spanN">
					<indexterm><primary><varname>spanN</varname></primary></indexterm>
					<indexterm><primary><varname>periodN</varname></primary></indexterm>
					<para>Get the n-th period</para>
					<para><varname>spanN(spanset,integer): span</varname></para>
					<para><varname>periodN(periodset,integer): period</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT spanN(floatspanset '{[1,3),[4,4],[6,7)}',2);
-- [4,4]
SELECT periodN(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}', 2);
-- [2001-01-04,2001-01-04]
</programlisting>
				</listitem>

				<listitem id="spans">
					<indexterm><primary><varname>spans</varname></primary></indexterm>
					<indexterm><primary><varname>periods</varname></primary></indexterm>
					<para>Get the periods</para>
					<para><varname>spans(spanset): span[]</varname></para>
					<para><varname>periods(periodset): period[]</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT spans(floatspanset '{[1,3),[4,4],[6,7)}');
-- {"[1,3)","[4,4]","[6,7)"}
SELECT periods(periodset '{[2001-01-01, 2001-01-03), [2001-01-04, 2001-01-04],
  [2001-01-05, 2001-01-06)}');
-- {"[2001-01-01,2001-01-03)", "[2001-01-04,2001-01-04]", "[2001-01-05,2001-01-06)"}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id ="modification_time_tyes">
			<title>Modification Functions</title>

			<itemizedlist>
				<listitem id="setspan_shift">
					<indexterm><primary><varname>shift</varname></primary></indexterm>
					<para>Shift the time value by an interval</para>
					<para><varname>shift({timestampset,period,periodset},interval): {timestampset,period,periodset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);
-- {2001-01-02, 2001-01-04, 2001-01-06}
SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);
-- [2001-01-02, 2001-01-04]
SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day'::interval);
-- {[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}
</programlisting>
				</listitem>

			<listitem id="setspan_tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Scale the time value to an interval. If the time span of the time value is zero (for example, for a singleton timestamp set), the result is the time value. The given interval must be strictly greater than zero.</para>
				<para><varname>tscale({timestampset,period,periodset},interval): {timestampset,period,periodset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tscale(timestampset '{2001-01-01}', '1 day');
-- {2001-01-01}
SELECT tscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '2 days');
-- {2001-01-01, 2001-01-02, 2001-01-03}
SELECT tscale(period '[2001-01-01, 2001-01-03]', '1 day');
-- [2001-01-01, 2001-01-02]
SELECT tscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}', '1 day');
/* {[2001-01-01 00:00:00, 2001-01-01 12:00:00],
   [2001-01-01 18:00:00, 2001-01-02 00:00:00]} */
SELECT tscale(timestampset '{2001-01-01}', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem id="setspan_shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Shift and scale the time value to the two intervals. This function combines in a single step the functions <link linkend="setspan_shift"><varname>shift</varname></link> and <link linkend="setspan_tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale({timestampset,period,periodset},interval,interval):</varname></para>
				<para><varname>  {timestampset,period,periodset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT shiftTscale(timestampset '{2001-01-01}', '1 day', '1 day');
-- {2001-01-02}
SELECT shiftTscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day','2 days');
-- {2001-01-02, 2001-01-03, 2001-01-04}
SELECT shiftTscale(period '[2001-01-01, 2001-01-03]', '1 day', '1 day');
-- [2001-01-02, 2001-01-03]
SELECT shiftTscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day', '1 day');
/* {[2001-01-02 00:00:00, 2001-01-02 12:00:00],
   [2001-01-02 18:00:00, 2001-01-03 00:00:00]} */
</programlisting>
			</listitem>

				<listitem id="floatspan_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Round the bounds of a float span to a number of decimal places</para>
					<para><varname>round(floatspan,integer): floatspan</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT round(floatspan '[1.123456789,2.123456789)', 3);
-- [1.123,2.123)
SELECT round(floatspan '[1.123456789, inf)', 3);
-- [1.123,Infinity)
SELECT round(floatspanset '{[1.123456789, 2.123456789],[3.123456789,4.123456789]}', 3);
-- {[1.123, 2.123], [3.123, 4.123]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="setspan_comp_operators">
			<title>Comparison Operators</title>

			<para>The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right arguments be of the same type. Excepted equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on span and time types. For span values, the operators compare first the lower bound, then the upper bound. For timestamp set and period set values, the operators compare first the bounding periods, and if those are equal, they compare the first N instants or periods, where N is the minimum of the number of composing instants or periods of both values.</para>

			<para>The comparison operators available for the span and time types are given next. Recall that integer spans are always represented by their canonical form.</para>

			<itemizedlist>
				<listitem id="setspan_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Are the values equal?</para>
					<para><varname>{span,timestampset} = {span,timestampset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1,3]' = intspan '[1,4)';
-- true
SELECT floatspanset '{[1, 2),[2,3)}' = floatspanset '{[1,3)}';
-- true
SELECT period '[2001-01-01, 2001-01-04)' = period '[2001-01-01, 2001-01-04)';
-- true
SELECT timestampset '{2001-01-01, 2001-01-02}' = timestampset '{2001-01-01, 2001-01-04}';
-- false
</programlisting>
				</listitem>

				<listitem id="setspan_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>Are the values different?</para>
					<para><varname>{span,timestampset} &lt;&gt; {span,timestampset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT period '[2001-01-01, 2001-01-04)' &lt;&gt; period '[2001-01-03, 2001-01-05)';
-- true
SELECT timestampset '{2001-01-01, 2001-01-04}' &lt;&gt; timestampset '{2001-01-01, 2001-01-05}';
-- false
</programlisting>
				</listitem>

				<listitem id="setspan_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>Is the first value less than the second one?</para>
					<para><varname>{span,timestampset} &lt; {span,timestampset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanset '{[1,2],[3,4]}' &lt; intspanset '{[3, 4]}';
-- true
SELECT floatspan '[3, 4]' &lt; floatspan '(3, 4]';
-- true
SELECT period '[2001-01-01, 2001-01-04)' &lt; period '[2001-01-01, 2001-01-04]';
-- true
SELECT timestampset '{2001-01-01, 2001-01-04}' &lt; timestampset '{2001-01-01, 2001-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>Is the first value greater than the second one?</para>
					<para><varname>{span,timestampset} &gt; {span,timestampset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[3, 4]' &gt; floatspan '[3, 4)';
-- true
SELECT period '[2001-01-03, 2001-01-04)' &gt; period '[2001-01-02, 2001-01-05)';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>Is the first value less than or equal to the second one?</para>
					<para><varname>{span,timestampset} &lt;= {span,timestampset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspanset '{[1, 4)}' &lt;= floatspanset '{[1, 5), [6, 7)}';
-- true
SELECT periodset '{[2001-01-01, 2001-01-04)}' &lt;=
  periodset '{[2001-01-01, 2001-01-05), [2001-01-06, 2001-01-07)}';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>Is the first value greater than or equal to the second one?</para>
					<para><varname>{span,timestampset} &gt;= {span,timestampset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspanset '{[1, 4)}' &gt;= intspanset '{[1, 5), [6, 7)}';
-- false
SELECT period '[2001-01-03, 2001-01-05)' &gt;= period '[2001-01-03, 2001-01-04)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="setspan_set_operators">
			<title>Set Operators</title>

			<para>The span and time types have associated set operators, namely union, difference, and intersection, which are represented, respectively by <varname>+</varname>, <varname>-</varname>, and <varname>*</varname>. The set operators for the span and time types are given next.</para>

			<itemizedlist>
				<listitem id="setspan_union">
					<indexterm><primary><varname>+</varname></primary></indexterm>
					<para>Union of span or time values</para>
					<para><varname>{span,timestampset} + {span,timestampset}: {span,timestampset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)' + intspan '[3, 5)';
-- [1, 5)
SELECT floatspan '[1, 3)' + floatspan '[4, 5)';
-- {[1, 3), [4, 5)}
SELECT period '[2011-01-01, 2011-01-03)' + period '[2011-01-04, 2011-01-05)';
-- {[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}
SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +
  timestampset '{2011-01-03, 2011-01-06}';
-- {2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}
SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +
  period '[2011-01-03, 2011-01-04)';
-- {[2011-01-01, 2011-01-05)}
</programlisting>
				</listitem>

				<listitem id="setspan_difference">
					<indexterm><primary><varname>-</varname></primary></indexterm>
					<para>Difference of span or time values</para>
					<para><varname>{span,timestampset} - {span,timestampset}: {span,timestampset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 5]' - intspan '[3, 6]';
-- [1, 3)
SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';
-- [2011-01-01, 2011-01-03)
SELECT floatspan '[1, 5]' - floatspan '[3, 4]';
-- {[1, 3), (4, 5]}
SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'
-- {[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}
SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -
  periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05],
  [2011-01-08, 2011-01-09]}';
/* {[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],
   [2011-01-07,2011-01-08), (2011-01-09,2011-01-10]} */
</programlisting>
				</listitem>

				<listitem id="setspan_intersection">
					<indexterm><primary><varname>*</varname></primary></indexterm>
					<para>Intersection of span or time values</para>
					<para><varname>{span,timestampset} * {span,timestampset}: {span,timestampset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 5)' * intspan '[3, 6)';
-- [3, 5)
SELECT floatspanset '{[1, 5),[6, 8)}' * floatspan '[1, 6)';
-- {[1, 5)}
SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';
-- {2011-01-03}
SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';
-- [2011-01-03, 2011-01-05)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="setspan_topo_operators">
			<title>Topological Operators</title>
			<para>The topological operators available for the span and time types are given next.</para>

			<itemizedlist>
				<listitem id="setspan_overlaps">
					<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
					<para>Do the values overlap (have values in common)?</para>
					<para><varname>numspan &amp;&amp; numspan: boolean</varname></para>
					<para><varname>{timestampset,period,periodset} &amp;&amp; {timestampset,period,periodset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[1, 3)' &amp;&amp; intspan '[2, 4)';
-- true
SELECT floatspan '[1, 3)' &amp;&amp; floatspan '[3, 4)';
-- false
SELECT floatspanset '{[1, 5),[6, 8)}' &amp;&amp; floatspan '[1, 6)';
-- true
SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_contains">
					<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
					<para>Does the first value contain the second one?</para>
					<para><varname>numspan @&gt; {numspan,number}: boolean</varname></para>
					<para><varname>{timestampset,period,periodset} @&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[1, 5]' @&gt; floatspan '[2, 5)';
-- true
SELECT floatspanset '{[1, 2),(2, 3)}' @&gt; 2.0;
-- false
SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_containedby">
					<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
					<para>Is the first value contained by the second one?</para>
					<para><varname>{numspan,number} &lt;@ numspan: boolean</varname></para>
					<para><varname>time &lt;@ {timestampset,period,periodset}: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT floatspan '[2, 5]' &lt;@ floatspan '[1, 5)';
-- false
SELECT floatspanset '{[1,2],[3,4]}' &lt;@ floatspan '[1, 6]';
-- true
SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_adjacent">
					<indexterm><primary><varname>-|-</varname></primary></indexterm>
					<para>Is the first value adjacent to the second one?</para>
					<para><varname>{numspan,number} -|- {numspan,number}: boolean</varname></para>
					<para><varname>time -|- time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[2, 6)' -|- intspan '[6, 7)';
-- true
SELECT floatspan '[2, 5)' -|- floatspan '(5, 6)';
-- false
SELECT floatspanset '{[2, 3],[4, 5)}' -|- floatspan '(5, 6)';
-- true
SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';
-- true
SELECT periodset '{[2001-01-01, 2001-01-02]}' -|- period '[2001-01-02, 2001-01-03)';
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="setspan_relpos_operators">
			<title>Relative Position Operators</title>
			<para>The relative position operators available for span and time types are given next. Notice that the operators for time types have an additional `<varname>#</varname>' to distinguish them from the operators for number types.</para>

			<itemizedlist>
				<listitem id="setspan_left">
					<indexterm><primary><varname>&lt;&lt;</varname></primary></indexterm>
					<indexterm><primary><varname>&lt;&lt;#</varname></primary></indexterm>
					<para>Is the first value strictly left of the second one?</para>
					<para><varname>{number,span} &lt;&lt; {number,span}: boolean</varname></para>
					<para><varname>time &lt;&lt;# time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &lt;&lt; 20;
-- true
SELECT intspanset '{[15, 17],[18, 20)}' &lt;&lt; 20;
-- true
SELECT floatspan '[15, 20)' &lt;&lt; floatspan '(15, 20)';
-- false
SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_right">
					<indexterm><primary><varname>&gt;&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>#&gt;&gt;</varname></primary></indexterm>
					<para>Is the first value strictly to the right of the second one?</para>
					<para><varname>{number,span} &gt;&gt; {number,span}: boolean</varname></para>
					<para><varname>time #&gt;&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &gt;&gt; 10;
-- true
SELECT floatspan '[15, 20)' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT floatspanset '{[15, 17], [18, 20)}' &gt;&gt; floatspan '[5, 10]';
-- true
SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt;
  periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';
-- true
</programlisting>
				</listitem>

				<listitem id="setspan_overleft">
					<indexterm><primary><varname>&amp;&lt;</varname></primary></indexterm>
					<indexterm><primary><varname>&amp;&lt;#</varname></primary></indexterm>
					<para>Is the first value not to the right of the second one?</para>
					<para><varname>{number,span} &amp;&lt; {number,span}: boolean</varname></para>
					<para><varname>time &amp;&lt;# time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&lt; 18;
-- false
SELECT intspanset '{[15, 16],[17, 18)}' &amp;&lt; 18;
-- true
SELECT floatspan '[15, 20)' &amp;&lt; floatspan '[10, 20]';
-- true
SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';
-- false
</programlisting>
				</listitem>

				<listitem id="setspan_overright">
					<indexterm><primary><varname>&amp;&gt;</varname></primary></indexterm>
					<indexterm><primary><varname>#&amp;&gt;</varname></primary></indexterm>
					<para>Is the first value not to the left of the second one?</para>
					<para><varname>{number,span} &amp;&gt; {number,span}: boolean</varname></para>
					<para><varname>time #&amp;&gt; time: boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intspan '[15, 20)' &amp;&gt; 30;
-- true
SELECT floatspan '[1, 6]' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT floatspanset '{[1, 2],[3, 4]}' &amp;&gt; floatspan '(1, 3)';
-- false
SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Distance Operator</title>

			<para>The distance operator <varname>&lt;-&gt;</varname> for span and time types consider the bounding span or period and returns a <varname>float</varname> value which is the smallest distance between the two values. In the case of periods it returns the number of seconds between the two time values. The distance operator can also be used for nearest neighbor searches using a GiST or an SP-GiST index (see <xref linkend="indexing_time_types" />).</para>

			<itemizedlist>
				<listitem id="smallest_distance_time">
					<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
					<para>Get the smallest distance ever</para>
					<para><varname>{number,span} &lt;-&gt; {number,span}: float</varname></para>
					<para><varname>time &lt;-&gt; time: float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT 3 &lt;-&gt; intspan '(5, 7]';
-- 3
SELECT floatspan '[1, 3]' &lt;-&gt; floatspan '(5.5, 7]';
-- 2.5
SELECT floatspan '[1, 3]' &lt;-&gt; floatspanset '{(5.5, 7],[8, 9]}';
-- 2.5
SELECT period '[2001-01-02, 2001-01-06)' &lt;-&gt; timestamptz '2001-01-07';
-- 86400
SELECT timestampset '{2001-01-01, 2001-01-03, 2001-01-05}' &lt;-&gt;
  timestampset '{2001-01-02, 2001-01-04}';
--  0
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Aggregate Functions</title>

			<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant in the <emphasis>union</emphasis> of the temporal extents of the values to aggregate. In contrast, recall that all other functions manipulating time types compute the value of the function at every instant in the <emphasis>intersection</emphasis> of the temporal extents of the arguments.</para>

			<para>The temporal aggregate functions are the following ones:</para>
			<itemizedlist>
				<listitem><para>Function <varname>tcount</varname> generalizes the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available objects (for example, number of periods). Function <varname>tcount</varname> returns a temporal integer (see <xref linkend="temporal_types" />). The function has two optional parameters that specify the granularity (an <varname>interval</varname>) and the origin of time (a <varname>timestamptz</varname>). When these parameters are given, the temporal count is computed at time buckets of the given granularity (see <xref linkend="multidimensional_tiling" />).</para></listitem>
				<listitem><para>Function <varname>extent</varname> returns a bounding span or period that encloses a set of span or time values.</para></listitem>
			</itemizedlist>

			<para>Union is a very useful operation for time types. As we have seen in <xref linkend="setspan_set_operators" />, we can compute the union of two time values using the <varname>+</varname> operator. However, it is also very useful to have an aggregate version of the union operator for combining an arbitrary number of values. Function <varname>tunion</varname> can be used for this purpose.
			</para>

			<itemizedlist>
				<listitem id="setspan_tcount">
					<indexterm><primary><varname>tcount</varname></primary></indexterm>
					<para>Temporal count</para>
					<para><varname>tcount(time): {tint_seq,tint_seqset}</varname></para>
					<para><varname>tcount(time, interval, timestamptz): {tint_seq,tint_seqset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tcount(ts) FROM times;
-- {2@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-04, 1@2000-01-05, 1@2000-01-06}
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02), [2000-01-03, 2000-01-04)}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04), [2000-01-05, 2000-01-06)}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06)}'
)
SELECT tcount(ps) FROM periods;
-- {[2@2000-01-01, 3@2000-01-03, 1@2000-01-04, 2@2000-01-05, 2@2000-01-06)}
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02), [2000-01-03, 2000-01-04)}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04), [2000-01-05, 2000-01-06)}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06)}'
)
SELECT tcount(ps, '2 days', '2000-01-01') FROM periods;
-- {[3@2000-01-01, 2@2000-01-05, 2@2000-01-07)}
</programlisting>
				</listitem>

				<listitem id="setspan_extent">
					<indexterm><primary><varname>extent</varname></primary></indexterm>
					<para>Bounding span or period</para>
					<para><varname>extent({span,timestampset}): span</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH spans(r) AS (
  SELECT floatspan '[1, 4)' UNION
  SELECT floatspan '(5, 8)' UNION
  SELECT floatspan '(7, 9)'
)
SELECT extent(r) FROM spans;
-- [1,9)
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT extent(ts) FROM times;
-- [2000-01-01, 2000-01-06]
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT extent(ps) FROM periods;
-- [2000-01-01, 2000-01-06]
</programlisting>
				</listitem>

				<listitem id="tunion">
					<indexterm><primary><varname>tunion</varname></primary></indexterm>
					<para>Temporal union</para>
					<para><varname>tunion({timestampset,period,periodset}): {timestampset,periodset}</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tunion(ts) FROM times;
-- {2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05, 2000-01-06}
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-03], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-07, 2000-01-08]}'
)
SELECT tunion(ps) FROM periods;
-- {[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06], [2000-01-07, 2000-01-08]}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id ="indexing_time_types">
		<title>Indexing of Time and Span Types</title>

		<para>GiST and SP-GiST indexes can be created for table columns of the span and time types. The GiST index implements an R-tree while the SP-GiST index implements a quad-tree. An example of creation of a GiST index in a column <varname>During</varname> of type <varname>period</varname> in a table <varname>Reservation</varname> is as follows:
			<programlisting language="sql" xml:space="preserve">
CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,
  During period);
CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);
</programlisting>
		</para>
		<para>A GiST or an SP-GiST index can accelerate queries involving the following operators: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>&amp;&lt;#</varname>, <varname>#&amp;&gt;</varname>, and <varname>&lt;-&gt;</varname>.</para>
		<para>In addition, B-tree indexes can be created for table columns of a span or time type. For these index types, basically the only useful operation is equality. There is a B-tree sort ordering defined for values of span time types with corresponding <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname>, and <varname>&gt;=</varname> operators, but the ordering is rather arbitrary and not usually useful in the real world. The B-tree support is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>
		<para>Finally, hash indexes can be created for table columns of a span or time type. For these types of indexes, the only operation defined is equality.</para>
	</sect1>
</chapter>
