<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="temporal_types_analytics">
	<title>Temporal Types: Analytics Operations</title>

	<sect1 id="temporal_types_simplification">
		<title>Simplification</title>
		<itemizedlist>
			<listitem id="minDistSimplify">
				<indexterm><primary><varname>minDistSimplify</varname></primary></indexterm>
				<indexterm><primary><varname>minTimeDeltaSimplify</varname></primary></indexterm>
				<para>Simplify a temporal float or a temporal point ensuring that consecutive values are at least a certain distance or time interval apart &Z_support; &geography_support;</para>
				<para><varname>minDistSimplify({tfloat,tpoint},mindist float) → {tfloat,tpoint}</varname></para>
				<para><varname>minTimeDeltaSimplify({tfloat,tpoint},mint interval) → {tfloat,tpoint}</varname></para>
				<para>In the case of temporal points, the distance is specified in the units of the coordinate system. Notice that simplification applies only to temporal sequences or sequence sets with linear interpolation. In all other cases, a copy of the given temporal value is returned.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT minDistSimplify(tfloat '[1@2000-01-01,2@2000-01-02,3@2000-01-04,4@2000-01-05]', 1);
-- [1@2000-01-01, 3@2000-01-04]
SELECT asText(minDistSimplify(tgeompoint '[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02, Point(3 3 3)@2000-01-04, Point(5 5 5)@2000-01-05)', sqrt(3)));
-- [POINT Z (1 1 1)@2000-01-01, POINT Z (3 3 3)@2000-01-04, POINT Z (5 5 5)@2000-01-05)
SELECT asText(minDistSimplify(tgeompoint '[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02, Point(3 3 3)@2000-01-04, Point(4 4 4)@2000-01-05)', sqrt(3)));
-- [POINT Z (1 1 1)@2000-01-01, POINT Z (3 3 3)@2000-01-04]
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT minTimeDeltaSimplify(tfloat '[1@2000-01-01, 2@2000-01-02, 3@2000-01-04,
  4@2000-01-05]', '1 day');
-- [1@2000-01-01, 3@2000-01-04]
SELECT asText(minTimeDeltaSimplify(tgeogpoint '[Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02, Point(3 3 3)@2000-01-04, Point(5 5 5)@2000-01-05)', '1 day'));
-- [POINT Z (1 1 1)@2000-01-01, POINT Z (3 3 3)@2000-01-04]
</programlisting>
			</listitem>

			<listitem id="DouglasPeuckerSimplify">
				<indexterm><primary><varname>maxDistSimplify</varname></primary></indexterm>
				<indexterm><primary><varname>DouglasPeuckerSimplify</varname></primary></indexterm>
				<para>Simplify a temporal float or a temporal point using the <ulink url="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Douglas-Peucker algorithm</ulink> &Z_support;</para>
				<para><varname>maxDistSimplify({tfloat,tgeompoint},maxdist float,syncdist=true) →</varname></para>
				<para><varname>  {tfloat,tgeompoint}</varname></para>
				<para><varname>DouglasPeuckerSimplify({tfloat,tgeompoint},maxdist float,syncdist=true) →</varname></para>
				<para><varname>  {tfloat,tgeompoint}</varname></para>
				<para>The difference between the two functions is that <varname>maxDistSimplify</varname> uses a single-pass version of the algorithm whereas <varname>DouglasPeuckerSimplify</varname> uses the standard recursive algorithm.</para>
				<para>The function removes values or points that are less than or equal to the distance passed as second argument. In the case of temporal points, the distance is specified in the units of the coordinate system. The third argument applies only for temporal points and specifies whether the spatial or the synchronized distance is used. Notice that simplification applies only to temporal sequences or sequence sets with linear interpolation. In all other cases, a copy of the given temporal value is returned.</para>
				<programlisting language="sql" xml:space="preserve">
-- Only synchronous distance for temporal floats
SELECT maxDistSimplify(tfloat '[1@2000-01-01, 2@2000-01-02, 1@2000-01-03, 3@2000-01-04,
  1@2000-01-05]', 1, false);
-- [1@2000-01-01, 1@2000-01-03, 3@2000-01-04, 1@2000-01-05]
-- Synchronous distance by default for temporal points
SELECT asText(maxDistSimplify(tgeompoint '[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(3 1)@2000-01-03, Point(3 3)@2000-01-05, Point(5 1)@2000-01-06]', 2));
-- [POINT(1 1)@2000-01-01, POINT(3 3)@2000-01-05, POINT(5 1)@2000-01-06]
-- Spatial distance
SELECT asText(maxDistSimplify(tgeompoint '[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(3 1)@2000-01-03, Point(3 3)@2000-01-05, Point(5 1)@2000-01-06]', 2, false));
-- [POINT(1 1)@2000-01-01, POINT(5 1)@2000-01-06]
</programlisting>
				<programlisting language="sql" xml:space="preserve">
-- Spatial vs synchronized Euclidean distance
SELECT asText(DouglasPeuckerSimplify(tgeompoint '[Point(1 1)@2000-01-01,
  Point(6 1)@2000-01-06, Point(7 4)@2000-01-07]', 2.3, false));
-- [POINT(1 1)@2000-01-01, POINT(7 4)@2000-01-07]
SELECT asText(DouglasPeuckerSimplify(tgeompoint '[Point(1 1)@2000-01-01,
  Point(6 1)@2000-01-06, Point(7 4)@2000-01-07]', 2.3, true));
-- [POINT(1 1)@2000-01-01, POINT(6 1)@2000-01-06, POINT(7 4)@2000-01-07]
</programlisting>
				<para>The difference between the spatial and the synchronized distance is illustrated in the last two examples above and in <xref linkend="dist_vs_sed" />. In the first example, which uses the spatial distance, the second instant is removed since the perperdicular distance between <varname>POINT(6 1)</varname> and the line defined by <varname>POINT(1 1)</varname> and <varname>POINT(7 4)</varname> is equal to 2.23. On the contrary, in the second example the second instant is kept since the projection of <varname>Point(6 2)</varname> at timestamp <varname>2000-01-06</varname> over the temporal line segment results in <varname>Point(6 3.5)</varname> and the distance between the original point and its projection is 2.5.</para>
				<figure id="dist_vs_sed" float="start">
					<title>Difference between the spatial and the synchronous distance.</title>
					<mediaobject>
						<imageobject><imagedata scale='100' fileref='images/dist_vs_sed.pdf' /></imageobject>
						<imageobject><imagedata scale='100' fileref='images/dist_vs_sed.svg' /></imageobject>
						<imageobject><imagedata scale='100' fileref='images/dist_vs_sed.png' /></imageobject>
					</mediaobject>
				</figure>
				<para>A typical use for the <varname>DouglasPeuckerSimplify</varname> function is to reduce the size of a dataset, in particular for visualization purposes. If the visualization is static, then the spatial distance should be preferred, if the visualization is dynamic or animated, the synchronized distance should be preferred.</para>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_types_reduction">
		<title>Reduction</title>
		<itemizedlist>
			<listitem id="tsample">
				<indexterm><primary><varname>tsample</varname></primary></indexterm>
				<para>Sample a temporal value with respect to an interval</para>
				<para><varname>tsample({tnumber,tgeompoint},duration interval,torigin timestamptz='2000-01-03') → </varname></para>
				<para><varname>  {tnumber,tgeompoint}</varname></para>
				<para>If the origin is not specified, it is set by default to Monday, January 3, 2000. The given interval must be strictly greater than zero. Notice that the result is a temporal instant or a temporal sequence with discrete interpolation.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT tsample(tint '{1@2000-01-01,5@2000-01-05}', '3 days', '2000-01-01');
-- {1@2000-01-01}
SELECT tsample(tfloat '[1@2000-01-01,5@2000-01-05]', '1 day', '2000-01-01');
-- {1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04, 5@2000-01-05}
SELECT tsample(tfloat '[1@2000-01-01,5@2000-01-05]', '3 days', '2000-01-01');
-- {1@2000-01-01, 4@2000-01-04}
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tsample(tgeompoint '[Point(1 1)@2000-01-01, Point(5 5)@2000-01-05]',
  '2 days', '2000-01-01'));
-- {POINT(1 1)@2000-01-01, POINT(3 3)@2000-01-03, POINT(5 5)@2000-01-05}
SELECT asText(tsample(tgeompoint '{[Point(1 1)@2000-01-01, Point(5 5)@2000-01-05],
  [Point(1 1)@2000-01-06, Point(5 5)@2000-01-08]}', '3 days', '2000-01-01'));
-- {POINT(1 1)@2000-01-01, POINT(4 4)@2000-01-04, POINT(3 3)@2000-01-07}
</programlisting>
				<para><xref linkend="fig_tsample" /> illustrates the sampling of temporal floats with various interpolations. As shown in the figure, the sampling operation is best suited for temporal values with continuous interpolation.</para>
				<figure id="fig_tsample" float="start">
					<title>Sampling of temporal floats with discrete, step, and linear interpolation.</title>
					<mediaobject>
						<imageobject><imagedata format="PDF" scale='75' fileref="images/tsample.pdf"/></imageobject>
						<imageobject><imagedata format="SVG" scale='75' fileref="images/tsample.svg"/></imageobject>
						<imageobject><imagedata format="PNG" scale='75' fileref="images/tsample.png"/></imageobject>
					</mediaobject>
				</figure>
			</listitem>

			<listitem id="tprecision">
				<indexterm><primary><varname>tprecision</varname></primary></indexterm>
				<para>Reduce the temporal precision of a temporal value with respect to an interval computing the time-weighted average/centroid in each time bucket</para>
				<para><varname>tprecision({tnumber,tgeompoint},duration interval,torigin timestamptz='2000-01-03')</varname></para>
				<para><varname> → {tnumber,tpoint}</varname></para>
				<para>If the origin is not specified, it is set by default to Monday, January 3, 2000. The given interval must be strictly greater than zero.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT tprecision(tint '[1@2000-01-01,5@2000-01-05,1@2000-01-09]','1 day',
  '2000-01-01');
-- Interp=Step;[1@2000-01-01, 5@2000-01-05, 1@2000-01-09]
SELECT tprecision(tfloat '[1@2000-01-01,5@2000-01-05,1@2000-01-09)','1 day',
  '2000-01-01');
-- [1.5@2000-01-01, 4.5@2000-01-04, 4.5@2000-01-05, 1.5@2000-01-08]
SELECT tprecision(tfloat '[1@2000-01-01,5@2000-01-05,1@2000-01-09]','1 day',
  '2000-01-01');
-- [1.5@2000-01-01, 4.5@2000-01-04, 4.5@2000-01-05, 1.5@2000-01-08, 1@2000-01-09]
SELECT tprecision(tfloat '[1@2000-01-01,5@2000-01-05,1@2000-01-09)','2 days',
  '2000-01-01');
-- [2@2000-01-01, 4@2000-01-03, 4@2000-01-05, 2@2000-01-07]
</programlisting>
				<programlisting language="sql" xml:space="preserve">
SELECT asText(tprecision(tgeompoint '[Point(1 1)@2000-01-01, Point(5 5)@2000-01-05,
  Point(1 1)@2000-01-09)', '1 day', '2000-01-01'));
/* [POINT(1.5 1.5)@2000-01-01, POINT(4.5 4.5)@2000-01-04, POINT(4.5 4.5)@2000-01-05,
   POINT(1.5 1.5)@2000-01-08] */
SELECT asText(tprecision(tgeompoint '[Point(1 1)@2000-01-01, Point(5 5)@2000-01-05,
  Point(1 1)@2000-01-09)', '2 days', '2000-01-01'));
/* [POINT(2 2)@2000-01-01, POINT(4 4)@2000-01-03, POINT(4 4)@2000-01-05,
   POINT(2 2)@2000-01-07] */
-- [POINT(1.5 1.5)@1999-12-31, POINT(3.5 3.5)@2000-01-02, POINT(3 3)@2000-01-04]
SELECT asText(tprecision(tgeompoint '[Point(1 1)@2000-01-01, Point(5 5)@2000-01-05,
  Point(1 1)@2000-01-09)', '4 days', '2000-01-01'));
-- [POINT(3 3)@2000-01-01, POINT(3 3)@2000-01-05]
</programlisting>
				<para>Changing the precision of a temporal value is akin to changing its <emphasis>temporal granularity</emphasis>, for example, from timestamps to hours or days, although the precision can be set to an arbitrary interval, such as 2 hours and 15 minutes. <xref linkend="fig_tprecision" /> illustrates a change of temporal precision for temporal floats with various interpolations.</para>
				<figure id="fig_tprecision" float="start">
					<title>Changing the precision of temporal floats with discrete, step, and linear interpolation.</title>
					<mediaobject>
						<imageobject><imagedata format="PDF" scale='75' fileref="images/tprecision.pdf"/></imageobject>
						<imageobject><imagedata format="SVG" scale='75' fileref="images/tprecision.svg"/></imageobject>
						<imageobject><imagedata format="PNG" scale='75' fileref="images/tprecision.png"/></imageobject>
					</mediaobject>
				</figure>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_types_similarity">
		<title>Similarity</title>
		<itemizedlist>
			<listitem id="hausdorffDistance">
				<indexterm><primary><varname>hausdorffDistance</varname></primary></indexterm>
				<para>Get the discrete <ulink url="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff distance</ulink> between two temporal values &Z_support; &geography_support;</para>
				<para><varname>hausdorffDistance({tnumber, tgeo}, {tnumber, tgeo}) → float</varname></para>
				<para>This function has a quadratic time complexity in the number of instants of the temporal values. Therefore, the function will require considerable time for temporal values with large number of instants.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT hausdorffDistance(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 0.5
SELECT round(hausdorffDistance(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 1.414214
</programlisting>
			</listitem>

			<listitem id="frechetDistance">
				<indexterm><primary><varname>frechetDistance</varname></primary></indexterm>
				<para>Get the discrete <ulink url="https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance">Fréchet distance</ulink> between two temporal values &Z_support; &geography_support;</para>
				<para><varname>frechetDistance({tnumber, tgeo}, {tnumber, tgeo}) → float</varname></para>
				<para>This function has a linear space complexity since only two rows of the distance matrix are allocated in memory. Nevertheless, its time complexity is quadratic in the number of instants of the temporal values. Therefore, the function will require considerable time for temporal values with large number of instants.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistance(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 0.5
SELECT round(frechetDistance(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 1.414214
</programlisting>
			</listitem>

			<listitem id="frechetDistancePath">
				<indexterm><primary><varname>frechetDistancePath</varname></primary></indexterm>
				<para>Get the correspondence pairs between two temporal values with respect to the discrete Fréchet distance &Z_support; &geography_support; &SRF;</para>
				<para><varname>frechetDistancePath({tnumber, tgeo}, {tnumber, tgeo}) → {(i,j)}</varname></para>
				<para>The result is a set of pairs <varname>(i,j)</varname>. This function requires to allocate in memory a distance matrix whose size is quadratic in the number of instants of the temporal values. Therefore, the function will fail for temporal values with large number of instants depending on the available memory.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT frechetDistancePath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT frechetDistancePath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarp">
				<indexterm><primary><varname>dynamicTimeWarp</varname></primary></indexterm>
				<para>Get the <ulink url="https://en.wikipedia.org/wiki/Dynamic_time_warping">Dynamic Time Warp</ulink> (DTW) distance between two temporal values &Z_support; &geography_support;</para>
				<para><varname>dynamicTimeWarp({tnumber, tgeo}, {tnumber, tgeo}) → float</varname></para>
				<para>This function has a linear space complexity since only two rows of the distance matrix are allocated in memory. Nevertheless, its time complexity is quadratic in the number of instants of the temporal values. Therefore, the function will require considerable time for temporal values with large number of instants.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarp(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- 2
SELECT round(dynamicTimeWarp(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]')::numeric, 6);
-- 3.380776
</programlisting>
			</listitem>

			<listitem id="dynamicTimeWarpPath">
				<indexterm><primary><varname>dynamicTimeWarpPath</varname></primary></indexterm>
				<para>Get the correspondence pairs between two temporal values with respect to the discrete Fréchet distance &Z_support; &geography_support; &SRF;</para>
				<para><varname>dynamicTimeWarpPath({tnumber, tgeo}, {tnumber, tgeo}) → {(i,j)}</varname></para>
				<para>The result is a set of pairs <varname>(i,j)</varname>. This function requires to allocate a distance matrix which is quadratic in the size of the number of instants of the temporal values. Therefore, memory allocation will fail for temporal values with large number of instants.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT dynamicTimeWarpPath(tfloat '[1@2001-01-01, 3@2001-01-03, 1@2001-01-06]',
 tfloat '[1@2001-01-01, 1.5@2001-01-02, 2.5@2001-01-03, 1.5@2001-01-04, 1.5@2001-01-05]');
-- (0,0)
-- (1,0)
-- (2,1)
-- (3,2)
-- (4,2)
SELECT dynamicTimeWarpPath(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03,
  Point(1 1)@2001-01-05]', tgeompoint '[Point(1.1 1.1)@2001-01-01,
  Point(2.5 2.5)@2001-01-02, Point(4 4)@2001-01-03, Point(3 3)@2001-01-04,
  Point(1.5 2)@2001-01-05]');
-- (0,0)
-- (1,1)
-- (2,1)
-- (3,1)
-- (4,2)
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="temporal_types_tiling">
		<title>Multidimensional Tiling</title>
		<para>
			Multidimensional tiling is the mechanism used to partition the domain of temporal values in buckets or tiles of varying number of dimensions. In the case of a single dimension, the domain can be partitioned by value or by time using buckets of the same size or duration, respectively. For temporal numbers, the domain can be partitioned in two-dimensional tiles of the same size for the value dimension and the same duration for the time dimension. For temporal points, the domain can be partitioned in space in two- or three-dimensional tiles, depending on the number of dimensions of the spatial coordinates. Finally, for temporal points, the domain can be partitioned in space and time using three- or four-dimensional tiles. Furthermore, the temporal values can also be fragmented according to a multidimensional grid defined over the underlying domain.
		</para>

		<para>
			Multidimensional tiling can be used for various purposes. For example, it can be used for computing multidimensional histograms, where the temporal values are aggregated according to the underlying partition of the domain. On the other hand, multidimensional tiling can be used for distributing a dataset across a cluster of servers, where each server contains a partition of the dataset. The advantage of this partition mechanism is that it preserves proximitity in space and time, unlike the traditional hash-based partition mechanisms used in big data environments.
		</para>

		<figure id="tiling" float="start">
			<title>Multidimensional tiling for temporal floats.</title>
			<mediaobject>
				<imageobject><imagedata format="PDF" scale='75' fileref="images/tiling.pdf"/></imageobject>
				<imageobject><imagedata format="SVG" scale='75' fileref="images/tiling.svg"/></imageobject>
				<imageobject><imagedata format="PNG" scale='75' fileref="images/tiling.png"/></imageobject>
			</mediaobject>
		</figure>

		<para>
			<xref linkend="tiling" /> illustrates multidimensional tiling for temporal floats. The two-dimensional domain is split into tiles having the same size for the value dimension and the same duration for the time dimension. Suppose that this tiling scheme is used for distribute a dataset across a cluster of six servers, as suggested by the gray pattern in the figure. In this case, the values are fragmented so each server will receive the data of contiguous tiles. This implies in particular that four nodes will receive one fragment of the temporal float depicted in the figure. One advantage of this distribution of data based on multidimensional tiling is that it reduces the data that needs to be exchanged between nodes when processing queries, a process typically referred to as <emphasis>reshuffling</emphasis>.
		</para>

		<para>Many of the functions in this section are <emphasis>set-returning functions</emphasis> (also known as a <emphasis>table functions</emphasis>) since they typically return more than one value. In this case, the functions are marked with the &SRF; symbol.</para>

		<sect2 id="bucket_functions">
			<title>Bucket Functions</title>

			<itemizedlist>
				<listitem id="bucketList">
					<indexterm><primary><varname>bucketList</varname></primary></indexterm>
					<para>Return a set of buckets that cover the span with buckets of the same size or duration aligned with the origin &SRF;</para>
					<para><varname>bucketList(bounds unitspan,size number,origin number=0) → {(index,span)}</varname></para>
					<para><varname>bucketList(bounds tstzspan,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  {(index,span)}</varname></para>
					<para>The result is a set of pairs <varname>(index,span)</varname>. If the origin is not specified, it is set by default to 0 for number spans and Monday, January 3, 2000 for periods. The indices start by 1.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(intspan '[15, 25]', 2) AS bl) t;
-- 1 | [14,16)
-- 2 | [16,18)
-- 3 | [18,20)
-- ...
SELECT bucketList(floatspan '[-10, -1]', 2.5, -7);
-- (1,"[-12, -9.5)")
-- (2,"[-9.5, -7)")
-- (3,"[-7, -4.5)")
-- ...
SELECT (bl).index, (bl).span
FROM (SELECT bucketList(tstzspan '[2000-01-15, 2000-01-25]','2 days') AS bl) t;
-- 1 | [2000-01-15, 2000-01-17)
-- 2 | [2000-01-17, 2000-01-19)
-- 3 | [2000-01-19, 2000-01-21)
-- ...
SELECT bucketList(tstzspan '[2000-01-15, 2000-01-25]', '2 days', '2000-01-02');
-- (1,"[2000-01-14, 2000-01-16)")
-- (2,"[2000-01-16, 2000-01-18)")
-- (3,"[2000-01-18, 2000-01-20)")
-- ...
</programlisting>
				</listitem>

				<listitem id="valueBucket">
					<indexterm><primary><varname>valueBucket</varname></primary></indexterm>
					<para> Return the start value of the bucket that contains the input number</para>
					<para><varname>valueBucket(value number,size number,origin number=0) → number</varname></para>
					<para>If the origin is not specified, it is set by default to 0.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT valueBucket(3, 2);
-- 2
SELECT valueBucket(3.5, 2.5, 1.5);
-- 1.5
</programlisting>
				</listitem>

				<listitem id="spanBucket">
					<indexterm><primary><varname>spanBucket</varname></primary></indexterm>
					<para>Return the span in the bucket space that contains the input number</para>
					<para><varname>spanBucket(value number,size number,origin number=0) → span</varname></para>
					<para>If the origin is not specified, it is set by default to 0.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT spanBucket(2, 2);
-- [2,4)
SELECT spanBucket(2, 2, 1);
-- [1,3)
SELECT spanBucket(2, 2.5);
-- [0,2.5)
SELECT spanBucket(2, 2.5, 1.5);
-- [1.5,4)
</programlisting>
				</listitem>

				<listitem id="timeBucket">
					<indexterm><primary><varname>timeBucket</varname></primary></indexterm>
					<para>Return the start timestamp of the bucket that contains the input timestamp</para>
					<para><varname>timeBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  timestamptz</varname></para>
					<para>If the origin is not specified, it is set by default to Monday, January 3, 2000.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days');
-- 2020-04-29 01:00:00+02
SELECT timeBucket(timestamptz '2020-05-01', interval '2 days', timestamptz '2020-01-01');
-- 2020-04-30 01:00:00+02
</programlisting>
				</listitem>

				<listitem id="periodBucket">
					<indexterm><primary><varname>periodBucket</varname></primary></indexterm>
					<para>Return the period in the bucket space that contains the input timestamp</para>
					<para><varname>periodBucket(time timestamptz,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  tstzspan</varname></para>
					<para>If the origin is not specified, it is set by default to Monday, January 3, 2000.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT periodBucket('2000-01-04', interval '1 week');
-- [2000-01-03, 2000-01-10)
SELECT periodBucket('2000-01-04', interval '1 week', '2000-01-07');
-- [1999-12-31, 2000-01-07)
</programlisting>
				</listitem>

			</itemizedlist>
		</sect2>

		<sect2 id="tile_functions">
			<title>Tile Functions</title>

			<itemizedlist>
				<listitem id="tileList">
					<indexterm><primary><varname>tileList</varname></primary></indexterm>
					<para>Return a set of tiles that covers the box with multidimensional tiles of the same size and duration &Z_support; &SRF;</para>
					<para><varname>tileList(bounds tbox,size float,duration interval,vorigin float=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03') → {(index,tile)}</varname></para>
					<para><varname>tileList(bounds stbox,xsize float,[ysize float,zsize float,] </varname></para>
					<para><varname>  sorigin geompoint='Point(0 0 0)') → {(index,tile)}</varname></para>
					<para><varname>tileList(bounds stbox,xsize float,[ysize float,zsize float,]duration interval,</varname></para>
					<para><varname>  sorigin geompoint='Point(0 0 0)',torigin timestamptz='2000-01-03') → {(index,tile)}</varname></para>
					<para>The result is a set of pairs <varname>(index,tile)</varname>. If the origin of the value and/or time dimensions are not specified, they are set by default to 0 or <varname>'Point(0 0 0)'</varname> for the value dimension (depending on the box type) and to Monday, January 3, 2000 for the time dimension.</para>
					<para>In the case of a spatiotemporal grid, <varname>ysize</varname> and <varname>zsize</varname> are optional, the size for the missing dimensions is assumed to be equal to <varname>xsize</varname>. The SRID of the tile coordinates is determined by the input box and the sizes are given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (gr).index, (gr).tile
FROM (SELECT tileList(tfloat '[15@2000-01-15, 25@2000-01-25]'::tbox, 2.0, '2 days')
  AS gr) t;
-- 1 | TBOX XT([14,16),[2000-01-15,2000-01-17))
-- 2 | TBOX XT([16,18),[2000-01-15,2000-01-17))
-- 3 | TBOX XT([18,20),[2000-01-15,2000-01-17))
-- ...
SELECT tileList(tfloat '[15@2000-01-15,25@2000-01-25]'::tbox, 2.0, '2 days', 11.5);
-- (1,"TBOX XT([13.5,15.5),[2000-01-15,2000-01-17))")
-- (2,"TBOX XT([15.5,17.5),[2000-01-15,2000-01-17))")
-- (3,"TBOX XT([17.5,19.5),[2000-01-15,2000-01-17))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0);
-- (1,"STBOX X((2,2),(4,4))")
-- (2,"STBOX X((4,2),(6,4))")
-- (3,"STBOX X((6,2),(8,4))")
-- ...
SELECT tileList(tgeompoint 'SRID=3812;[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3)');
-- (1,"SRID=3812;STBOX X((3,3),(5,5))")
-- (2,"SRID=3812;STBOX X((5,3),(7,5))")
-- (3,"SRID=3812;STBOX X((7,3),(9,5))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, geometry 'Point(3 3 3)');
-- (1,"STBOX Z((3,3,3),(5,5,5))")
-- (2,"STBOX Z((5,3,3),(7,5,5))")
-- (3,"STBOX Z((7,3,3),(9,5,5))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3)@2000-01-15,
  Point(15 15)@2000-01-25]'::stbox, 2.0, interval '2 days');
-- (1,"STBOX XT(((2,2),(4,4)),[2000-01-15,2000-01-17))")
-- (2,"STBOX XT(((4,2),(6,4)),[2000-01-15,2000-01-17))")
-- (3,"STBOX XT(((6,2),(8,4)),[2000-01-15,2000-01-17))")
-- ...
SELECT tileList(tgeompoint '[Point(3 3 3)@2000-01-15,
  Point(15 15 15)@2000-01-25]'::stbox, 2.0, '2 days', 'Point(3 3 3)', '2000-01-15');
-- (1,"STBOX ZT(((3,3,3),(5,5,5)),[2000-01-15,2000-01-17))")
-- (2,"STBOX ZT(((5,3,3),(7,5,5))),[2000-01-15,2000-01-17)")
-- (3,"STBOX ZT(((7,3,3),(9,5,5))),[2000-01-15,2000-01-17)")
-- ...
</programlisting>
				</listitem>

				<listitem id="tile">
					<indexterm><primary><varname>tile</varname></primary></indexterm>
					<para>Return the tile of the multidimensional grid that contains the value and the timestamp &Z_support;</para>
					<para><varname>tile(value float,time timestamptz,size float,duration interval,</varname></para>
					<para><varname>  vorigin float=0.0,torigin timestamptz='2000-01-03') → tbox</varname></para>
					<para><varname>tile(point geometry,xsize float,[ysize float,zsize float],</varname></para>
					<para><varname>  sorigin geompoint='Point(0 0 0)') → stbox</varname></para>
					<para><varname>tile(point geometry,time timestamptz,xsize float,[ysize float,zsize float,]duration</varname></para>
					<para><varname>  interval,sorigin geompoint='Point(0 0 0)',torigin timestamptz='2000-01-03') → stbox</varname></para>
					<para>If the origin of the value and/or time dimensions are not specified, they are set by default to 0 or <varname>Point(0 0 0)</varname> for the value dimension and Monday, January 3, 2000 for the time dimension, respectively.</para>
					<para>In the case of a spatiotemporal grid, <varname>ysize</varname> and <varname>zsize</varname> are optional, the size for the missing dimensions is assumed to be equal to <varname>xsize</varname>. The SRID of the tile coordinates is determined by the input point and the sizes are given in the units of the SRID. If the origin for the spatial coordinates is given, which must be a point, its dimensionality and SRID should be equal to the one of box, otherwise an error is raised.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tile(15, '2000-01-15', 2, interval '2 days');
-- TBOX XT([14,16),[2000-01-15,2000-01-17))
SELECT tile(15, '2000-01-15', 2, interval '2 days', 1, '2000-01-02');
-- TBOX XT([15,17),[2000-01-14,2000-01-16))
SELECT tile(geometry 'Point(1 1 1)', 2.0);
-- STBOX Z((0,0,0),(2,2,2))
SELECT tile(geometry 'Point(1 1)', '2000-01-01', 2.0, interval '2 days');
-- STBOX XT(((0,0),(2,2)),[2000-01-01, 2000-01-03))
SELECT tile(geometry 'Point(1 1)', '2000-01-01', 2.0, interval '2 days',
  'Point(1 1)', '2000-01-02');
-- STBOX XT(((1,1),(3,3)),[1999-12-31, 2000-01-02))
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="split_functions">
			<title>Split Functions</title>
			<para>These functions fragment a temporal value with respect to a sequence of buckets (see <xref linkend="bucket_functions" />) or tiles (see <xref linkend="tile_functions" />).</para>
			<itemizedlist>
				<listitem id="valueSplit">
					<indexterm><primary><varname>valueSplit</varname></primary></indexterm>
					<para>Fragment the temporal number with respect to span buckets &SRF;</para>
					<para><varname>valueSplit(tnumber,size number,origin number=0) → {(number,tnumber)}</varname></para>
					<para>The result is a set of pairs <varname>(number,tnumber)</varname>. If the origin of values is not specified, it is set by default to 0.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).tnumber
FROM (SELECT valueSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05, 10@2001-01-10]',
  2) AS sp) t;
--  0 | {[1@2001-01-01 00:00:00+01, 1@2001-01-02 00:00:00+01)}
--  2 | {[2@2001-01-02 00:00:00+01, 2@2001-01-05 00:00:00+01)}
--  4 | {[5@2001-01-05 00:00:00+01, 5@2001-01-10 00:00:00+01)}
-- 10 | {[10@2001-01-10 00:00:00+01]}
SELECT valueSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 2.0, 1.0);
-- (1,"{[1@2001-01-01 00:00:00+01, 3@2001-01-03 00:00:00+01)}")
-- (3,"{[3@2001-01-03 00:00:00+01, 5@2001-01-05 00:00:00+01)}")
-- (5,"{[5@2001-01-05 00:00:00+01, 7@2001-01-07 00:00:00+01)}")
-- (7,"{[7@2001-01-07 00:00:00+01, 9@2001-01-09 00:00:00+01)}")
-- (9,"{[9@2001-01-09 00:00:00+01, 10@2001-01-10 00:00:00+01)}")
</programlisting>
				</listitem>

				<listitem id="timeSplit">
					<indexterm><primary><varname>timeSplit</varname></primary></indexterm>
					<para>Fragment the temporal value with respect to time buckets &Z_support; &SRF;</para>
					<para><varname>timeSplit(ttype,duration interval,origin timestamptz='2000-01-03') → </varname></para>
					<para><varname>  {(time,temp)}</varname></para>
					<para>The result is a set of pairs <varname>(time,temp)</varname>. If the origin of time is not specified, it is set by default to Monday, January 3, 2000.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time, (ts).temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', '2 days') AS ts) t;
-- 2011-12-31 | [1@2001-01-01, 2@2001-01-02)
-- 2001-01-02 | [2@2001-01-02, 4@2001-01-04)
-- 2001-01-04 | [4@2001-01-04, 6@2001-01-06)
-- ...
SELECT (ts).time, astext((ts).temp) AS temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-10]',
  '2 days', '2001-01-01') AS ts) AS t;
-- 2001-01-01 | [POINT Z (1 1 1)@2001-01-01, POINT Z (3 3 3)@2001-01-03)
-- 2001-01-03 | [POINT Z (3 3 3)@2001-01-03, POINT Z (5 5 5)@2001-01-05)
-- 2001-01-05 | [POINT Z (5 5 5)@2001-01-05, POINT Z (7 7 7)@2001-01-07)
-- ...
</programlisting>
					<para>Notice that we can fragment a temporal value in cyclic (instead of linear) time buckets. The following two examples show how to fragment a temporal value by hour and by day of the week.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (ts).time::time as hour, merge((ts).temp) as temp
FROM (SELECT timeSplit(tfloat '[1@2001-01-01, 10@2001-01-03]', '1 hour') AS ts) t
GROUP BY hour ORDER BY hour;
/* 00:00:00 | {[1@2001-01-01 00:00:00+01, 1.1875@2001-01-01 01:00:00+01),
               [5.5@2001-01-02 00:00:00+01, 5.6875@2001-01-02 01:00:00+01)} */
/* 01:00:00 | {[1.1875@2001-01-01 01:00:00+01, 1.375@2001-01-01 02:00:00+01),
               [5.6875@2001-01-02 01:00:00+01, 5.875@2001-01-02 02:00:00+01)} */
/* 02:00:00 | {[1.375@2001-01-01 02:00:00+01, 1.5625@2001-01-01 03:00:00+01),
               [5.875@2001-01-02 02:00:00+01, 6.0625@2001-01-02 03:00:00+01)} */
/* 03:00:00 | {[1.5625@2001-01-01 03:00:00+01, 1.75@2001-01-01 04:00:00+01),
               [6.0625@2001-01-02 03:00:00+01, 6.25@2001-01-02 04:00:00+01)} */
/* ...  */
SELECT EXTRACT(DOW FROM (ts).time) as dow_no, TO_CHAR((ts).time, 'Dy') as dow,
  asText(round(merge((ts).temp), 2)) as temp
FROM (SELECT timeSplit(tgeompoint '[Point(1 1)@2001-01-01, Point(10 10)@2001-01-14)',
  '1 hour') AS ts) t
GROUP BY dow, dow_no ORDER BY dow_no;
/* 0 | Sun | {[POINT(1 1)@2001-01-01, POINT(1.69 1.69)@2001-01-02),
             [POINT(5.85 5.85)@2001-01-08, POINT(6.54 6.54)@2001-01-09)} */
/* 1 | Mon | {[POINT(1.69 1.69)@2001-01-02, POINT(2.38 2.38)@2001-01-03),
             [POINT(6.54 6.54)@2001-01-09, POINT(7.23 7.23)@2001-01-10)} */
/* 2 | Tue | {[POINT(2.38 2.38)@2001-01-03, POINT(3.08 3.08)@2001-01-04),
             [POINT(7.23 7.23)@2001-01-10, POINT(7.92 7.92)@2001-01-11)} */
/* ... */
</programlisting>
				</listitem>

				<listitem id="valueTimeSplit">
					<indexterm><primary><varname>valueTimeSplit</varname></primary></indexterm>
					<para>Fragment the temporal number with respect to the tiles in a value-time grid &SRF;</para>
					<para><varname>valueTimeSplit(tumber,size number,duration interval,vorigin number=0,</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03') → {(number,time,tnumber}</varname></para>
					<para>The result is a set of triples <varname>(number,time,tnumber)</varname>. If the origin of values and/or time are not specified, they are set by default to 0 and to Monday, January 3, 2000, respectively.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tint '[1@2001-01-01, 2@2001-01-02, 5@2001-01-05,
  10@2001-01-10]', 5, '5 days') AS sp) t;
--  0 | 2011-12-31 | [1@2001-01-01, 2@2001-01-02, 2@2001-01-05)
--  5 | 2001-01-05 | [5@2001-01-05, 5@2001-01-10)
-- 10 | 2001-01-10 | [10@2001-01-10]
SELECT (sp).number, (sp).time, (sp).tnumber
FROM (SELECT valueTimeSplit(tfloat '[1@2001-01-01, 10@2001-01-10)', 5.0, '5 days', 1.0,
  '2001-01-01') AS sp) t;
-- 1 | 2001-01-01 | [1@2001-01-01, 6@2001-01-06)
-- 6 | 2001-01-06 | [6@2001-01-06, 10@2001-01-10)
</programlisting>
				</listitem>

				<listitem id="spaceSplit">
					<indexterm><primary><varname>spaceSplit</varname></primary></indexterm>
					<para>Fragment the temporal point with respect to the tiles in a spatial grid &Z_support; &SRF;</para>
					<para><varname>spaceSplit(tgeompoint,xsize float,[ysize float,zsize float,]</varname></para>
					<para><varname>  origin geompoint='Point(0 0 0)',bitmatrix=true) → {(point,tpoint)}</varname></para>
					<para>The result is a set of pairs <varname>(point,tpoint)</varname>. If the origin of the space dimension is not specified, it is set by default to <varname>'Point(0 0 0)'</varname>. The arguments <varname>ysize</varname> and <varname>zsize</varname> are optional, the size for the missing dimensions is assumed to be equal to <varname>xsize</varname>. If the argument <varname>bitmatrix</varname> is not specified, then the computation will use a bit matrix to speed up the process.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0) AS sp) t;
-- POINT(0 0) | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | {[POINT(2 2)@2020-03-02, POINT(4 4)@2020-03-04)}
-- POINT(4 4) | {[POINT(4 4)@2020-03-04, POINT(6 6)@2020-03-06)}
-- ...
SELECT ST_AsText((sp).point) AS point, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, 'Point(1 1 1)') AS sp) t;
-- POINT Z(1 1 1) | {[POINT Z (1 1 1)@2020-03-01, POINT Z (3 3 3)@2020-03-03)}
-- POINT Z(3 3 3) | {[POINT Z (3 3 3)@2020-03-03, POINT Z (5 5 5)@2020-03-05)}
-- POINT Z(5 5 5) | {[POINT Z (5 5 5)@2020-03-05, POINT Z (7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
				<listitem id="spaceTimeSplit">
					<indexterm><primary><varname>spaceTimeSplit</varname></primary></indexterm>
					<para>Fragment the temporal point with respect to the tiles in a spatiotemporal grid &Z_support; &SRF;</para>
					<para><varname>spaceTimeSplit(tgeompoint,xsize float,[ysize float,ysize float,]</varname></para>
					<para><varname>  duration interval,sorigin geompoint='Point(0 0 0)',</varname></para>
					<para><varname>  torigin timestamptz='2000-01-03',bitmatrix=true) → {(point,time,tpoint)}</varname></para>
					<para>The result is a set of triples <varname>(point,time,tpoint)</varname>. If the origin of the space and time dimensions are not specified, they are set by default to <varname>'Point(0 0 0)'</varname> and Monday, January 3, 2000, respectively. The arguments <varname>ysize</varname> and <varname>zsize</varname> are optional, the size for the missing dimensions is assumed to be equal to <varname>xsize</varname>. If the argument <varname>bitmatrix</varname> is not specified, then the computation will use a bit matrix to speed up the process.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1)@2020-03-01, Point(10 10)@2020-03-10]',
  2.0, '2 days') AS sp) t;
-- POINT(0 0) | 2020-03-01 | {[POINT(1 1)@2020-03-01, POINT(2 2)@2020-03-02)}
-- POINT(2 2) | 2020-03-01 | {[POINT(2 2)@2020-03-02, POINT(3 3)@2020-03-03]}
-- POINT(2 2) | 2020-03-03 | {[POINT(3 3)@2020-03-03, POINT(4 4)@2020-03-04)}
-- ...
SELECT ST_AsText((sp).point) AS point, (sp).time, astext((sp).tpoint) AS tpoint
FROM (SELECT spaceTimeSplit(tgeompoint '[Point(1 1 1)@2020-03-01,
  Point(10 10 10)@2020-03-10]', 2.0, '2 days', 'Point(1 1 1)', '2020-03-01') AS sp) t;
-- POINT Z(1 1 1) | 2020-03-01 | {[POINT Z(1 1 1)@2020-03-01, POINT Z(3 3 3)@2020-03-03)}
-- POINT Z(3 3 3) | 2020-03-03 | {[POINT Z(3 3 3)@2020-03-03, POINT Z(5 5 5)@2020-03-05)}
-- POINT Z(5 5 5) | 2020-03-05 | {[POINT Z(5 5 5)@2020-03-05, POINT Z(7 7 7)@2020-03-07)}
-- ...
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

</chapter>
