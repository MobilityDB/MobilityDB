<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="temporal_network_points">
	<title>Temporal Network Points</title>

	<para>The temporal points that we have considered so far represent the movement of objects that can move freely on space since it is assumed that they can change their position from one location to the next one without any motion restriction. This is the case for animals and for flying objects such as planes or drones. However, in many cases, objects do not move freely in space but rather within spatially embedded networks such as routes or railways. In this case, it is necessary to take the embedded networks into account while describing the movements of these moving objects. Temporal network points account for these requirements.</para>

	<para>Compared with the free-space temporal points, network-based points have the following advantages:</para>
	<itemizedlist>
		<listitem>
			<para>Network points provide road constraints that reflect the real movements of moving objects.</para>
		</listitem>
		<listitem>
			<para>The geometric information is not stored with the moving point, but once and for all in the fixed networks. In this way, the location representations and interpolations are more precise.</para>
		</listitem>
		<listitem>
			<para>Network points are more efficient in terms of data storage, location update, formulation of query, as well as indexing. These are discussed later in this document.</para>
		</listitem>
	</itemizedlist>

	<para>Temporal network points are based on <ulink url="https://pgrouting.org/">pgRouting</ulink>, a PostgreSQL extension for developing network routing applications and doing graph analysis. Therefore, temporal network points asume that the underlying network is defined in a table named <varname>ways</varname>, which has at least three columns: <varname>gid</varname> containing the unique route identifier, <varname>length</varname> containing the route length, and <varname>the_geom</varname> containing the route geometry.</para>

	<para>There are two static network types, <varname>npoint</varname> (short for network point) and <varname>nsegment</varname> (short for network segment), which represent, respectively, a point and a segment of a route. An <varname>npoint</varname> value is composed of a route identifier and a float number in the range [0,1] determining a relative position of the route, where 0 corresponds to the begining of the route and 1 to the end of the route. An <varname>nsegment</varname> value is composed of a route identifier and two float numbers in the range [0,1] determining the start and end relative positions. A <varname>nsegment</varname> value whose start and end positions are equal corresponds to an <varname>npoint</varname> value.</para>

	<para>The <varname>npoint</varname> type serves as base type for defining the temporal network point type <varname>tnpoint</varname>. The <varname>tnpoint</varname> type has similar functionality as the temporal point type <varname>tgeompoint</varname> with the exception that it only considers two dimensions. Thus, all functions and operators described before for the <varname>tgeompoint</varname> type are also applicable for the <varname>tnpoint</varname> type. In addition, there are specific functions defined for the <varname>tnpoint</varname> type.</para>

	<sect1 id="static_network_types">
		<title>Static Network Types</title>

		<para>An <varname>npoint</varname> value is a couple of the form <varname>(rid,position)</varname> where <varname>rid</varname> is a <varname>bigint</varname> value representing a route identifier and <varname>position</varname> is a <varname>float</varname> value in the range [0,1] indicating its relative position. The values 0 and 1 of <varname>position</varname> denote, respectively, the starting and the ending position of the route. The road distance between an <varname>npoint</varname> value and the starting position of route with identifier <varname>rid</varname> is computed by multiplying <varname>position</varname> by length, where <varname>length</varname> is the route length. Examples of input of network point values are as follows:</para>
		<programlisting language="sql" xml:space="preserve">
SELECT npoint 'Npoint(76, 0.3)';
SELECT npoint 'Npoint(64, 1.0)';
</programlisting>

		<para>The constructor function for network points has one argument for the route identifier and one argument for the relative position. An example of a network point value defined with the constructor function is as follows:</para>
		<programlisting language="sql" xml:space="preserve">
SELECT npoint(76, 0.3);
</programlisting>

		<para>An <varname>nsegment</varname> value is a triple of the form <varname>(rid,startPosition,endPosition)</varname> where <varname>rid</varname> is a <varname>bigint</varname> value representing a route identifier and <varname>startPosition</varname> and <varname>endPosition</varname> are <varname>float</varname> values in the range [0,1] such that <varname>startPosition &le; endPosition</varname>. Semantically, a network segment represents a set of network points <varname>(rid,position)</varname> with <varname>startPosition &le; position &le; endPosition</varname>. If <varname>startPosition=0</varname> and <varname>endPosition=1</varname>, the network segment is equivalent to the entire route. If <varname>startPosition=endPosition</varname>, the network segment represents into a single network point. Examples of input of network point values are as follows:</para>
			<programlisting language="sql" xml:space="preserve">
SELECT nsegment 'Nsegment(76, 0.3, 0.5)';
SELECT nsegment 'Nsegment(64, 0.5, 0.5)';
SELECT nsegment 'Nsegment(64, 0.0, 1.0)';
SELECT nsegment 'Nsegment(64, 1.0, 0.0)';
-- converted to nsegment 'Nsegment(64, 0.0, 1.0)';
</programlisting>
		<para>As can be seen in the last example, the <varname>startPosition</varname> and <varname>endPosition</varname> values will be inverted to ensure that the condition <varname>startPosition &le; endPosition</varname> is always satisfied. The constructor function for network segments has one argument for the route identifier and two optional arguments for the start and end positions. Examples of network segment values defined with the constructor function are as follows:</para>
			<programlisting language="sql" xml:space="preserve">
SELECT nsegment(76, 0.3, 0.3);
SELECT nsegment(76); -- start and end position assumed to be 0 and 1 respectively
SELECT nsegment(76, 0.5); -- end position assumed to be 1
</programlisting>
		<para>Values of the <varname>npoint</varname> type can be converted to the <varname>nsegment</varname> type using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation as shown next.</para>
			<programlisting language="sql" xml:space="preserve">
SELECT npoint(76, 0.33)::nsegment;
</programlisting>

		<para>Values of static network types must satisfy several constraints so that they are well defined. These constraints are given next.</para>
		<itemizedlist>
			<listitem>
				<para>The route identifier <varname>rid</varname> must be found in column <varname>gid</varname> of table <varname>ways</varname>.</para>
			</listitem>
			<listitem>
				<para>The <varname>position</varname>, <varname>startPosition</varname>, and <varname>endPosition</varname> values must be in the range [0,1]. An error is raised whenever one of these constraints are not satisfied.</para>
			</listitem>
		</itemizedlist>
		<para>Examples of incorrect static network type values are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
-- incorrect rid value
SELECT npoint 'Npoint(87.5, 1.0)';
-- incorrect position value
SELECT npoint 'Npoint(87, 2.0)';
-- rid value not found in the ways table
SELECT npoint 'Npoint(99999999, 1.0)';
</programlisting>
		<para>We give next the functions and operators for the static network types.</para>

		<sect2 id="constructor_functions">
			<title>Constructor Functions</title>

			<itemizedlist>
				<listitem id="npoint">
					<indexterm><primary><varname>npoint</varname></primary></indexterm>
					<para>Constructor for network points</para>
					<para><varname>npoint(bigint,double precision): npoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT npoint(76, 0.3);
</programlisting>
				</listitem>

				<listitem id="nsegment">
					<indexterm><primary><varname>nsegment</varname></primary></indexterm>
					<para>Constructor for network segments</para>
					<para><varname>nsegment(bigint,double precision,double precision): nsegment</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT nsegment(76, 0.3, 0.5);
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Modification Functions</title>
			<itemizedlist>
				<listitem id="npoint_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Round the position(s) of the network point or the network segment to the number of decimal places</para>
					<para><varname>round({npoint,nsegment},integer): {npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT round(npoint(76, 0.123456789), 6);
--  NPoint(76,0.123457)
SELECT round(nsegment(76, 0.123456789, 0.223456789), 6);
--  NSegment(76,0.123457,0.223457)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="accessor_functions">
			<title>Accessor Functions</title>

			<itemizedlist>
				<listitem id="route">
					<indexterm><primary><varname>route</varname></primary></indexterm>
					<para>Get the route identifier</para>
					<para><varname>route({npoint,nsegment}): bigint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT route(npoint 'Npoint(63, 0.3)');
-- 63
SELECT route(nsegment 'Nsegment(76, 0.3, 0.3)');
-- 76
</programlisting>
				</listitem>

				<listitem id="getPosition">
					<indexterm><primary><varname>getPosition</varname></primary></indexterm>
					<para>Get the position</para>
					<para><varname>getPosition(npoint): float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT getPosition(npoint 'Npoint(63, 0.3)');
-- 0.3
</programlisting>
				</listitem>

				<listitem id="startPosition">
					<indexterm><primary><varname>startPosition</varname></primary></indexterm>
					<para>Get the start position</para>
					<para><varname>startPosition(npoint): float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT startPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.3
</programlisting>
				</listitem>

				<listitem id="endPosition">
					<indexterm><primary><varname>endPosition</varname></primary></indexterm>
					<para>Get the end position</para>
					<para><varname>endPosition(npoint): float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT endPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.5
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="spatial_functions">
			<title>Spatial Functions</title>

			<itemizedlist>
				<listitem id="npoint_srid">
					<indexterm><primary><varname>SRID</varname></primary></indexterm>
					<para>Get the spatial reference identifier</para>
					<para><varname>srid({npoint,nsegment}): int</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT SRID(nspoint 'Npoint(76, 0.3)');
-- 5676
SELECT SRID(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 5676
</programlisting>
				</listitem>
			</itemizedlist>

			<para>Values of the <varname>npoint</varname> and <varname>nsegment</varname> types can be converted to the <varname>geometry</varname> type using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation as shown next.</para>
			<itemizedlist>
				<listitem id="npoint_geometry">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a network point to a geometry</para>
					<para><varname>{npoint,nsegment}::geometry</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(npoint(76, 0.33)::geometry);
-- POINT(21.6338731332283 50.0545869554067)
SELECT ST_AsText(nsegment(76, 0.33, 0.66)::geometry);
-- LINESTRING(21.6338731332283 50.0545869554067,30.7475989651999 53.9185062927473)
SELECT ST_AsText(nsegment(76, 0.33, 0.33)::geometry);
-- POINT(21.6338731332283 50.0545869554067)
</programlisting>
				</listitem>
			</itemizedlist>

			<para>Similarly, <varname>geometry</varname> values of subtype <varname>point</varname> or <varname>linestring</varname> (restricted to two points) can be converted, respectively, to <varname>npoint</varname> and <varname>nsegment</varname> values using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation. For this, the route that intersects the given points must be found, where a tolerance of 0.00001 units (depending on the coordinate system) is assumed so a point and a route that are close are considered to intersect. If no such route is found, a null value is returned.</para>
			<itemizedlist>
				<listitem id="geometry_npoint">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a geometry to a network point</para>
					<para><varname>geometry::{npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT geometry 'Point(279.269156511873 811.497076880187)'::npoint;
-- NPoint(3,0.781413)
SELECT geometry 'LINESTRING(406.729536784738 702.58583437902,
  383.570801314823 845.137059419277)'::nsegment;
-- NSegment(3,0.6,0.9)
SELECT geometry 'Point(279.3 811.5)'::npoint;
-- NULL
SELECT geometry 'LINESTRING(406.7 702.6,383.6 845.1)'::nsegment;
-- NULL
</programlisting>
				</listitem>
			</itemizedlist>

			<para>Two <varname>npoint</varname> values may be have different route identifiers but may represent the same spatial point at the intersection of the two routes. Function <varname>equals</varname> is used for testing spatial equality of network points.</para>
			<itemizedlist>
				<listitem id="npoint_same">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Spatial equality for network points</para>
					<para><varname>equals(npoint, npoint)::Boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
WITH inter(geom) AS (
  SELECT st_intersection(t1.the_geom, t2.the_geom)
  FROM ways t1, ways t2 WHERE t1.gid = 1 AND t2.gid = 2),
fractions(f1, f2) AS (
  SELECT ST_LineLocatePoint(t1.the_geom, i.geom), ST_LineLocatePoint(t2.the_geom, i.geom)
  FROM ways t1, ways t2, inter i WHERE t1.gid = 1 AND t2.gid = 2)
SELECT equals(npoint(1, f1), npoint(2, f2)) FROM fractions;
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="static_operators">
			<title>Comparison Operators</title>

			<para>The comparison operators (=, &lt;, and so on) for static network types require that the left and right arguments be of the same type. Excepted the equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on static network types.</para>

			<itemizedlist>
				<listitem id="static_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Are the values equal?</para>
					<para><varname>{npoint,nsegment} = {npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT npoint 'Npoint(3, 0.5)' = npoint 'Npoint(3, 0.5)';
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' = nsegment 'Nsegment(3, 0.5, 0.6)';
-- false
</programlisting>
				</listitem>

				<listitem id="static_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>Are the values different?</para>
					<para><varname>{npoint,nsegment} &lt;&gt; {npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT npoint 'Npoint(3, 0.5)' &lt;&gt; npoint 'Npoint(3, 0.6)';
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt;&gt; nsegment 'Nsegment(3, 0.5, 0.5)';
-- false
</programlisting>
				</listitem>

				<listitem id="static_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>Is the first value less than the second one?</para>
					<para><varname>{npoint,nsegment} &lt; {npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt; nsegment 'Nsegment(3, 0.5, 0.6)';
-- true
</programlisting>
				</listitem>

				<listitem id="static_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>Is the first value greater than the second one?</para>
					<para><varname>{npoint,nsegment} &gt; {npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &gt; nsegment 'Nsegment(2, 0.5, 0.5)';
-- true
</programlisting>
				</listitem>

				<listitem id="static_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>Is the first value less than or equal to the second one?</para>
					<para><varname>{npoint,nsegment} &lt;= {npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT npoint 'Npoint(1, 0.5)' &lt;= npoint 'Npoint(2, 0.5)';
-- true
</programlisting>
				</listitem>

				<listitem id="static_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>Is the first value greater than or equal to the second one?</para>
					<para><varname>{npoint,nsegment} &gt;= {npoint,nsegment}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT npoint 'Npoint(1, 0.6)' &gt;= npoint 'Npoint(1, 0.5)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id="temp_network_points">
		<title>Temporal Network Points</title>

		<para>The temporal network point type <varname>tnpoint</varname> allows to represent the movement of objects over a network. It corresponds to the temporal point type <varname>tgeompoint</varname> restricted to two-dimensional coordinates. As all the other temporal types it comes in trhee subtypes, namely, instant, sequence, and sequence set. Examples of <varname>tnpoint</varname> values in these subtypes are given next.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tnpoint 'Npoint(1, 0.5)@2000-01-01';
SELECT tnpoint '{Npoint(1, 0.3)@2000-01-01, Npoint(1, 0.5)@2000-01-02,
  Npoint(1, 0.5)@2000-01-03}';
SELECT tnpoint '[Npoint(1, 0.2)@2000-01-01, Npoint(1, 0.4)@2000-01-02,
  Npoint(1, 0.5)@2000-01-03]';
SELECT tnpoint '{[Npoint(1, 0.2)@2000-01-01, Npoint(1, 0.4)@2000-01-02,
  Npoint(1, 0.5)@2000-01-03], [Npoint(2, 0.6)@2000-01-04, Npoint(2, 0.6)@2000-01-05]}';
</programlisting>
		<para>The temporal network point type accepts type modifiers (or <varname>typmod</varname> in PostgreSQL terminology). The possible values for the type modifier are <varname>Instant</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. If no type modifier is specified for a column, values of any subtype are allowed.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tnpoint(Sequence) '[Npoint(1, 0.2)@2000-01-01, Npoint(1, 0.4)@2000-01-02,
  Npoint(1, 0.5)@2000-01-03]';
SELECT tnpoint(Sequence) 'Npoint(1, 0.2)@2000-01-01';
-- ERROR: Temporal type (Instant) does not match column type (Sequence)
</programlisting>

		<para>Temporal network point values of sequence subtype and linear or stepwise interpolation must be defined on a single route. Therefore, a value of sequence set subtype is needed for representing the movement of an object that traverses several routes, even if there is no temporal gap. For example, in the following value</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '{[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.5)@2001-01-03),
  [NPoint(2, 0.4)@2001-01-03, NPoint(2, 0.6)@2001-01-04)}';
</programlisting>
		<para>the network point changes its route at 2001-01-03.</para>

		<para>Temporal network point values of sequence or sequence set subtype are converted into a normal form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. Three consecutive instant values can be merged into two if the linear functions defining the evolution of values are the same. Examples of transformation into a normal form are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.4)@2001-01-02,
  NPoint(1, 0.6)@2001-01-03)';
-- [NPoint(1,0.2)@2001-01-01, NPoint(1,0.6)@2001-01-03)
SELECT tnpoint '{[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.3)@2001-01-02,
  NPoint(1, 0.5)@2001-01-03), [NPoint(1, 0.5)@2001-01-03, NPoint(1, 0.7)@2001-01-04)}';
-- {[NPoint(1,0.2)@2001-01-01, NPoint(1,0.3)@2001-01-02, NPoint(1,0.7)@2001-01-04)}
</programlisting>
	</sect1>

	<sect1 id="validity_temporal_network_points">
		<title>Validity of Temporal Network Points</title>

		<para>Temporal network point values must satisfy the constraints specified in <xref linkend="validity_temporal_types" /> so that they are well defined. An error is raised whenever one of these constraints are not satisfied. Examples of incorrect values are as follows.</para>
		<programlisting language="sql" xml:space="preserve">
-- Null values are not allowed
SELECT tnpoint 'NULL@2001-01-01 08:05:00';
SELECT tnpoint 'Point(0 0)@NULL';
-- Base type is not a network point
SELECT tnpoint 'Point(0 0)@2001-01-01 08:05:00';
-- Multiple routes in a continuous sequence
SELECT tnpoint '[Npoint(1, 0.2)@2001-01-01 09:00:00, Npoint(2, 0.2)@2001-01-01 09:05:00)';
</programlisting>
	</sect1>

	<sect1 id="constructors_temporal_network_points">
		<title>Constructors for Temporal Network Points</title>

			<itemizedlist>
				<listitem id="tnpoint_inst">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Constructor for temporal network points of instant subtype</para>
					<para><varname>tnpoint_inst(val npoint,t timestamptz):tnpoint_inst</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tnpoint_inst('Npoint(1, 0.5)', '2000-01-01');
-- NPoint(1,0.5)@2000-01-01
</programlisting>
				</listitem>

				<listitem id="tnpoint_discseq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Constructors for temporal network points of sequence subtype and discrete interpolation</para>
					<para><varname>tnpoint_discseq(tnpoint[]):tnpoint_discseq</varname></para>
					<para><varname>tnpoint_discseq(npoint,timestampset):tnpoint_discseq</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tnpoint_discseq(ARRAY[tnpoint 'Npoint(1, 0.3)@2000-01-01',
  'Npoint(1, 0.5)@2000-01-02', 'Npoint(1, 0.5)@2000-01-03']);
-- {NPoint(1,0.3)@2000-01-01, NPoint(1,0.5)@2000-01-02, NPoint(1,0.5)@2000-01-03}
SELECT tnpoint_discseq('Npoint(1, 0.3)', '{2000-01-01, 2000-01-03, 2000-01-05}');
-- {NPoint(1,0.3)@2000-01-01, NPoint(1,0.3)@2000-01-03, NPoint(1,0.3)@2000-01-05}
</programlisting>
				</listitem>

				<listitem id="tnpoint_seq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Constructor for temporal network points of sequence subtype and linear or stepwise interpolation</para>
					<para><varname>tnpoint_seq(tnpoint[],lower_inc boolean=true,upper_inc boolean=true,</varname></para>
					<para><varname>  linear boolean=true):tnpoint_seq</varname></para>
					<para><varname>tnpoint_seq(npoint,period,linear boolean=true):tnpoint_seq</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tnpoint_seq(ARRAY[tnpoint 'Npoint(1, 0.2)@2000-01-01', 'Npoint(1, 0.4)@2000-01-02',
  'Npoint(1, 0.5)@2000-01-03']);
-- [NPoint(1,0.2)@2000-01-01, NPoint(1,0.4)@2000-01-02, NPoint(1,0.5)@2000-01-03]
SELECT tnpoint_seq(npoint 'Npoint(1, 0.2)', '[2000-01-01, 2000-01-03]', false);
-- Interp=Stepwise;[NPoint(1,0.2)@2000-01-01, NPoint(1,0.2)@2000-01-03]
</programlisting>
				</listitem>

				<listitem id="tnpoint_seqset">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Constructor for temporal network points of sequence set subtype</para>
					<para><varname>tnpoint_seqset(tnpoint[]):tnpoint_seqset</varname></para>
					<para><varname>tnpoint_seqset(npoint,periodset,boolean=true):tnpoint_seqset</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tnpoint_seqset(ARRAY[tnpoint '[Npoint(1, 0.2)@2000-01-01, Npoint(1, 0.4)@2000-01-02,
  Npoint(1, 0.5)@2000-01-03]', '[Npoint(2, 0.6)@2000-01-04, Npoint(2, 0.6)@2000-01-05]']);
/* {[NPoint(1,0.2)@2000-01-01, NPoint(1,0.4)@2000-01-02, NPoint(1,0.5)@2000-01-03],
   [NPoint(2,0.6)@2000-01-04, NPoint(2,0.6)@2000-01-05]} */
</programlisting>
				</listitem>
			</itemizedlist>
	</sect1>

	<sect1 id="casting_temporal_network_types">
		<title>Casting for Temporal Network Points</title>

		<para>A temporal network point value can be converted to and from a temporal geometry point. This can be done using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation. A null value is returned if any of the composing geometry point values cannot be converted into a <varname>npoint</varname> value.</para>
		<itemizedlist>
			<listitem id="tnpoint_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal network point to a temporal geometry point</para>
				<para><varname>tnpoint::tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT asText((tnpoint '[NPoint(1, 0.2)@2001-01-01,
  NPoint(1, 0.3)@2001-01-02)')::tgeompoint);
/* [POINT(23.057077727326 28.7666335767956)@2001-01-01,
   POINT(48.7117553116406 20.9256801894708)@2001-01-02) */
</programlisting>
			</listitem>

			<listitem id="tgeompoint_tnpoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Cast a temporal geometry point to a temporal network point</para>
				<para><varname>tgeompoint::tnpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[POINT(23.057077727326 28.7666335767956)@2001-01-01,
  POINT(48.7117553116406 20.9256801894708)@2001-01-02)'::tnpoint
-- [NPoint(1,0.2)@2001-01-01, NPoint(1,0.3)@2001-01-02)
SELECT tgeompoint '[POINT(23.057077727326 28.7666335767956)@2001-01-01,
  POINT(48.7117553116406 20.9)@2001-01-02)'::tnpoint
-- NULL
</programlisting>
			</listitem>
		</itemizedlist>
		<para>We give next the functions and operators for network point types.</para>
	</sect1>

	<sect1 id="functions_temporal_network_points">
		<title>Functions and Operators for Temporal Network Points</title>

		<para>All functions for temporal types described in <xref linkend="manipulating_temporal_types" /> can be applied for temporal network point types. Therefore, in the signatures of the functions, the notation <varname>base</varname> also represents an <varname>npoint</varname> and the notations <varname>ttype</varname>, <varname>tpoint</varname>, and <varname>tgeompoint</varname> also represent a <varname>tnpoint</varname>. Furthermore, the functions that have an argument of type <varname>geometry</varname> accept in addition an argument of type <varname>npoint</varname>. To avoid redundancy, we only present next some examples of these functions and operators for temporal network points.</para>

		<itemizedlist>
			<listitem id="tnpoint_transform">
				<indexterm><primary><varname>tnpoint_inst</varname></primary></indexterm>
				<indexterm><primary><varname>tnpoint_discseq</varname></primary></indexterm>
				<indexterm><primary><varname>tnpoint_seq</varname></primary></indexterm>
				<indexterm><primary><varname>tnpoint_seqset</varname></primary></indexterm>
				<para>Transform a temporal network point to another subtype</para>
				<para><varname>tnpoint_inst(tnpoint): tnpoint_inst</varname></para>
				<para><varname>tnpoint_discseq(tnpoint): tnpoint_discseq</varname></para>
				<para><varname>tnpoint_seq(tnpoint): tnpoint_seq</varname></para>
				<para><varname>tnpoint_seqset(tnpoint): tnpoint_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint_seqset(tnpoint 'NPoint(1, 0.5)@2001-01-01');
-- {[NPoint(1,0.5)@2001-01-01]}
</programlisting>
			</listitem>

			<listitem id="tnpoint_round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Round the fraction of the temporal network point to the number of decimal places</para>
				<para><varname>round(tnpoint,integer): tnpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT round(tnpoint '{[NPoint(1, 0.123456789)@2001-01-01, NPoint(1, 0.5)@2001-01-02)}', 6);
-- {[NPoint(1,0.123457)@2001-01-01 00:00:00+01, NPoint(1,0.5)@2001-01-02 00:00:00+01)}
</programlisting>
			</listitem>

			<listitem id="tnpoint_getValues">
				<indexterm><primary><varname>getValues</varname></primary></indexterm>
				<para>Get the values</para>
				<para><varname>getValues(tnpoint): npoint[]</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getValues(tnpoint '{[NPoint(1, 0.3)@2001-01-01, NPoint(1, 0.5)@2001-01-02)}');
-- {"NPoint(1,0.3)","NPoint(1,0.5)"}
SELECT getValues(tnpoint '{[NPoint(1, 0.3)@2001-01-01, NPoint(1, 0.3)@2001-01-02)}');
-- {"NPoint(1,0.3)"}
</programlisting>
			</listitem>

			<listitem id="tnpoint_valueAtTimestamp">
				<indexterm><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Get the value at a timestamp</para>
				<para><varname>valueAtTimestamp(tnpoint,timestamptz): npoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT valueAtTimestamp(tnpoint '[NPoint(1, 0.3)@2001-01-01, NPoint(1, 0.5)@2001-01-03)',
  '2001-01-02');
-- NPoint(1,0.4)
</programlisting>
			</listitem>

			<listitem id="tnpoint_length">
				<indexterm><primary><varname>length</varname></primary></indexterm>
				<para>Get the length traversed by the temporal network point</para>
				<para><varname>length(tnpoint): float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT length(tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]');
-- 54.3757408468784
</programlisting>
			</listitem>

			<listitem id="tnpoint_cumulativeLength">
				<indexterm><primary><varname>cumulativeLength</varname></primary></indexterm>
				<para>Get the cumulative length traversed by the temporal network point</para>
				<para><varname>cumulativeLength(tnpoint): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT cumulativeLength(tnpoint '{[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02,
  NPoint(1, 0.5)@2000-01-03], [NPoint(1, 0.6)@2000-01-04, NPoint(1, 0.7)@2000-01-05]}');
/* {[0@2000-01-01, 54.3757408468784@2000-01-02, 54.3757408468784@2000-01-03],
   [54.3757408468784@2000-01-04, 81.5636112703177@2000-01-05]} */
</programlisting>
			</listitem>

			<listitem id="tnpoint_speed">
				<indexterm><primary><varname>speed</varname></primary></indexterm>
				<para>Get the speed of the temporal network point in units per second</para>
				<para><varname>speed({tnpoint_seq, tpoint_seqset}): tfloat_seqset</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT speed(tnpoint '[NPoint(1, 0.1)@2000-01-01, NPoint(1, 0.4)@2000-01-02,
  NPoint(1, 0.6)@2000-01-03]') * 3600 * 24;
/* Interp=Stepwise;[21.4016800272077@2000-01-01, 14.2677866848051@2000-01-02,
   14.2677866848051@2000-01-03] */
</programlisting>
			</listitem>

			<listitem id="tnpoint_stbox">
				<indexterm><primary><varname>stbox</varname></primary></indexterm>
				<para>Construct the bounding box from a npoint and, optionally, a timestamp or a period</para>
				<para><varname>stbox(npoint): stbox</varname></para>
				<para><varname>stbox(npoint,{timestamptz,period}): stbox</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT stbox(npoint 'NPoint(1,0.3)');
-- STBOX X(((48.711754,20.92568),(48.711758,20.925682)))
SELECT stbox(npoint 'NPoint(1,0.3)', timestamptz '2000-01-01');
-- STBOX XT(((62.786633,80.143555),(62.786636,80.143562)),[2000-01-01,2000-01-01])
SELECT stbox(npoint 'NPoint(1,0.3)', period '[2000-01-01,2000-01-02]');
-- STBOX XT(((62.786633,80.143555),(62.786636,80.143562)),[2000-01-01,2000-01-02])
</programlisting>
			</listitem>

			<listitem id="tnpoint_twCentroid">
				<indexterm><primary><varname>twCentroid</varname></primary></indexterm>
				<para>Get the time-weighted centroid</para>
				<para><varname>twCentroid(tnpoint): geometry(Point)</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT st_astext(twCentroid(tnpoint '{[NPoint(1, 0.3)@2001-01-01,
  NPoint(1, 0.5)@2001-01-02, NPoint(1, 0.5)@2001-01-03, NPoint(1, 0.7)@2001-01-04)}'));
-- POINT(79.9787466444847 46.2385558051041)
</programlisting>
			</listitem>

			<listitem id="tnpoint_azimuth">
				<indexterm><primary><varname>azimuth</varname></primary></indexterm>
				<para>Get the temporal azimuth</para>
				<para><varname>azimuth(tnpoint): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT azimuth(tnpoint '[NPoint(2, 0.3)@2001-01-01, NPoint(2, 0.7)@2001-01-02]');
/* {[0.974681063778863@2001-01-01 00:00:00+01,
   0.974681063778863@2001-01-01 23:54:36.721091+01),
   [3.68970843029227@2001-01-01 23:54:36.721091+01,
  3.68970843029227@2001-01-02 00:00:00+01)} */
</programlisting>
				<para>Since the underlying geometry associated to a route may have several vertices, the azimuth value may change between instants of the input temporal network point, as shown in the example above.</para>
			</listitem>

			<listitem id="tnpoint_nearestApproachInstant">
				<indexterm><primary><varname>nearestApproachInstant</varname></primary></indexterm>
				<para>Get the instant of the first temporal network point at which the two arguments are at the nearest distance</para>
				<para><varname>nearestApproachInstant({geo,npoint,tpoint},{geo,npoint,tpoint}): tpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT nearestApproachInstant(tnpoint '[NPoint(2, 0.3)@2001-01-01,
  NPoint(2, 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)');
-- NPoint(2,0.349928)@2001-01-01 02:59:44.402905+01
SELECT nearestApproachInstant(tnpoint '[NPoint(2, 0.3)@2001-01-01,
  NPoint(2, 0.7)@2001-01-02]', npoint 'NPoint(1, 0.5)');
-- NPoint(2,0.592181)@2001-01-01 17:31:51.080405+01
</programlisting>
			</listitem>

			<listitem id="tnpoint_nearestApproachDistance">
				<indexterm><primary><varname>nearestApproachDistance</varname></primary></indexterm>
				<para>Get the smallest distance ever between the two arguments</para>
				<para><varname>nearestApproachDistance({geo,npoint,tpoint},{geo,npoint,tpoint}): float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT nearestApproachDistance(tnpoint '[NPoint(2, 0.3)@2001-01-01,
  NPoint(2, 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)');
-- 1.41793220500979
SELECT nearestApproachDistance(tnpoint '[NPoint(2, 0.3)@2001-01-01,
  NPoint(2, 0.7)@2001-01-02]', npoint 'NPoint(1, 0.5)');
-- NPoint(2,0.592181)@2001-01-01 17:31:51.080405+01
</programlisting>
				<para>Function <varname>nearestApproachDistance</varname> has an associated operator <varname>|=|</varname> that can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="indexing_temporal_types" />).</para>
			</listitem>

			<listitem id="tnpoint_shortestLine">
				<indexterm><primary><varname>shortestLine</varname></primary></indexterm>
				<para>Get the line connecting the nearest approach point between the two arguments</para>
				<para><varname>shortestLine({geo,npoint,tpoint},{geo,npoint,tpoint}): geometry</varname></para>
				<para>The function will only return the first line that it finds if there are more than one</para>
				<programlisting language="sql" xml:space="preserve">
SELECT st_astext(shortestLine(tnpoint '[NPoint(2, 0.3)@2001-01-01,
  NPoint(2, 0.7)@2001-01-02]', geometry 'Linestring(50 50,55 55)'));
-- LINESTRING(50.7960725266492 48.8266286733015,50 50)
SELECT st_astext(shortestLine(tnpoint '[NPoint(2, 0.3)@2001-01-01,
  NPoint(2, 0.7)@2001-01-02]', npoint 'NPoint(1, 0.5)'));
-- LINESTRING(77.0902838115125 66.6659083092593,90.8134936900394 46.4385792121146)
</programlisting>
			</listitem>

			<listitem id="tnpoint_atValue">
				<indexterm><primary><varname>atValue</varname></primary></indexterm>
				<para>Restrict to a value</para>
				<para><varname>atValue(tnpoint,base): tnpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atValue(tnpoint '[NPoint(2, 0.3)@2001-01-01, NPoint(2, 0.7)@2001-01-03]',
  'NPoint(2, 0.5)');
-- {[NPoint(2,0.5)@2001-01-02]}
</programlisting>
			</listitem>

			<listitem id="tnpoint_atGeometry">
				<indexterm><primary><varname>atGeometry</varname></primary></indexterm>
				<para>Restrict to a geometry</para>
				<para><varname>atGeometry(tnpoint,geometry): tnpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT atGeometry(tnpoint '[NPoint(2, 0.3)@2001-01-01, NPoint(2, 0.7)@2001-01-03]',
  'Polygon((40 40,40 50,50 50,50 40,40 40))');
</programlisting>
			</listitem>

			<listitem id="tnpoint_minusValue">
				<indexterm><primary><varname>minusValue</varname></primary></indexterm>
				<para>Difference with a value</para>
				<para><varname>minusValue(tnpoint,base): tnpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT minusValue(tnpoint '[NPoint(2, 0.3)@2001-01-01, NPoint(2, 0.7)@2001-01-03]',
  'NPoint(2, 0.5)');
/* {[NPoint(2,0.3)@2001-01-01, NPoint(2,0.5)@2001-01-02),
   (NPoint(2,0.5)@2001-01-02, NPoint(2,0.7)@2001-01-03]} */
</programlisting>
			</listitem>

			<listitem id="tnpoint_minusGeometry">
				<indexterm><primary><varname>minusGeometry</varname></primary></indexterm>
				<para>Difference with a geometry</para>
				<para><varname>minusGeometry(tnpoint,geometry): tnpoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT minusGeometry(tnpoint '[NPoint(2, 0.3)@2001-01-01, NPoint(2, 0.7)@2001-01-03]',
  'Polygon((40 40,40 50,50 50,50 40,40 40))');
/* {(NPoint(2,0.342593)@2001-01-01 05:06:40.364673+01,
   NPoint(2,0.7)@2001-01-03 00:00:00+01]} */
</programlisting>
			</listitem>

			<listitem id="tnpoint_comp">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Traditional comparison operators</para>
				<para><varname>tnpoint = tnpoint: boolean</varname></para>
				<para><varname>tnpoint &lt;&gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &lt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &lt;= tnpoint: boolean</varname></para>
				<para><varname>tnpoint &gt;= tnpoint: boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '{[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-02),
  [NPoint(1, 0.3)@2001-01-02, NPoint(1, 0.5)@2001-01-03]}' =
  tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]';
-- true
SELECT tnpoint '{[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]}' &lt;&gt;
  tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]';
-- false
SELECT tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]' &lt;
  tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.6)@2001-01-03]';
-- true
</programlisting>
			</listitem>

			<listitem id="tnpoint_tcomp">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Temporal comparison operators</para>
				<para><varname>tnpoint #= tnpoint: tbool</varname></para>
				<para><varname>tnpoint #&lt;&gt; tnpoint: tbool</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.4)@2001-01-03)' #=
  npoint 'NPoint(1, 0.3)';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tnpoint '[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.8)@2001-01-03)' #&lt;&gt;
  tnpoint '[NPoint(1, 0.3)@2001-01-01, NPoint(1, 0.7)@2001-01-03)';
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
</programlisting>
			</listitem>

			<listitem id="tnpoint_ever_always">
				<indexterm><primary><varname>?=</varname></primary></indexterm>
				<indexterm><primary><varname>&amp;=</varname></primary></indexterm>
				<para>Ever and always equal operators</para>
				<para><varname>tnpoint ?= tnpoint: boolean</varname></para>
				<para><varname>tnpoint &amp;= tnpoint: boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '[Npoint(1, 0.2)@2001-01-01, Npoint(1, 0.4)@2001-01-04)' ?= Npoint(1, 0.3);
-- true
SELECT tnpoint '[Npoint(1, 0.2)@2001-01-01, Npoint(1, 0.2)@2001-01-04)' &amp;= Npoint(1, 0.2);
-- true
</programlisting>
			</listitem>

			<listitem id="tnpoint_relpos">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Relative position operators</para>
				<para><varname>tnpoint &lt;&lt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &amp;&lt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &gt;&gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &amp;&gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &lt;&lt;| tnpoint: boolean</varname></para>
				<para><varname>tnpoint &amp;&lt;| tnpoint: boolean</varname></para>
				<para><varname>tnpoint |&gt;&gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint |&amp;&gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &lt;&lt;# tnpoint: boolean</varname></para>
				<para><varname>tnpoint &amp;&lt;# tnpoint: boolean</varname></para>
				<para><varname>tnpoint #&gt;&gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint |&amp;&gt; tnpoint: boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &lt;&lt;
  npoint 'NPoint(1, 0.2)'
-- false
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &lt;&lt;|
  stbox(npoint 'NPoint(1, 0.5)')
-- false
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &amp;&gt;
  npoint 'NPoint(1, 0.3)'::geometry
-- true
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &gt;&gt;#
  tnpoint '[NPoint(1, 0.3)@2000-01-03, NPoint(1, 0.5)@2000-01-05]'
-- true
</programlisting>
			</listitem>

			<listitem id="tnpoint_topo">
				<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
				<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
				<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
				<indexterm><primary><varname>~=</varname></primary></indexterm>
				<indexterm><primary><varname>-|-</varname></primary></indexterm>
				<para>Topological operators</para>
				<para><varname>tnpoint &amp;&amp; tnpoint: boolean</varname></para>
				<para><varname>tnpoint &lt;@ tnpoint: boolean</varname></para>
				<para><varname>tnpoint @&gt; tnpoint: boolean</varname></para>
				<para><varname>tnpoint ~= tnpoint: boolean</varname></para>
				<para><varname>tnpoint -|- tnpoint: boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &amp;&amp;
  npoint 'NPoint(1, 0.5)'
-- true
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' @&gt;
  stbox(npoint 'NPoint(1, 0.5)')
-- true
SELECT npoint 'NPoint(1, 0.5)'::geometry &lt;@
  tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]'
-- true
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' ~=
  tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.35)@2000-01-02,
  NPoint(1, 0.5)@2000-01-03]'
-- true
</programlisting>
			</listitem>

			<listitem id="tnpoint_smallestDistance">
				<indexterm><primary><varname>|=|</varname></primary></indexterm>
				<para>Get the smallest distance ever between the two arguments</para>
				<para><varname>tgeompoint |=| tnpoint: float</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' |=|
  npoint 'NPoint(1, 0.2)';
-- 2.34988300875063
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' |=|
  geometry 'Linestring(2 2,2 1,3 1)';
-- 82.2059262761477
</programlisting>
			</listitem>

			<listitem id="tnpoint_distance">
				<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
				<para>Get the temporal distance</para>
				<para><varname>tgeompoint &lt;-&gt; tnpoint: tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' &lt;-&gt;
  npoint 'NPoint(1, 0.2)';
-- [2.34988300875063@2000-01-02 00:00:00+01, 2.34988300875063@2000-01-03 00:00:00+01]
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' &lt;-&gt;
  geometry 'Point(50 50)';
-- [25.0496666945044@2000-01-01 00:00:00+01, 26.4085688426232@2000-01-03 00:00:00+01]
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' &lt;-&gt;
  tnpoint '[NPoint(1, 0.3)@2000-01-02, NPoint(1, 0.5)@2000-01-04]'
-- [2.34988300875063@2000-01-02 00:00:00+01, 2.34988300875063@2000-01-03 00:00:00+01]
</programlisting>
			</listitem>

			<listitem id="tnpoint_spatialrels">
				<indexterm><primary><varname>contains</varname></primary></indexterm>
				<indexterm><primary><varname>disjoint</varname></primary></indexterm>
				<indexterm><primary><varname>intersects</varname></primary></indexterm>
				<indexterm><primary><varname>touches</varname></primary></indexterm>
				<indexterm><primary><varname>dwithin</varname></primary></indexterm>
				<para>Possible spatial relationships</para>
				<para><varname>contains(geometry,tnpoint): boolean</varname></para>
				<para><varname>disjoint({geometry,npoint,tnpoint},{geometry,npoint,tnpoint}): boolean</varname></para>
				<para><varname>intersects({geometry,npoint,tnpoint},{geometry,npoint,tnpoint}): boolean</varname></para>
				<para><varname>touches({geometry,npoint,tnpoint},{geometry,npoint,tnpoint}): boolean</varname></para>
				<para><varname>dwithin({geometry,npoint,tnpoint},{geometry,npoint,tnpoint},float): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT contains(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
  tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-03)');
-- false
SELECT disjoint(npoint 'NPoint(2, 0.0)',
  tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-03)');
-- true
SELECT intersects(tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-03)',
  tnpoint '[NPoint(2, 0.0)@2001-01-01, NPoint(2, 1)@2001-01-03)');
-- false
</programlisting>
			</listitem>

			<listitem id="tnpoint_tspatialrels">
				<indexterm><primary><varname>tcontains</varname></primary></indexterm>
				<indexterm><primary><varname>tdisjoint</varname></primary></indexterm>
				<indexterm><primary><varname>tintersects</varname></primary></indexterm>
				<indexterm><primary><varname>ttouches</varname></primary></indexterm>
				<indexterm><primary><varname>tdwithin</varname></primary></indexterm>
				<para>Temporal spatial relationships</para>
				<para><varname>tcontains(geometry,tnpoint): boolean</varname></para>
				<para><varname>tdisjoint({geometry,npoint,tnpoint},{geometry,npoint,tnpoint}): boolean</varname></para>
				<para><varname>tintersects({geometry,npoint,tnpoint},{geometry,npoint,tnpoint}): boolean</varname></para>
				<para><varname>ttouches({geometry,npoint,tnpoint},{geometry,npoint,tnpoint}): boolean</varname></para>
				<para><varname>tdwithin({geometry,npoint,tnpoint},{geometry,npoint,tnpoint},float): boolean</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT tdisjoint(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
  tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-03)');
-- {[t@2001-01-01 00:00:00+01, t@2001-01-03 00:00:00+01)}
SELECT tdwithin(tnpoint '[NPoint(1, 0.3)@2001-01-01, NPoint(1, 0.5)@2001-01-03)',
  tnpoint '[NPoint(1, 0.5)@2001-01-01, NPoint(1, 0.3)@2001-01-03)', 1);
/* {[t@2001-01-01 00:00:00+01, t@2001-01-01 22:35:55.379053+01],
   (f@2001-01-01 22:35:55.379053+01, t@2001-01-02 01:24:04.620946+01,
   t@2001-01-03 00:00:00+01)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="aggregate_temporal_network_points">
		<title>Aggregate Functions</title>

		<para>The three aggregate functions for temporal network points are illustrated next.</para>

		<itemizedlist>
			<listitem id="tnpoint_tcount">
				<indexterm><primary><varname>tcount</varname></primary></indexterm>
				<para>Temporal count</para>
				<para><varname>tcount(tnpoint): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
  SELECT tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-03)' UNION
  SELECT tnpoint '[NPoint(1, 0.2)@2001-01-02, NPoint(1, 0.4)@2001-01-04)' UNION
  SELECT tnpoint '[NPoint(1, 0.3)@2001-01-03, NPoint(1, 0.5)@2001-01-05)' )
SELECT tcount(Temp)
FROM Temp;
-- {[1@2001-01-01, 2@2001-01-02, 1@2001-01-04, 1@2001-01-05)}
</programlisting>
			</listitem>

			<listitem id="tnpoint_wcount">
				<indexterm><primary><varname>wcount</varname></primary></indexterm>
				<para>Window count</para>
				<para><varname>wcount(tnpoint): {tint_seq,tint_seqset}</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
  SELECT tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-03)' UNION
  SELECT tnpoint '[NPoint(1, 0.2)@2001-01-02, NPoint(1, 0.4)@2001-01-04)' UNION
  SELECT tnpoint '[NPoint(1, 0.3)@2001-01-03, NPoint(1, 0.5)@2001-01-05)' )
SELECT wcount(Temp, '1 day')
FROM Temp;
/* {[1@2001-01-01, 2@2001-01-02, 3@2001-01-03, 2@2001-01-04, 1@2001-01-05,
   1@2001-01-06)} */
</programlisting>
			</listitem>

			<listitem id="tnpoint_tcentroid">
				<indexterm><primary><varname>tcentroid</varname></primary></indexterm>
				<para>Temporal centroid</para>
				<para><varname>tcentroid(tnpoint): tgeompoint</varname></para>
				<programlisting language="sql" xml:space="preserve">
WITH Temp(temp) AS (
SELECT tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-03)' UNION
SELECT tnpoint '[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.4)@2001-01-03)' UNION
SELECT tnpoint '[NPoint(1, 0.3)@2001-01-01, NPoint(1, 0.5)@2001-01-03)' )
SELECT astext(tcentroid(Temp))
FROM Temp;
/* {[POINT(72.451531682218 76.5231414472853)@2001-01-01,
   POINT(55.7001249027598 72.9552602410653)@2001-01-03)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="indexing_temporal_network_points">
		<title>Indexing of Temporal Network Points</title>

		<para>GiST and SP-GiST indexes can be created for table columns of temporal networks points. An example of index creation is follows:</para>
		<programlisting language="sql" xml:space="preserve">
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		<para>The GiST and SP-GiST indexes store the bounding box for the temporal network points, which is an stbox and thus stores the absolute coordinates of the underlying space.</para>

		<para>A GiST or SP-GiST index can accelerate queries involving the following operators:</para>
		<itemizedlist>
			<listitem>
				<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, which only consider the spatial dimension in temporal network points,</para>
			</listitem>
			<listitem>
				<para><varname>&lt;&lt;#</varname>, <varname>&amp;&lt;#</varname>, <varname>#&amp;&gt;</varname>, <varname>#&gt;&gt;</varname>, which only consider the time dimension in temporal network points,</para>
			</listitem>
			<listitem>
				<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, <varname>-|-</varname>, and <varname>|=|</varname> , which consider as many dimensions as they are shared by the indexed column and the query argument.</para>
			</listitem>
		</itemizedlist>
		<para>These operators work on bounding boxes, not the entire values.</para>
	</sect1>
</chapter>
