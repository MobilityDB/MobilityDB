<?xml version="1.0" encoding="UTF-8"?>
<chapter id="time_types_range_types">
	<title>Time Types and Range Types</title>

	<para>Temporal types are based on four time types: the <varname>timestamptz</varname> type provided by PostgreSQL and three new types which are <varname>period</varname>, <varname>timestampset</varname>, and <varname>periodset</varname>.</para>

	<para>The <varname>period</varname> type is a specialized version of the <varname>tstzrange</varname> (short for timestamp with time zone range) type provided by PostgreSQL. Type <varname>period</varname> has similar functionality as type <varname>tstzrange</varname> but has a more efficient implementation, in particular it is of fixed length while the <varname>tstzrange</varname> type is of variable length. Furthermore, empty periods and infinite bounds are not allowed in <varname>period</varname> values, while they are allowed in <varname>tstzrange</varname> values.</para>

	<para>A value of the <varname>period</varname> type has two bounds, the lower bound and the upper bound, which are <varname>timestamptz</varname> values. The bounds can be inclusive or exclusive. An inclusive bound means that the boundary instant is included in the period, while an exclusive bound means that the boundary instant is not included in the period. In the text form of a <varname>period</varname> value, inclusive and exclusive lower bounds are represented, respectively, by &ldquo;<varname>[</varname>&rdquo; and &ldquo;<varname>(</varname>&rdquo;. Likewise, inclusive and exclusive upper bounds are represented, respectively, by &ldquo;<varname>]</varname>&rdquo; and &ldquo;<varname>)</varname>&rdquo;. In a <varname>period</varname> value, the lower bound must be less than or equal to the upper bound. A <varname>period</varname> value with equal and inclusive bounds is called an <emphasis>instantaneous period</emphasis> and corresponds to a <varname>timestamptz</varname> value. Examples of <varname>period</varname> values are as follows:
		<programlisting>
SELECT period '[2012-01-01 08:00:00, 2012-01-03 09:30:00)';
-- Instant period
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00]';
-- Erroneous period: invalid bounds
SELECT period '[2012-01-01 08:10:00, 2012-01-01 08:00:00]';
-- Erroneous period: empty period
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00)';
		</programlisting>
	</para>

	<para>The <varname>timestampset</varname> type represents a set of different <varname>timestamptz</varname> values. A <varname>timestampset</varname> value must contain at least one element, in which case it corresponds to a <varname>timestamptz</varname> value. The elements composing a <varname>timestampset</varname> value must be ordered. Examples of <varname>timestampset</varname> values are as follows:
		<programlisting>
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-03 09:30:00}';
-- Singleton timestampset
SELECT timestampset '{2012-01-01 08:00:00}';
-- Erroneous timestampset: unordered elements
SELECT timestampset '{2012-01-01 08:10:00, 2012-01-01 08:00:00}';
-- Erroneous timestampset: duplicate elements
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-01 08:00:00}';
		</programlisting>
	</para>

	<para>Finally, the <varname>periodset</varname> type represents a set of disjoint <varname>period</varname> values. A <varname>periodset</varname> value must contain at least one element, in which case it corresponds to a <varname>period</varname> value. The elements composing a <varname>periodset</varname> value must be ordered. Examples of <varname>periodset</varname> values are as follows:
		<programlisting>
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
  [2012-01-01 08:20:00, 2012-01-01 08:40:00]}';
-- Singleton periodset
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- Erroneous periodset: unordered elements
SELECT periodset '{[2012-01-01 08:20:00, 2012-01-01 08:40:00],
  [2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- Erroneous periodset: overlapping elements
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
  [2012-01-01 08:05:00, 2012-01-01 08:15:00]}';
		</programlisting>
	</para>

	<para>Values of the <varname>periodset</varname> type are converted into <emphasis>normal form</emphasis> so that equivalent values have identical representations. For this, consecutive adjacent period values are merged when possible. An example of transformation into normal form is as follows:
		<programlisting>
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00),
  [2012-01-01 08:10:00, 2012-01-01 08:10:00], (2012-01-01 08:10:00, 2012-01-01 08:20:00]}';
-- "{[2012-01-01 08:00:00+00,2012-01-01 08:20:00+00]}"
		</programlisting>
	</para>

	<para>Besides the built-in range types provided by PostgreSQL, MobilityDB defines two additional range types: <varname>intrange</varname> (another name for <varname>int4range</varname>) and <varname>floatrange</varname>.</para>

	<sect1 id ="functions_operations_time_types">
		<title>Functions and Operators for Time Types and Range Types</title>

		<para>We present next the functions and operators for time types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this in the signature of the operators, we use the following notation:
			<itemizedlist>
				<listitem>
					<para>A set of types such as <varname>{period,timestampset,periodset}</varname> represents any of the types listed,</para>
				</listitem>
				<listitem>
					<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
				</listitem>
				<listitem>
					<para><varname>number</varname> represents any number type, that is, <varname>integer</varname> or <varname>float</varname>,</para>
				</listitem>
				<listitem>
					<para><varname>range</varname> represents any number range type, that is, <varname>intrange</varname> or <varname>floatrange</varname>.</para>
				</listitem>
				<listitem>
					<para><varname>type[]</varname> represents an array of <varname>type</varname>.
					</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>As an example, the signature of the contains operator (<varname>@&gt;</varname>) is as follows:
			<programlisting>
{timestampset, period, periodset} @&gt; time: boolean
			</programlisting>
		In the following, for conciseness, the time part of the timestamps is omitted in the examples. Recall that in that case PostgreSQL assumes the time <varname>00:00:00</varname>.
		</para>

		<sect2>
			<title>Constructor Functions</title>

			<para>The <varname>period</varname> type has a constructor function that accepts two or four arguments. The two-argument form constructs a period in <emphasis>normal form</emphasis>, that is, with inclusive lower bound and exclusive upper bound. The four-argument form constructs a period with bounds specified by the third and fourth arguments, which are Boolean values stating, respectively, whether the left and right bounds are inclusive or not.
			</para>
			<itemizedlist>
				<listitem id="period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Constructor for <varname>period</varname></para>
					<para><varname>period(timestamptz,timestamptz,left_inc=true,right_inc=false): period</varname></para>
					<programlisting>
-- Period defined with two arguments
SELECT period('2012-01-01 08:00:00', '2012-01-03 08:00:00');
--  [2012-01-01 08:00:00+01, 2012-01-03 08:00:00+01)
-- Period defined with four arguments
SELECT period('2012-01-01 08:00:00', '2012-01-03 09:30:00', false, true);
-- (2012-01-01 08:00:00+01, 2012-01-03 09:30:00+01]
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The <varname>timestampset</varname> type has a constructor function that accepts a single argument which is an array of <varname>timestamptz</varname> values.
			</para>
			<itemizedlist>
				<listitem id="timestampset">
					<indexterm><primary><varname>timestampset</varname></primary></indexterm>
					<para>Constructor for <varname>timestampset</varname></para>
					<para><varname>timestampset(timestamptz[]): timestampset</varname></para>
					<programlisting>
SELECT timestampset(ARRAY[timestamptz '2012-01-01 08:00:00', '2012-01-03 09:30:00']);
-- "{2012-01-01 08:00:00+00, 2012-01-03 09:30:00+00}"
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The <varname>periodset</varname> type has a constructor function that accepts a single argument which is an array of <varname>period</varname> values.
			</para>
			<itemizedlist>
				<listitem id="periodset">
					<indexterm><primary><varname>periodset</varname></primary></indexterm>
					<para>Constructor for <varname>periodset</varname></para>
					<para><varname>periodset(period[]): periodset</varname></para>
					<programlisting>
SELECT periodset(ARRAY[period '[2012-01-01 08:00:00, 2012-01-01 08:10:00]',
-- '[2012-01-01 08:20:00, 2012-01-01 08:40:00]']);
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Casting</title>

			<para>Values of the <varname>timestamptz</varname>, <varname>tstzrange</varname>, or the time types can be converted to one another using the function <varname>CAST</varname> or using the <varname>::</varname> notation.
			</para>

			<itemizedlist>
				<listitem id="timestamptz_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestamptz</varname> to another time type</para>
					<para><varname>timestamptz::timestampset</varname></para>
					<para><varname>timestamptz::period</varname></para>
					<para><varname>timestamptz::periodset</varname></para>
					<programlisting>
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS timestampset);
-- "{2012-01-01 08:00:00+01}"
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS period);
-- "[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]"
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS periodset);
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]}"
					</programlisting>
				</listitem>
				<listitem id="timestampset_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestampset</varname> to a <varname>periodset</varname></para>
					<para><varname>timestampset::periodset</varname></para>
					<programlisting>
SELECT CAST(timestampset '{2012-01-01 08:00:00, 2012-01-01 08:15:00,
  2012-01-01 08:25:00}' AS periodset);
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01],
  [2012-01-01 08:15:00+01, 2012-01-01 08:15:00+01],
  [2012-01-01 08:25:00+01, 2012-01-01 08:25:00+01]}"
					</programlisting>
				</listitem>
				<listitem id="period_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>period</varname> to another time type</para>
					<para><varname>period::periodset</varname></para>
					<para><varname>period::tstzrange</varname></para>
					<programlisting>
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::periodset;
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)}"
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::tstzrange;
-- "["2012-01-01 08:00:00+01","2012-01-01 08:30:00+01")"
					</programlisting>
				</listitem>
				<listitem id="tstzrange_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>tstzrange</varname> to a <varname>period</varname></para>
					<para><varname>tstzrange::period</varname></para>
					<programlisting>
SELECT tstzrange '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::period;
-- "[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Accessor Functions</title>

			<itemizedlist>
				<listitem id="time_memSize">
					<indexterm><primary><varname>memSize</varname></primary></indexterm>
					<para>Get the memory size in bytes</para>
					<para><varname>memSize({timestampset,periodset}): integer</varname></para>
					<programlisting>
SELECT memSize(timestampset '{2012-01-01, 2012-01-02, 2012-01-03}');
-- 104
SELECT memSize(periodset '{[2012-01-01, 2012-01-02], [2012-01-03, 2012-01-04],
  [2012-01-05, 2012-01-06]}');
-- 136
					</programlisting>
				</listitem>

				<listitem id="lower">
					<indexterm><primary><varname>lower</varname></primary></indexterm>
					<para>Get the lower bound</para>
					<para><varname>lower(period): timestamptz</varname></para>
					<programlisting>
SELECT lower(period '[2011-01-01, 2011-01-05)');
-- "2011-01-01"
				</programlisting>
				</listitem>

				<listitem id="upper">
					<indexterm><primary><varname>upper</varname></primary></indexterm>
					<para>Get the upper bound</para>
					<para><varname>upper(period): timestamptz</varname></para>
					<programlisting>
SELECT upper(period '[2011-01-01, 2011-01-05)');
-- "2011-01-05"
					</programlisting>
				</listitem>

				<listitem id="lower_inc">
					<indexterm><primary><varname>lower_inc</varname></primary></indexterm>
					<para>Is the lower bound inclusive?</para>
					<para><varname>lower_inc(period): boolean</varname></para>
					<programlisting>
SELECT lower_inc(period '[2011-01-01, 2011-01-05)');
-- true
					</programlisting>
				</listitem>

				<listitem id="upper_inc">
					<indexterm><primary><varname>upper_inc</varname></primary></indexterm>
					<para>Is the upper bound inclusive?</para>
					<para><varname>upper_inc(period): boolean</varname></para>
					<programlisting>
SELECT upper_inc(period '[2011-01-01, 2011-01-05)');
-- false
					</programlisting>
				</listitem>

				<listitem id="time_duration">
					<indexterm><primary><varname>duration</varname></primary></indexterm>
					<para>Get the duration</para>
					<para><varname>duration({period,periodset}): interval</varname></para>
					<programlisting>
SELECT duration(period '[2012-01-01, 2012-01-03)');
-- "2 days"
SELECT duration(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "3 days"
					</programlisting>
				</listitem>

				<listitem id="time_timespan">
					<indexterm><primary><varname>timespan</varname></primary></indexterm>
					<para>Get the timespan ignoring the potential time gaps</para>
					<para><varname>timespan({timestampset,periodset}): interval</varname></para>
					<programlisting>
SELECT timespan(timestampset '{2012-01-01, 2012-01-03}');
-- "2 days"
SELECT timespan(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "4 days"
					</programlisting>
				</listitem>

				<listitem id="time_period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Get the period on which the timestamp set or period set is defined ignoring the potential time gaps</para>
					<para><varname>period({timestampset,periodset}): period</varname></para>
					<programlisting>
SELECT period(timestampset '{2012-01-01, 2012-01-03, 2012-01-05}');
-- "[2012-01-01, 2012-01-05]"
SELECT period(periodset '{[2012-01-01, 2012-01-02), [2012-01-03, 2012-01-04)}');
-- "[2012-01-01, 2012-01-04)"
					</programlisting>
				</listitem>

				<listitem id="time_numTimestamps">
					<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
					<para>Get the number of different timestamps</para>
					<para><varname>numTimestamps({timestampset,periodset}): integer</varname></para>
					<programlisting>
SELECT numTimestamps(timestampset '{2012-01-01, 2012-01-03, 2012-01-04}');
-- 3
SELECT numTimestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- 3
					</programlisting>
				</listitem>

				<listitem id="time_startTimestamp">
					<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
					<para>Get the start timestamp</para>
					<para><varname>startTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT startTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-01"
					</programlisting>
				</listitem>

				<listitem id="time_endTimestamp">
					<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
					<para>Get the end timestamp</para>
					<para><varname>endTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT endTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-05"
					</programlisting>
				</listitem>

				<listitem id="time_timestampN">
					<indexterm><primary><varname>timestampN</varname></primary></indexterm>
					<para>Get the n-th different timestamp</para>
					<para><varname>timestampN({timestampset,periodset},integer): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT timestampN(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}', 3);
-- "2012-01-04"
					</programlisting>
				</listitem>

				<listitem id="time_timestamps">
					<indexterm><primary><varname>timestamps</varname></primary></indexterm>
					<para>Get the different timestamps</para>
					<para><varname>timestamps({timestampset,periodset}): timestampset</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT timestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "{"2012-01-01", "2012-01-03", "2012-01-05"}"
					</programlisting>
				</listitem>

				<listitem id="numPeriods">
					<indexterm><primary><varname>numPeriods</varname></primary></indexterm>
					<para>Get the number of periods</para>
					<para><varname>numPeriods(periodset): integer</varname></para>
					<programlisting>
SELECT numPeriods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- 3
					</programlisting>
				</listitem>

				<listitem id="startPeriod">
					<indexterm><primary><varname>startPeriod</varname></primary></indexterm>
					<para>Get the start period</para>
					<para><varname>startPeriod(periodset): period</varname></para>
					<programlisting>
SELECT startPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- "[2012-01-01,2012-01-03)"
					</programlisting>
				</listitem>

				<listitem id="endPeriod">
					<indexterm><primary><varname>endPeriod</varname></primary></indexterm>
					<para>Get the end period</para>
					<para><varname>endPeriod(periodset): period</varname></para>
					<programlisting>
SELECT endPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- "[2012-01-05,2012-01-06)"
					</programlisting>
				</listitem>

				<listitem id="periodN">
					<indexterm><primary><varname>periodN</varname></primary></indexterm>
					<para>Get the n-th period</para>
					<para><varname>periodN(periodset,integer): period</varname></para>
					<programlisting>
SELECT periodN(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}', 2);
-- "[2012-01-04,2012-01-04]"
					</programlisting>
				</listitem>

				<listitem id="periods">
					<indexterm><primary><varname>periods</varname></primary></indexterm>
					<para>Get the periods</para>
					<para><varname>periods(periodset): period[]</varname></para>
					<programlisting>
SELECT periods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- "{"[2012-01-01,2012-01-03)", "[2012-01-04,2012-01-04]", "[2012-01-05,2012-01-06)"}"
					</programlisting>
				</listitem>

				<listitem id="time_shift">
					<indexterm><primary><varname>shift</varname></primary></indexterm>
					<para>Shift the time value by an interval</para>
					<para><varname>shift({timestampset,period,periodset}): {timestampset,period,periodset}</varname></para>
					<programlisting>
SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);
-- "{2001-01-02, 2001-01-04, 2001-01-06}"
SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);
-- "[2001-01-02, 2001-01-04]"
SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day'::interval);
-- "{[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_comp_operators">
			<title>Comparison Operators</title>

			<para>The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right arguments be of the same type. Excepted equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on time types. For period values, the operators compare first the lower bound, then the upper bound. For timestamp set and period set values, the operators compare first the bounding periods, and if those are equal, they compare the first N instants or periods, where N is the minimum of the number of composing instants or periods of both values.</para>

			<para>The comparison operators available for the time types are given next.</para>

			<itemizedlist>
				<listitem id="time_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Are the time values equal?</para>
					<para><varname>time = time: boolean</varname></para>
					<programlisting>
SELECT period '[2012-01-01, 2012-01-04)' = period '[2012-01-01, 2012-01-04)';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>Are the time values different?</para>
					<para><varname>time &lt;&gt; time: boolean</varname></para>
					<programlisting>
SELECT period '[2012-01-01, 2012-01-04)' &lt;&gt; period '[2012-01-03, 2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>Is the first time value less than the second one?</para>
					<para><varname>time &lt; time: boolean</varname></para>
					<programlisting>
SELECT timestampset '{2012-01-01, 2012-01-04}' &lt; timestampset '{2012-01-01, 2012-01-05}';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>Is the first time value greater than the second one?</para>
					<para><varname>time &gt; time: boolean</varname></para>
					<programlisting>
SELECT period '[2012-01-03, 2012-01-04)' &gt; period '[2012-01-02, 2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>Is the first time value less than or equal to the second one?</para>
					<para><varname>time &lt;= time: boolean</varname></para>
					<programlisting>
SELECT periodset '{[2012-01-01, 2012-01-04)}' &lt;=
  periodset '{[2012-01-01, 2012-01-05), [2012-01-06, 2012-01-07)}';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>Is the first time value greater than or equal to the second one?</para>
					<para><varname>time &gt;= time: boolean</varname></para>
					<programlisting>
SELECT period '[2012-01-03, 2012-01-05)' &gt;= period '[2012-01-03, 2012-01-04)';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_set_operators">
			<title>Set Operators</title>

			<para>The set operators available for the time types are given next.</para>

			<itemizedlist>
				<listitem id="time_union">
					<indexterm><primary><varname>+</varname></primary></indexterm>
					<para>Union of the time values</para>
					<para><varname>time + time: time</varname></para>
					<programlisting>
SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +
  timestampset '{2011-01-03, 2011-01-06}';
-- "{2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}"
SELECT period '[2011-01-01, 2011-01-05)' + period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-07)"
SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +
  period '[2011-01-03, 2011-01-04)';
-- "{[2011-01-01, 2011-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="time_intersection">
					<indexterm><primary><varname>*</varname></primary></indexterm>
					<para>Intersection of the time values</para>
					<para><varname>time * time: time</varname></para>
					<programlisting>
SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';
-- "{2011-01-03}"
SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';
-- "[2011-01-03, 2011-01-05)"
					</programlisting>
				</listitem>

				<listitem id="time_difference">
					<indexterm><primary><varname>-</varname></primary></indexterm>
					<para>Difference of the time values</para>
					<para><varname>time - time: time</varname></para>
					<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-03)"
SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'
-- "{[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}"
SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -
  periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05],
  [2011-01-08, 2011-01-09]}';
-- "{[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],
  [2011-01-07,2011-01-08), (2011-01-09,2011-01-10]}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_topo_operators">
			<title>Topological Operators</title>
			<para>The topological operators available for the time types are given next.</para>

			<itemizedlist>
				<listitem id="time_overlaps">
					<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
					<para>Do the time values overlap (have instants in common)?</para>
					<para><varname>{timestampset,period,periodset} &amp;&amp; {timestampset,period,periodset}: boolean</varname></para>
					<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_contains">
					<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
					<para>Does the first time value contain the second one?</para>
					<para><varname>{timestampset,period,periodset} @&gt; time: boolean</varname></para>
					<programlisting>
SELECT period '[2011-01-01, 2011-05-01)' @&gt; period '[2011-02-01, 2011-03-01)';
-- true
SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_containedby">
					<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
					<para>Is the first time value contained by the second one?</para>
					<para><varname>time &lt;@ {timestampset,period,periodset}: boolean</varname></para>
					<programlisting>
SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_adjacent">
					<indexterm><primary><varname>-|-</varname></primary></indexterm>
					<para>Is the first time value adjacent to the second one?</para>
					<para><varname>time -|- time: boolean</varname></para>
					<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';
-- true
SELECT periodset '{[2012-01-01, 2012-01-02]}' -|- period '[2012-01-02, 2012-01-03)';
-- false
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_relpos_operators">
			<title>Relative Position Operators</title>

			<para>In PostgreSQL, the range operators <varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&gt;</varname>, and <varname>-|-</varname> only accept ranges as left or right argument. We extended these operators for numeric ranges so that one argument may be an integer or a float.</para>

			<para>The relative position operators available for the time types and range types are given next.</para>

			<itemizedlist>
				<listitem id="range_left">
					<indexterm><primary><varname>&lt;&lt;</varname></primary></indexterm>
					<para>Is the first number or range value strictly left of the second one?</para>
					<para><varname>{number,range} &lt;&lt; {number,range}: boolean</varname></para>
					<programlisting>
SELECT intrange '[15, 20)' &lt;&lt; 20;
-- true
					</programlisting>
				</listitem>

				<listitem id="range_right">
					<indexterm><primary><varname>&gt;&gt;</varname></primary></indexterm>
					<para>Is the first number or range value strictly right of the second one?</para>
					<para><varname>{number,range} &gt;&gt; {number,range}: boolean</varname></para>
					<programlisting>
SELECT intrange '[15, 20)' &gt;&gt; 10;
-- true
					</programlisting>
				</listitem>

				<listitem id="range_overleft">
					<indexterm><primary><varname>&amp;&lt;</varname></primary></indexterm>
					<para>Is the first number or range value not to the right of the second one?</para>
					<para><varname>{number,range} &amp;&lt; {number,range}: boolean</varname></para>
					<programlisting>
SELECT intrange '[15, 20)' &amp;&lt; 18;
-- false
					</programlisting>
				</listitem>

				<listitem id="range_overright">
					<indexterm><primary><varname>&amp;&gt;</varname></primary></indexterm>
					<para>Is the first number or range value not to the left of the second one?</para>
					<para><varname>{number,range} &amp;&gt; {number,range}: boolean</varname></para>
					<programlisting>
SELECT period '[2011-01-01, 2011-01-03)' &amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
SELECT intrange '[15, 20)' &amp;&gt; 30;
-- true
					</programlisting>
				</listitem>

				<listitem id="range_adjacent">
					<indexterm><primary><varname>-|-</varname></primary></indexterm>
					<para>Is the first number or range value adjacent to the second one?</para>
					<para><varname>{number,range} -|- {number,range}: boolean</varname></para>
					<programlisting>
SELECT floatrange '[15, 20)' -|- 20;
-- true
					</programlisting>
				</listitem>

				<listitem id="time_before">
					<indexterm><primary><varname>&lt;&lt;#</varname></primary></indexterm>
					<para>Is the first time value scritly before the second one?</para>
					<para><varname>time &lt;&lt;# time: boolean</varname></para>
					<programlisting>
SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_after">
					<indexterm><primary><varname>#&gt;&gt;</varname></primary></indexterm>
					<para>Is the first time value strictly after the second one?</para>
					<para><varname>time #&gt;&gt; time: boolean</varname></para>
					<programlisting>
SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt;
  periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';
-- true
					</programlisting>
				</listitem>

				<listitem id="time_overbefore">
					<indexterm><primary><varname>&amp;&lt;#</varname></primary></indexterm>
					<para>Is the first time value not after the second one?</para>
					<para><varname>time &amp;&lt;# time: boolean</varname></para>
					<programlisting>
SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';
-- false
					</programlisting>
				</listitem>

				<listitem id="time_overafter">
					<indexterm><primary><varname>#&amp;&gt;</varname></primary></indexterm>
					<para>Is the first time value not before the second one?</para>
					<para><varname>time #&amp;&gt; time: boolean</varname></para>
					<programlisting>
SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="bucketing">
			<title>Bucketing</title>

			<itemizedlist>
				<listitem id="bucketList">
					<indexterm><primary><varname>bucketList</varname></primary></indexterm>
					<para>Returns a set of couples (index, bucket) that completely cover the period or range with buckets of the same width.</para>
					<para>If the origin is not provided, it is set by default to Monday, January 3, 2000 for periods and 0 for ranges. Notice that the bucket indices are determined by the origin.</para>
					<para><varname>bucketList(period,interval,timestamptz='2000-01-03'): setof index_period</varname></para>
					<para><varname>bucketList(range,number,number=0): setof index_range</varname></para>
					<programlisting>
SELECT bucketList(tfloat '[1@2000-01-15, 10@2000-01-25]'::period, '2 days');
-- (6,"[2000-01-15, 2000-01-17)")
   (7,"[2000-01-17, 2000-01-19)")
   (8,"[2000-01-19, 2000-01-21)")
   ...
SELECT bucketList(tfloat '[1@2000-01-15, 10@2000-01-25]'::period, '2 days',
  '2000-01-15');
-- (0,"[2000-01-15, 2000-01-17)")
   (1,"[2000-01-17, 2000-01-19)")
   (2,"[2000-01-19, 2000-01-21)")
   ...
SELECT bucketList(tfloat '[1@2000-01-15, 10@2000-01-25]'::period, '2 days',
  '2000-01-18');
-- (-2,"[2000-01-14, 2000-01-16)")
   (-1,"[2000-01-16, 2000-01-18)")
   (0,"[2000-01-18, 2000-01-20)")
   ...
SELECT bucketList(tint '[15@2000-01-01, 25@2000-01-10]'::intrange, 2);
-- (7,"[14,16)")
   (8,"[16,18)")
   (9,"[18,20)")
   ...
SELECT bucketList(tfloat '[15@2000-01-01, 25@2000-01-10]'::floatrange, 2.0, 15.0);
-- (0,"[15,17)")
   (1,"[17,19)")
   (2,"[19,21)")
   ...
SELECT bucketList(tfloat '[-1@2000-01-01, -10@2000-01-10]'::floatrange, 2);
-- (-5,"[-10,-8)")
   (-4,"[-8,-6)")
   (-3,"[-6,-4)")
   ...
					</programlisting>
				</listitem>

				<listitem id="bucketPeriod">
					<indexterm><primary><varname>bucketPeriod</varname></primary></indexterm>
					<para>Returns a <varname>period</varname> within the bucket space using the index and bucket width.</para>
					<para>If the origin is not provided, it is set by default to Monday, January 3, 2000. Notice that the bucket indices are determined by the origin.</para>
					<para><varname>bucketPeriod(integer,interval,timestamptz='2000-01-03'): period</varname></para>
					<programlisting>
SELECT bucketPeriod(2, interval '2 days');
-- [2000-01-07, 2000-01-09)
SELECT bucketPeriod(2, interval '2 days', '2020-06-15');
-- [2020-06-19, 2020-06-21)
					</programlisting>
				</listitem>

				<listitem id="bucketIntRange">
					<indexterm><primary><varname>bucketIntRange</varname></primary></indexterm>
					<para>Returns an <varname>intrange</varname> within the bucket space using the index and bucket width.</para>
					<para>If the origin is not provided, it is set by default to 0. Notice that the bucket indices are determined by the origin.</para>
					<para><varname>bucketIntRange(integer,integer,integer=0): intrange</varname></para>
					<programlisting>
SELECT bucketIntRange(2, 2);
-- [4,6)
SELECT bucketIntRange(2, 2, 1);
-- [5,7)
					</programlisting>
				</listitem>

				<listitem id="bucketFloatRange">
					<indexterm><primary><varname>bucketFloatRange</varname></primary></indexterm>
					<para>Returns a <varname>floatrange</varname> within the bucket space using the index and bucket width.</para>
					<para>If the origin is not provided, it is set by default to 0.0. Notice that the bucket indices are determined by the origin.</para>
					<para><varname>bucketFloatRange(integer,float,float=0.0): floatrange</varname></para>
					<programlisting>
SELECT bucketFloatRange(2, 2.0);
-- [4,6)
SELECT bucketFloatRange(2, 2.0, 1.0);
-- [5,7)
					</programlisting>
				</listitem>

				<listitem id="timeBucket">
					<indexterm><primary><varname>timeBucket</varname></primary></indexterm>
					<para>  Returns the start value of the bucket that contains the input <varname>timestamptz</varname>.</para>
					<para>If the origen is not specified, it is set by default to Monday, January 3, 2000.</para>
					<para><varname>timeBucket(timestamptz,interval,timestamptz='2000-01-03'): number</varname></para>
					<programlisting>
SELECT timeBucket(timestamptz '2020-06-01', interval '2 days');
-- 2020-05-31 02:00:00+02
SELECT timeBucket(timestamptz '2020-06-01', interval '2 days', timestamptz '2020-01-01');
-- 2020-05-30 01:00:00+02
					</programlisting>
				</listitem>

				<listitem id="rangeBucket">
					<indexterm><primary><varname>rangeBucket</varname></primary></indexterm>
					<para> Returns the start value of the bucket that contains the input <varname>integer</varname> o <varname>float</varname>.</para>
					<para>If the origen is not specified, it is set by default to 0.</para>
					<para><varname>rangeBucket(number,number,number=0): number</varname></para>
					<programlisting>
SELECT rangeBucket(3, 2);
-- 2
SELECT rangeBucket(3, 2.0, 1.0);
-- 3
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
				<title>Aggregate Functions</title>

				<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant in the <emphasis>union</emphasis> of the temporal extents of the values to aggregate. In contrast, recall that all other functions manipulating time types compute the value of the function at every instant in the <emphasis>intersection</emphasis> of the temporal extents of the arguments.</para>

				<para>The temporal aggregate functions are the following ones:</para>
				<itemizedlist>
					<listitem><para>Function <varname>tcount</varname> generalizes the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available objects (for example, number of periods). Function <varname>tcount</varname> returns a temporal integer (see <xref linkend="temporal_types" />).</para></listitem>
					<listitem><para>Function <varname>extent</varname> returns a bounding period that encloses a set of time values.</para></listitem>
				</itemizedlist>

				<para>Union is a very useful operation for time types. As we have seen in <xref linkend="time_set_operators" />, we can compute the union of two time values using the <varname>+</varname> operator. However, it is also very useful to have an aggregate version of the union operator for combining an arbitrary number of values. Function <varname>tunion</varname> can be used for this purpose.
				</para>

				<itemizedlist>
					<listitem id="time_tcount">
						<indexterm><primary><varname>tcount</varname></primary></indexterm>
						<para>Temporal count</para>
						<para><varname>tcount({timestampset,period,periodset}): {tinti,tints}</varname></para>
						<programlisting>
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tcount(ts) FROM times;
-- "{2@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-04, 1@2000-01-05, 1@2000-01-06}"

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT tcount(ps) FROM periods;
-- {[2@2000-01-01, 3@2000-01-02], (2@2000-01-02, 3@2000-01-03, 3@2000-01-04],
   (1@2000-01-04, 2@2000-01-05, 2@2000-01-06]}
						</programlisting>
					</listitem>

					<listitem id="time_extent">
						<indexterm><primary><varname>extent</varname></primary></indexterm>
						<para>Bounding period</para>
						<para><varname>extent({timestampset,period,periodset}): period</varname></para>
						<programlisting>
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT extent(ts) FROM times;
-- "[2000-01-01, 2000-01-06]"

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT extent(ps) FROM periods;
-- "[2000-01-01, 2000-01-06]"
					</programlisting>
				</listitem>

				<listitem id="tunion">
					<indexterm><primary><varname>tunion</varname></primary></indexterm>
					<para>Temporal union</para>
					<para><varname>tunion({timestampset,period,periodset}): {timestampset,periodset}</varname></para>
					<programlisting>
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tunion(ts) FROM times;
-- "{2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05, 2000-01-06}"
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-03], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-07, 2000-01-08]}'
)
SELECT tunion(ps) FROM periods;
-- "{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06], [2000-01-07, 2000-01-08]}"
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
</sect1>

	<sect1 id ="indexing_time_types">
		<title>Indexing of Time Types</title>

		<para>GiST and SP-GiST indexes can be created for table columns of the <varname>timestampset</varname>, <varname>period</varname>, and <varname>periodset</varname> types. An example of creation of a GiST index in a column <varname>During</varname> of type <varname>period</varname> in a table <varname>Reservation</varname> is as follows:
				<programlisting>
CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,
  During period);
CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);
				</programlisting>
		</para>
		<para>A GiST or SP-GiST index can accelerate queries involving the following operators: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname>.</para>
		<para>In addition, B-tree indexes can be created for table columns of a time type. For these index types, basically the only useful operation is equality. There is a B-tree sort ordering defined for values of time types with corresponding <varname>&lt;</varname> and <varname>&gt;</varname> operators, but the ordering is rather arbitrary and not usually useful in the real world. The B-tree support is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>
	</sect1>
</chapter>
