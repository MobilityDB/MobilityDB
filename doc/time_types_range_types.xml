<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter id="time_types_range_types">
	<title>Time Types and Range Types</title>

	<para>
		Temporal types are based on four time types: the <varname>timestamptz</varname> type provided by PostgreSQL and three new types which are <varname>period</varname>, <varname>timestampset</varname>, and <varname>periodset</varname>.
	</para>

	<para>
		The <varname>period</varname> type is a specialized version of the <varname>tstzrange</varname> (short for timestamp with time zone range) type provided by PostgreSQL. Type <varname>period</varname> has similar functionality as type <varname>tstzrange</varname> but has a more efficient implementation, in particular it is of fixed length while the <varname>tstzrange</varname> type is of variable length. Furthermore, empty periods and infinite bounds are not allowed in <varname>period</varname> values, while they are allowed in <varname>tstzrange</varname> values.
	</para>

	<para>
		A value of the <varname>period</varname> type has two bounds, the lower bound and the upper bound, which are <varname>timestamptz</varname> values. The bounds can be inclusive or exclusive. An inclusive bound means that the boundary instant is included in the period, while an exclusive bound means that the boundary instant is not included in the period. In the text form of a <varname>period</varname> value, inclusive and exclusive lower bounds are represented, respectively, by &ldquo;<varname>[</varname>&rdquo; and &ldquo;<varname>(</varname>&rdquo;. Likewise, inclusive and exclusive upper bounds are represented, respectively, by &ldquo;<varname>]</varname>&rdquo; and &ldquo;<varname>)</varname>&rdquo;. In a <varname>period</varname> value, the lower bound must be less than or equal to the upper bound. A <varname>period</varname> value with equal and inclusive bounds is called an <emphasis>instantaneous period</emphasis> and corresponds to a <varname>timestamptz</varname> value. Examples of <varname>period</varname> values are as follows:
	</para>
	<programlisting xml:space="preserve">
SELECT period '[2012-01-01 08:00:00, 2012-01-03 09:30:00)';
-- Instant period
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00]';
-- Erroneous period: invalid bounds
SELECT period '[2012-01-01 08:10:00, 2012-01-01 08:00:00]';
-- Erroneous period: empty period
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00)';
</programlisting>

	<para>
		The <varname>timestampset</varname> type represents a set of different <varname>timestamptz</varname> values. A <varname>timestampset</varname> value must contain at least one element, in which case it corresponds to a <varname>timestamptz</varname> value. The elements composing a <varname>timestampset</varname> value must be ordered. Examples of <varname>timestampset</varname> values are as follows:
	</para>
	<programlisting xml:space="preserve">
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-03 09:30:00}';
-- Singleton timestampset
SELECT timestampset '{2012-01-01 08:00:00}';
-- Erroneous timestampset: unordered elements
SELECT timestampset '{2012-01-01 08:10:00, 2012-01-01 08:00:00}';
-- Erroneous timestampset: duplicate elements
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-01 08:00:00}';
</programlisting>

	<para>
		Finally, the <varname>periodset</varname> type represents a set of disjoint <varname>period</varname> values. A <varname>periodset</varname> value must contain at least one element, in which case it corresponds to a <varname>period</varname> value. The elements composing a <varname>periodset</varname> value must be ordered. Examples of <varname>periodset</varname> values are as follows:
	</para>
	<programlisting xml:space="preserve">
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
  [2012-01-01 08:20:00, 2012-01-01 08:40:00]}';
-- Singleton periodset
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- Erroneous periodset: unordered elements
SELECT periodset '{[2012-01-01 08:20:00, 2012-01-01 08:40:00],
  [2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- Erroneous periodset: overlapping elements
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
  [2012-01-01 08:05:00, 2012-01-01 08:15:00]}';
</programlisting>

	<para>
		Values of the <varname>periodset</varname> type are converted into <emphasis>normal form</emphasis> so that equivalent values have identical representations. For this, consecutive adjacent period values are merged when possible. An example of transformation into normal form is as follows:
	</para>
	<programlisting xml:space="preserve">
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00),
  [2012-01-01 08:10:00, 2012-01-01 08:10:00], (2012-01-01 08:10:00, 2012-01-01 08:20:00]}';
-- "{[2012-01-01 08:00:00+00,2012-01-01 08:20:00+00]}"
</programlisting>

	<para>
		Besides the built-in range types provided by PostgreSQL, MobilityDB defines two additional range types: <varname>intrange</varname> (another name for <varname>int4range</varname>) and <varname>floatrange</varname>.
	</para>

	<sect1 id ="functions_operations_time_types">
		<title>Functions and Operators for Time Types and Range Types</title>

		<para>
			We present next the functions and operators for time and range types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this in the signature of the operators, we use the following notation:
		</para>
		<itemizedlist>
			<listitem>
				<para>A set of types such as <varname>{period,timestampset,periodset}</varname> represents any of the types listed,</para>
			</listitem>
			<listitem>
				<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
			</listitem>
			<listitem>
				<para><varname>number</varname> represents any number type, that is, <varname>integer</varname> or <varname>float</varname>,</para>
			</listitem>
			<listitem>
				<para><varname>range</varname> represents any number range type, that is, <varname>intrange</varname> or <varname>floatrange</varname>.</para>
			</listitem>
			<listitem>
				<para><varname>type[]</varname> represents an array of <varname>type</varname>.</para>
			</listitem>
		</itemizedlist>

		<para>
			As an example, the signature of the contains operator (<varname>@&gt;</varname>) is as follows:
		</para>
		<programlisting xml:space="preserve">
{timestampset, period, periodset} @&gt; time: boolean
</programlisting>
		<para>
			In the following, for conciseness, the time part of the timestamps is omitted in the examples. Recall that in that case PostgreSQL assumes the time <varname>00:00:00</varname>.
		</para>

		<sect2>
			<title>Constructor Functions</title>

			<para>The <varname>period</varname> type has a constructor function that accepts two or four arguments. The two-argument form constructs a period in <emphasis>normal form</emphasis>, that is, with inclusive lower bound and exclusive upper bound. The four-argument form constructs a period with bounds specified by the third and fourth arguments, which are Boolean values stating, respectively, whether the left and right bounds are inclusive or not.
			</para>
			<itemizedlist>
				<listitem id="period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Constructor for <varname>period</varname></para>
					<para><varname>period(timestamptz,timestamptz,left_inc=true,right_inc=false): period</varname></para>
					<programlisting xml:space="preserve">
-- Period defined with two arguments
SELECT period('2012-01-01 08:00:00', '2012-01-03 08:00:00');
-- [2012-01-01 08:00:00+01, 2012-01-03 08:00:00+01)
-- Period defined with four arguments
SELECT period('2012-01-01 08:00:00', '2012-01-03 09:30:00', false, true);
-- (2012-01-01 08:00:00+01, 2012-01-03 09:30:00+01]
</programlisting>
				</listitem>
			</itemizedlist>

			<para>The <varname>timestampset</varname> type has a constructor function that accepts a single argument which is an array of <varname>timestamptz</varname> values.
			</para>
			<itemizedlist>
				<listitem id="timestampset">
					<indexterm><primary><varname>timestampset</varname></primary></indexterm>
					<para>Constructor for <varname>timestampset</varname></para>
					<para><varname>timestampset(timestamptz[]): timestampset</varname></para>
					<programlisting xml:space="preserve">
SELECT timestampset(ARRAY[timestamptz '2012-01-01 08:00:00', '2012-01-03 09:30:00']);
-- "{2012-01-01 08:00:00+00, 2012-01-03 09:30:00+00}"
</programlisting>
				</listitem>
			</itemizedlist>

			<para>The <varname>periodset</varname> type has a constructor function that accepts a single argument which is an array of <varname>period</varname> values.
			</para>
			<itemizedlist>
				<listitem id="periodset">
					<indexterm><primary><varname>periodset</varname></primary></indexterm>
					<para>Constructor for <varname>periodset</varname></para>
					<para><varname>periodset(period[]): periodset</varname></para>
					<programlisting xml:space="preserve">
SELECT periodset(ARRAY[period '[2012-01-01 08:00:00, 2012-01-01 08:10:00]',
-- '[2012-01-01 08:20:00, 2012-01-01 08:40:00]']);
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Casting</title>
			<para>Values of the <varname>timestamptz</varname>, <varname>tstzrange</varname>, or the time types can be converted to one another using the function <varname>CAST</varname> or using the <varname>::</varname> notation.
			</para>

			<itemizedlist>
				<listitem id="timestamptz_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestamptz</varname> to another time type</para>
					<para><varname>timestamptz::timestampset</varname></para>
					<para><varname>timestamptz::period</varname></para>
					<para><varname>timestamptz::periodset</varname></para>
					<programlisting xml:space="preserve">
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS timestampset);
-- "{2012-01-01 08:00:00+01}"
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS period);
-- "[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]"
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS periodset);
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]}"
</programlisting>
				</listitem>
				<listitem id="timestampset_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>timestampset</varname> to a <varname>periodset</varname></para>
					<para><varname>timestampset::periodset</varname></para>
					<programlisting xml:space="preserve">
SELECT CAST(timestampset '{2012-01-01 08:00:00, 2012-01-01 08:15:00,
  2012-01-01 08:25:00}' AS periodset);
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01],
  [2012-01-01 08:15:00+01, 2012-01-01 08:15:00+01],
  [2012-01-01 08:25:00+01, 2012-01-01 08:25:00+01]}"
</programlisting>
				</listitem>
				<listitem id="period_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>period</varname> to another time type</para>
					<para><varname>period::periodset</varname></para>
					<para><varname>period::tstzrange</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::periodset;
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)}"
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::tstzrange;
-- "["2012-01-01 08:00:00+01","2012-01-01 08:30:00+01")"
</programlisting>
				</listitem>
				<listitem id="tstzrange_cast">
					<indexterm><primary><varname>::</varname></primary></indexterm>
					<para>Cast a <varname>tstzrange</varname> to a <varname>period</varname></para>
					<para><varname>tstzrange::period</varname></para>
					<programlisting xml:space="preserve">
SELECT tstzrange '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::period;
-- "[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)"
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Accessor Functions</title>

			<itemizedlist>
				<listitem id="time_memSize">
					<indexterm><primary><varname>memSize</varname></primary></indexterm>
					<para>Get the memory size in bytes</para>
					<para><varname>memSize({timestampset,periodset}): integer</varname></para>
					<programlisting xml:space="preserve">
SELECT memSize(timestampset '{2012-01-01, 2012-01-02, 2012-01-03}');
-- 104
SELECT memSize(periodset '{[2012-01-01, 2012-01-02], [2012-01-03, 2012-01-04],
  [2012-01-05, 2012-01-06]}');
-- 136
</programlisting>
				</listitem>

				<listitem id="lower">
					<indexterm><primary><varname>lower</varname></primary></indexterm>
					<para>Get the lower bound</para>
					<para><varname>lower(period): timestamptz</varname></para>
					<programlisting xml:space="preserve">
SELECT lower(period '[2011-01-01, 2011-01-05)');
-- "2011-01-01"
</programlisting>
				</listitem>

				<listitem id="upper">
					<indexterm><primary><varname>upper</varname></primary></indexterm>
					<para>Get the upper bound</para>
					<para><varname>upper(period): timestamptz</varname></para>
					<programlisting xml:space="preserve">
SELECT upper(period '[2011-01-01, 2011-01-05)');
-- "2011-01-05"
</programlisting>
				</listitem>

				<listitem id="lower_inc">
					<indexterm><primary><varname>lower_inc</varname></primary></indexterm>
					<para>Is the lower bound inclusive?</para>
					<para><varname>lower_inc(period): boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT lower_inc(period '[2011-01-01, 2011-01-05)');
-- true
</programlisting>
				</listitem>

				<listitem id="upper_inc">
					<indexterm><primary><varname>upper_inc</varname></primary></indexterm>
					<para>Is the upper bound inclusive?</para>
					<para><varname>upper_inc(period): boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT upper_inc(period '[2011-01-01, 2011-01-05)');
-- false
</programlisting>
				</listitem>

				<listitem id="time_duration">
					<indexterm><primary><varname>duration</varname></primary></indexterm>
					<para>Get the duration</para>
					<para><varname>duration({period,periodset}): interval</varname></para>
					<programlisting xml:space="preserve">
SELECT duration(period '[2012-01-01, 2012-01-03)');
-- "2 days"
SELECT duration(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "3 days"
</programlisting>
				</listitem>

				<listitem id="time_timespan">
					<indexterm><primary><varname>timespan</varname></primary></indexterm>
					<para>Get the timespan ignoring the potential time gaps</para>
					<para><varname>timespan({timestampset,periodset}): interval</varname></para>
					<programlisting xml:space="preserve">
SELECT timespan(timestampset '{2012-01-01, 2012-01-03}');
-- "2 days"
SELECT timespan(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "4 days"
</programlisting>
				</listitem>

				<listitem id="time_period">
					<indexterm><primary><varname>period</varname></primary></indexterm>
					<para>Get the period on which the timestamp set or period set is defined ignoring the potential time gaps</para>
					<para><varname>period({timestampset,periodset}): period</varname></para>
					<programlisting xml:space="preserve">
SELECT period(timestampset '{2012-01-01, 2012-01-03, 2012-01-05}');
-- "[2012-01-01, 2012-01-05]"
SELECT period(periodset '{[2012-01-01, 2012-01-02), [2012-01-03, 2012-01-04)}');
-- "[2012-01-01, 2012-01-04)"
</programlisting>
				</listitem>

				<listitem id="time_numTimestamps">
					<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
					<para>Get the number of different timestamps</para>
					<para><varname>numTimestamps({timestampset,periodset}): integer</varname></para>
					<programlisting xml:space="preserve">
SELECT numTimestamps(timestampset '{2012-01-01, 2012-01-03, 2012-01-04}');
-- 3
SELECT numTimestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="time_startTimestamp">
					<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
					<para>Get the start timestamp</para>
					<para><varname>startTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting xml:space="preserve">
SELECT startTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-01"
</programlisting>
				</listitem>

				<listitem id="time_endTimestamp">
					<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
					<para>Get the end timestamp</para>
					<para><varname>endTimestamp({timestampset,periodset}): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting xml:space="preserve">
SELECT endTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-05"
</programlisting>
				</listitem>

				<listitem id="time_timestampN">
					<indexterm><primary><varname>timestampN</varname></primary></indexterm>
					<para>Get the n-th different timestamp</para>
					<para><varname>timestampN({timestampset,periodset},integer): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting xml:space="preserve">
SELECT timestampN(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}', 3);
-- "2012-01-04"
</programlisting>
				</listitem>

				<listitem id="time_timestamps">
					<indexterm><primary><varname>timestamps</varname></primary></indexterm>
					<para>Get the different timestamps</para>
					<para><varname>timestamps({timestampset,periodset}): timestampset</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting xml:space="preserve">
SELECT timestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "{"2012-01-01", "2012-01-03", "2012-01-05"}"
</programlisting>
				</listitem>

				<listitem id="numPeriods">
					<indexterm><primary><varname>numPeriods</varname></primary></indexterm>
					<para>Get the number of periods</para>
					<para><varname>numPeriods(periodset): integer</varname></para>
					<programlisting xml:space="preserve">
SELECT numPeriods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- 3
</programlisting>
				</listitem>

				<listitem id="startPeriod">
					<indexterm><primary><varname>startPeriod</varname></primary></indexterm>
					<para>Get the start period</para>
					<para><varname>startPeriod(periodset): period</varname></para>
					<programlisting xml:space="preserve">
SELECT startPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- "[2012-01-01,2012-01-03)"
</programlisting>
				</listitem>

				<listitem id="endPeriod">
					<indexterm><primary><varname>endPeriod</varname></primary></indexterm>
					<para>Get the end period</para>
					<para><varname>endPeriod(periodset): period</varname></para>
					<programlisting xml:space="preserve">
SELECT endPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- "[2012-01-05,2012-01-06)"
</programlisting>
				</listitem>

				<listitem id="periodN">
					<indexterm><primary><varname>periodN</varname></primary></indexterm>
					<para>Get the n-th period</para>
					<para><varname>periodN(periodset,integer): period</varname></para>
					<programlisting xml:space="preserve">
SELECT periodN(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}', 2);
-- "[2012-01-04,2012-01-04]"
</programlisting>
				</listitem>

				<listitem id="periods">
					<indexterm><primary><varname>periods</varname></primary></indexterm>
					<para>Get the periods</para>
					<para><varname>periods(periodset): period[]</varname></para>
					<programlisting xml:space="preserve">
SELECT periods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
  [2012-01-05, 2012-01-06)}');
-- "{"[2012-01-01,2012-01-03)", "[2012-01-04,2012-01-04]", "[2012-01-05,2012-01-06)"}"
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id ="modification_time_tyes">
			<title>Modification Functions</title>

			<itemizedlist>
				<listitem id="time_shift">
					<indexterm><primary><varname>shift</varname></primary></indexterm>
					<para>Shift the time value by an interval</para>
					<para><varname>shift({timestampset,period,periodset}): {timestampset,period,periodset}</varname></para>
					<programlisting xml:space="preserve">
SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);
-- "{2001-01-02, 2001-01-04, 2001-01-06}"
SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);
-- "[2001-01-02, 2001-01-04]"
SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day'::interval);
-- "{[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}"
</programlisting>
				</listitem>

			<listitem id="time_tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Scale the time value to an interval. If the time span of the time value is zero (for example, for a singleton instant set), the result is the time value. The given interval must be strictly greater than zero.</para>
				<para><varname>tscale({timestampset,period,periodset},interval): {timestampset,period,periodset}</varname></para>
				<programlisting xml:space="preserve">
SELECT tscale(timestampset '{2001-01-01}', '1 day');
-- {2001-01-01}
SELECT tscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '2 days');
-- {2001-01-01, 2001-01-02, 2001-01-03}
SELECT tscale(period '[2001-01-01, 2001-01-03]', '1 day');
-- [2001-01-01, 2001-01-02]
SELECT tscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}', '1 day');
-- {[2001-01-01 00:00:00, 2001-01-01 12:00:00],
  [2001-01-01 18:00:00, 2001-01-02 00:00:00]}
SELECT tscale(timestampset '{2001-01-01}', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
</programlisting>
			</listitem>

			<listitem id="time_shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Shift and scale the time value to the two intervals. This function combines in a single step the functions <link linkend="time_shift"><varname>shift</varname></link> and <link linkend="time_tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale({timestampset,period,periodset},interval,interval):</varname></para>
				<para><varname>  {timestampset,period,periodset}</varname></para>
				<programlisting xml:space="preserve">
SELECT shiftTscale(timestampset '{2001-01-01}', '1 day', '1 day');
-- {2001-01-02}
SELECT shiftTscale(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day','2 days');
-- {2001-01-02, 2001-01-03, 2001-01-04}
SELECT shiftTscale(period '[2001-01-01, 2001-01-03]', '1 day', '1 day');
-- [2001-01-02, 2001-01-03]
SELECT shiftTscale(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}',
  '1 day', '1 day');
-- {[2001-01-02 00:00:00, 2001-01-02 12:00:00],
  [2001-01-02 18:00:00, 2001-01-03 00:00:00]}
</programlisting>
			</listitem>

				<listitem id="floatrange_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Round the bounds of a float range to a number of decimal places</para>
					<para><varname>round(floatrange,integer): floatrange</varname></para>
					<programlisting xml:space="preserve">
SELECT round(floatrange '[1.123456789,2.123456789)', 3);
-- "[1.123,2.123)"
SELECT round(floatrange '(,2.123456789]', 3);
-- "(,2.123]"
SELECT round(floatrange '[1.123456789, inf)', 3);
-- "[1.123,Infinity)"
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_comp_operators">
			<title>Comparison Operators</title>

			<para>The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right arguments be of the same type. Excepted equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on time types. For period values, the operators compare first the lower bound, then the upper bound. For timestamp set and period set values, the operators compare first the bounding periods, and if those are equal, they compare the first N instants or periods, where N is the minimum of the number of composing instants or periods of both values.</para>

			<para>The comparison operators available for the time types are given next.</para>

			<itemizedlist>
				<listitem id="time_eq">
					<indexterm><primary><varname>=</varname></primary></indexterm>
					<para>Are the time values equal?</para>
					<para><varname>time = time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2012-01-01, 2012-01-04)' = period '[2012-01-01, 2012-01-04)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_ne">
					<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
					<para>Are the time values different?</para>
					<para><varname>time &lt;&gt; time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2012-01-01, 2012-01-04)' &lt;&gt; period '[2012-01-03, 2012-01-05)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_lt">
					<indexterm><primary><varname>&lt;</varname></primary></indexterm>
					<para>Is the first time value less than the second one?</para>
					<para><varname>time &lt; time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT timestampset '{2012-01-01, 2012-01-04}' &lt; timestampset '{2012-01-01, 2012-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_gt">
					<indexterm><primary><varname>&gt;</varname></primary></indexterm>
					<para>Is the first time value greater than the second one?</para>
					<para><varname>time &gt; time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2012-01-03, 2012-01-04)' &gt; period '[2012-01-02, 2012-01-05)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_le">
					<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
					<para>Is the first time value less than or equal to the second one?</para>
					<para><varname>time &lt;= time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT periodset '{[2012-01-01, 2012-01-04)}' &lt;=
  periodset '{[2012-01-01, 2012-01-05), [2012-01-06, 2012-01-07)}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_ge">
					<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
					<para>Is the first time value greater than or equal to the second one?</para>
					<para><varname>time &gt;= time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2012-01-03, 2012-01-05)' &gt;= period '[2012-01-03, 2012-01-04)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_set_operators">
			<title>Set Operators</title>

			<para>The set operators available for the time types are given next.</para>

			<itemizedlist>
				<listitem id="time_union">
					<indexterm><primary><varname>+</varname></primary></indexterm>
					<para>Union of the time values</para>
					<para><varname>time + time: time</varname></para>
					<programlisting xml:space="preserve">
SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +
  timestampset '{2011-01-03, 2011-01-06}';
-- "{2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}"
SELECT period '[2011-01-01, 2011-01-05)' + period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-07)"
SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +
  period '[2011-01-03, 2011-01-04)';
-- "{[2011-01-01, 2011-01-05)}"
</programlisting>
				</listitem>

				<listitem id="time_intersection">
					<indexterm><primary><varname>*</varname></primary></indexterm>
					<para>Intersection of the time values</para>
					<para><varname>time * time: time</varname></para>
					<programlisting xml:space="preserve">
SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';
-- "{2011-01-03}"
SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';
-- "[2011-01-03, 2011-01-05)"
</programlisting>
				</listitem>

				<listitem id="time_difference">
					<indexterm><primary><varname>-</varname></primary></indexterm>
					<para>Difference of the time values</para>
					<para><varname>time - time: time</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-03)"
SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'
-- "{[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}"
SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -
  periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05],
  [2011-01-08, 2011-01-09]}';
-- "{[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],
  [2011-01-07,2011-01-08), (2011-01-09,2011-01-10]}"
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_topo_operators">
			<title>Topological Operators</title>
			<para>The topological operators available for the time types are given next.</para>

			<itemizedlist>
				<listitem id="time_overlaps">
					<indexterm><primary><varname>&amp;&amp;</varname></primary></indexterm>
					<para>Do the time values overlap (have instants in common)?</para>
					<para><varname>{timestampset,period,periodset} &amp;&amp; {timestampset,period,periodset}: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_contains">
					<indexterm><primary><varname>@&gt;</varname></primary></indexterm>
					<para>Does the first time value contain the second one?</para>
					<para><varname>{timestampset,period,periodset} @&gt; time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-01-01, 2011-05-01)' @&gt; period '[2011-02-01, 2011-03-01)';
-- true
SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';
-- true
</programlisting>
				</listitem>

				<listitem id="time_containedby">
					<indexterm><primary><varname>&lt;@</varname></primary></indexterm>
					<para>Is the first time value contained by the second one?</para>
					<para><varname>time &lt;@ {timestampset,period,periodset}: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
</programlisting>
				</listitem>

				<listitem id="time_adjacent">
					<indexterm><primary><varname>-|-</varname></primary></indexterm>
					<para>Is the first time value adjacent to the second one?</para>
					<para><varname>time -|- time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';
-- true
SELECT periodset '{[2012-01-01, 2012-01-02]}' -|- period '[2012-01-02, 2012-01-03)';
-- false
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="time_relpos_operators">
			<title>Relative Position Operators</title>

			<para>In PostgreSQL, the range operators <varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&gt;</varname>, and <varname>-|-</varname> only accept ranges as left or right argument. We extended these operators for numeric ranges so that one argument may be an integer or a float.</para>

			<para>The relative position operators available for the time types and range types are given next.</para>

			<itemizedlist>
				<listitem id="range_left">
					<indexterm><primary><varname>&lt;&lt;</varname></primary></indexterm>
					<para>Is the first number or range value strictly left of the second one?</para>
					<para><varname>{number,range} &lt;&lt; {number,range}: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT intrange '[15, 20)' &lt;&lt; 20;
-- true
</programlisting>
				</listitem>

				<listitem id="range_right">
					<indexterm><primary><varname>&gt;&gt;</varname></primary></indexterm>
					<para>Is the first number or range value strictly right of the second one?</para>
					<para><varname>{number,range} &gt;&gt; {number,range}: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT intrange '[15, 20)' &gt;&gt; 10;
-- true
</programlisting>
				</listitem>

				<listitem id="range_overleft">
					<indexterm><primary><varname>&amp;&lt;</varname></primary></indexterm>
					<para>Is the first number or range value not to the right of the second one?</para>
					<para><varname>{number,range} &amp;&lt; {number,range}: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT intrange '[15, 20)' &amp;&lt; 18;
-- false
</programlisting>
				</listitem>

				<listitem id="range_overright">
					<indexterm><primary><varname>&amp;&gt;</varname></primary></indexterm>
					<para>Is the first number or range value not to the left of the second one?</para>
					<para><varname>{number,range} &amp;&gt; {number,range}: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-01-01, 2011-01-03)' &amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
SELECT intrange '[15, 20)' &amp;&gt; 30;
-- true
</programlisting>
				</listitem>

				<listitem id="range_adjacent">
					<indexterm><primary><varname>-|-</varname></primary></indexterm>
					<para>Is the first number or range value adjacent to the second one?</para>
					<para><varname>{number,range} -|- {number,range}: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT floatrange '[15, 20)' -|- 20;
-- true
</programlisting>
				</listitem>

				<listitem id="time_before">
					<indexterm><primary><varname>&lt;&lt;#</varname></primary></indexterm>
					<para>Is the first time value scritly before the second one?</para>
					<para><varname>time &lt;&lt;# time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_after">
					<indexterm><primary><varname>#&gt;&gt;</varname></primary></indexterm>
					<para>Is the first time value strictly after the second one?</para>
					<para><varname>time #&gt;&gt; time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt;
  periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';
-- true
</programlisting>
				</listitem>

				<listitem id="time_overbefore">
					<indexterm><primary><varname>&amp;&lt;#</varname></primary></indexterm>
					<para>Is the first time value not after the second one?</para>
					<para><varname>time &amp;&lt;# time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';
-- false
</programlisting>
				</listitem>

				<listitem id="time_overafter">
					<indexterm><primary><varname>#&amp;&gt;</varname></primary></indexterm>
					<para>Is the first time value not before the second one?</para>
					<para><varname>time #&amp;&gt; time: boolean</varname></para>
					<programlisting xml:space="preserve">
SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Distance Operators</title>

			<para>There are two distance operators for time types. These operators work with bouding periods and compute both the smallest distance between the two time values but they differ in the result type: the <varname>&lt;-&gt;</varname> operator returns a standard SQL type <varname>interval</varname>, while the <varname>|=|</varname> operator returns a <varname>float</varname> which is the number of seconds between the two time values. The latter operator can also be used for nearest neighbor searches using a GiST or an SP-GiST index (see <xref linkend="indexing_time_types" />).</para>

			<itemizedlist>
				<listitem id="smallest_distance_interval">
					<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
					<para>Get the smallest distance ever in an interval</para>
					<para><varname>time &lt;-&gt; time: interval</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2012-01-02, 2012-01-06)' &lt;-&gt; timestamptz '2012-01-07';
-- 1 day
SELECT timestampset '{2012-01-01, 2012-01-03, 2012-01-05}' &lt;-&gt;
  timestampset '{2012-01-02, 2012-01-04}';
--  00:00:00
</programlisting>
				</listitem>

				<listitem id="smallest_distance_secs">
					<indexterm><primary><varname>|=|</varname></primary></indexterm>
					<para>Get the smallest distance ever in number of seconds</para>
					<para><varname>time |=| time: float</varname></para>
					<programlisting xml:space="preserve">
SELECT period '[2012-01-02, 2012-01-06)' |=| timestamptz '2012-01-07';
-- 86400
SELECT timestampset '{2012-01-01, 2012-01-03, 2012-01-05}' |=|
  timestampset '{2012-01-02, 2012-01-04}';
--  0
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Aggregate Functions</title>

			<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant in the <emphasis>union</emphasis> of the temporal extents of the values to aggregate. In contrast, recall that all other functions manipulating time types compute the value of the function at every instant in the <emphasis>intersection</emphasis> of the temporal extents of the arguments.</para>

			<para>The temporal aggregate functions are the following ones:</para>
			<itemizedlist>
				<listitem><para>Function <varname>tcount</varname> generalizes the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available objects (for example, number of periods). Function <varname>tcount</varname> returns a temporal integer (see <xref linkend="temporal_types" />).</para></listitem>
				<listitem><para>Function <varname>extent</varname> returns a bounding period that encloses a set of time values.</para></listitem>
			</itemizedlist>

			<para>Similarly, there is an aggregate function for range types:</para>
			<itemizedlist>
				<listitem><para>Function <varname>extent</varname> returns a bounding range that encloses a set of integer or float range values.</para></listitem>
			</itemizedlist>

			<para>Union is a very useful operation for time types. As we have seen in <xref linkend="time_set_operators" />, we can compute the union of two time values using the <varname>+</varname> operator. However, it is also very useful to have an aggregate version of the union operator for combining an arbitrary number of values. Function <varname>tunion</varname> can be used for this purpose.
			</para>

			<itemizedlist>
				<listitem id="time_tcount">
					<indexterm><primary><varname>tcount</varname></primary></indexterm>
					<para>Temporal count</para>
					<para><varname>tcount({timestampset,period,periodset}): {tint_instset,tint_seqset}</varname></para>
					<programlisting xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tcount(ts) FROM times;
-- "{2@2000-01-01, 2@2000-01-02, 1@2000-01-03, 1@2000-01-04, 1@2000-01-05, 1@2000-01-06}"

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT tcount(ps) FROM periods;
-- {[2@2000-01-01, 3@2000-01-02], (2@2000-01-02, 3@2000-01-03, 3@2000-01-04],
   (1@2000-01-04, 2@2000-01-05, 2@2000-01-06]}
</programlisting>
				</listitem>

				<listitem id="time_extent">
					<indexterm><primary><varname>extent</varname></primary></indexterm>
					<para>Bounding period</para>
					<para><varname>extent({timestampset,period,periodset}): period</varname></para>
					<programlisting xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT extent(ts) FROM times;
-- "[2000-01-01, 2000-01-06]"

WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-06]}'
)
SELECT extent(ps) FROM periods;
-- "[2000-01-01, 2000-01-06]"
</programlisting>
				</listitem>

				<listitem id="range_extent">
					<indexterm><primary><varname>extent</varname></primary></indexterm>
					<para>Bounding range</para>
					<para><varname>extent(range): range</varname></para>
					<programlisting xml:space="preserve">
WITH ranges(r) AS (
  SELECT floatrange '[1, 4)' UNION
  SELECT floatrange '(5, 8)' UNION
  SELECT floatrange '(7, 9)'
)
SELECT extent(r) FROM ranges;
-- "[1,9)"
</programlisting>
				</listitem>

				<listitem id="tunion">
					<indexterm><primary><varname>tunion</varname></primary></indexterm>
					<para>Temporal union</para>
					<para><varname>tunion({timestampset,period,periodset}): {timestampset,periodset}</varname></para>
					<programlisting xml:space="preserve">
WITH times(ts) AS (
  SELECT timestampset '{2000-01-01, 2000-01-03, 2000-01-05}' UNION
  SELECT timestampset '{2000-01-02, 2000-01-04, 2000-01-06}' UNION
  SELECT timestampset '{2000-01-01, 2000-01-02}'
)
SELECT tunion(ts) FROM times;
-- "{2000-01-01, 2000-01-02, 2000-01-03, 2000-01-04, 2000-01-05, 2000-01-06}"
WITH periods(ps) AS (
  SELECT periodset '{[2000-01-01, 2000-01-02], [2000-01-03, 2000-01-04]}' UNION
  SELECT periodset '{[2000-01-02, 2000-01-03], [2000-01-05, 2000-01-06]}' UNION
  SELECT periodset '{[2000-01-07, 2000-01-08]}'
)
SELECT tunion(ps) FROM periods;
-- "{[2000-01-01, 2000-01-04], [2000-01-05, 2000-01-06], [2000-01-07, 2000-01-08]}"
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>

	<sect1 id ="indexing_time_types">
		<title>Indexing of Time Types</title>

		<para>GiST and SP-GiST indexes can be created for table columns of the <varname>timestampset</varname>, <varname>period</varname>, and <varname>periodset</varname> types. The GiST index implements an R-tree while the SP-GiST index implements a quad-tree. An example of creation of a GiST index in a column <varname>During</varname> of type <varname>period</varname> in a table <varname>Reservation</varname> is as follows:
			<programlisting xml:space="preserve">
CREATE TABLE Reservation (ReservationID integer PRIMARY KEY, RoomID integer,
  During period);
CREATE INDEX Reservation_During_Idx ON Reservation USING GIST(During);
</programlisting>
		</para>
		<para>A GiST or an SP-GiST index can accelerate queries involving the following operators: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, and <varname>|=|</varname>.</para>
		<para>In addition, B-tree indexes can be created for table columns of a time type. For these index types, basically the only useful operation is equality. There is a B-tree sort ordering defined for values of time types with corresponding <varname>&lt;</varname> and <varname>&gt;</varname> operators, but the ordering is rather arbitrary and not usually useful in the real world. The B-tree support is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>
	</sect1>
</chapter>
