<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
	<sect1>
		<title>Spatial Functions and Operators</title>
		<para>In the following, we specify with the symbol &Z_support; that the function supports 3D points and with the symbol &geography_support; that the function is available for geographies.</para>

		<sect2 id="tpoint_inout">
			<title>Input/Output Functions</title>

			<itemizedlist>
				<listitem id="asText">
					<indexterm><primary><varname>asText</varname></primary></indexterm>
					<para>Get the Well-Known Text (WKT) representation &Z_support; &geography_support;</para>
					<para><varname>asText({tpoint,tpoint[],geo[]}): {text,text[]}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02)');
-- [POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02)
SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);
-- {"POINT(0 0)","POINT(1 1)"}
</programlisting>
				</listitem>

				<listitem id="asEWKT">
					<indexterm><primary><varname>asEWKT</varname></primary></indexterm>
					<para>Get the Extended Well-Known Text (EWKT) representation &Z_support; &geography_support;</para>
					<para><varname>asEWKT({tpoint,tpoint[],geo[]}): {text,text[]}</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02)');
-- SRID=4326;[POINT Z (0 0 0)@2001-01-01, POINT Z (1 1 1)@2001-01-02)
SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);
-- {"SRID=5676;POINT(0 0)","SRID=5676;POINT(1 1)"}
</programlisting>
				</listitem>

				<listitem id="asMFJSON">
					<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
					<para>Get the Moving Features JSON representation &Z_support; &geography_support;</para>
					<para><varname>asMFJSON(tpoint,options integer=0,flags integer=0,maxdecdigits integer=15): bytea</varname></para>
					<para>The <varname>options</varname> argument can be used to add BBOX and/or CRS in MFJSON output:</para>
					<itemizedlist>
						<listitem><para>0: means no option (default value)</para></listitem>
						<listitem><para>1: MFJSON BBOX</para></listitem>
						<listitem><para>2: MFJSON Short CRS (e.g EPSG:4326)</para></listitem>
						<listitem><para>4: MFJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)</para></listitem>
					</itemizedlist>
					<para>The <varname>flags</varname> argument can be used to customize the JSON output, for example, to produce an easy-to-read (for human readers) JSON output. Please look at the documentation of the <varname>json-c</varname> library. Typical values are as follows:</para>
					<itemizedlist>
						<listitem><para>0: means no option (default value)</para></listitem>
						<listitem><para>1: JSON_C_TO_STRING_SPACED</para></listitem>
						<listitem><para>2: JSON_C_TO_STRING_PRETTY</para></listitem>
					</itemizedlist>
					<para>The <varname>maxdecdigits</varname> argument can be used to set the maximum number of decimal places in the output of floating point values (default 15).</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asMFJSON(tgeompoint 'Point(1 2)@2019-01-01 18:00:00.15+02');
/* {"type":"MovingPoint","coordinates":[1,2],"datetimes":"2019-01-01T17:00:00.15+01",
   "interpolations":["Discrete"]} */
SELECT asMFJSON(tgeompoint 'SRID=4326;
  Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 3, 2);
/* {"type":"MovingPoint","crs":{"type":"name","properties":{"name":"EPSG:4326"}},
   "stBoundedBy":{"bbox":[50.81,4.38,50.81,4.38],
   "period":{"begin":"2019-01-01 17:00:00.15+01","end":"2019-01-01 17:00:00.15+01"}},
   "coordinates":[50.81,4.38],"datetimes":"2019-01-01T17:00:00.15+01",
   "interpolations":["Discrete"]} */
</programlisting>
				</listitem>

				<listitem id="asBinary">
					<indexterm><primary><varname>asBinary</varname></primary></indexterm>
					<para>Get the Well-Known Binary (WKB) representation &Z_support; &geography_support;</para>
					<para><varname>asBinary(tpoint): bytea</varname></para>
					<para><varname>asBinary(tpoint,endian text): bytea</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asBinary(tgeompoint 'Point(1 2 3)@2001-01-01');
-- \x0191000000000000f03f0000000000000040000000000000084000fce0136a580100
</programlisting>
				</listitem>

				<listitem id="asEWKB">
					<indexterm><primary><varname>asEWKB</varname></primary></indexterm>
					<para>Get the Extended Well-Known Binary (EWKB) representation &Z_support; &geography_support;</para>
					<para><varname>asEWKB(tpoint): bytea</varname></para>
					<para><varname>asEWKB(tpoint,endian text): bytea</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKB(tgeogpoint 'SRID=7844;Point(1 2 3)@2001-01-01');
-- \x01f1a41e0000000000000000f03f0000000000000040000000000000084000fce0136a580100
</programlisting>
				</listitem>

				<listitem id="asHexEWKB">
					<indexterm><primary><varname>asHexEWKB</varname></primary></indexterm>
					<para>Get the Hexadecimal Extended Well-Known Binary (EWKB) representation as text &Z_support; &geography_support;</para>
					<para><varname>asHexEWKB(tpoint): text</varname></para>
					<para><varname>asHexEWKB(tpoint,endian text): text</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then NDR is used.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asHexEWKB(tgeompoint 'SRID=3812;Point(1 2 3)@2001-01-01');
-- 01D1E40E0000000000000000F03F0000000000000040000000000000084000FCE0136A580100
</programlisting>
				</listitem>

				<listitem id="tgeompointFromText">
					<indexterm><primary><varname>tgeompointFromText</varname></primary></indexterm>
					<para>Input a temporal geometry point from a Well-Known Text (WKT) representation &Z_support;</para>
					<para><varname>tgeompointFromText(text): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromText(text '[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]'));
-- [POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]
</programlisting>
				</listitem>

				<listitem id="tgeogpointFromText">
					<indexterm><primary><varname>tgeogpointFromText</varname></primary></indexterm>
					<para>Input a temporal geography point from a Well-Known Text (WKT) representation &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromText(text): tgeogpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeogpointFromText(text '[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]'));
-- SRID=4326;[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]
</programlisting>
				</listitem>

				<listitem id="tgeompointFromEWKT">
					<indexterm><primary><varname>tgeompointFromEWKT</varname></primary></indexterm>
					<para>Input a temporal geometry point from an Extended Well-Known Text (EWKT) representation &Z_support;</para>
					<para><varname>tgeompointFromEWKT(text): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromEWKT(text 'SRID=3812;[POINT(1 2)@2000-01-01,
  POINT(3 4)@2000-01-02]'));
-- SRID=3812;[POINT(1 2)@2000-01-01 00:00:00+01, POINT(3 4)@2000-01-02 00:00:00+01]
</programlisting>
				</listitem>

				<listitem id="tgeogpointFromEWKT">
					<indexterm><primary><varname>tgeogpointFromEWKT</varname></primary></indexterm>
					<para>Input a temporal geography point from an Extended Well-Known Text (EWKT) representation &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromEWKT(text): tgeogpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeogpointFromEWKT(text 'SRID=7844;[POINT(1 2)@2000-01-01,
  POINT(3 4)@2000-01-02]'));
-- SRID=7844;[POINT(1 2)@2000-01-01, POINT(3 4)@2000-01-02]
</programlisting>
				</listitem>

				<listitem id="tgeompointFromMFJSON">
					<indexterm><primary><varname>tgeompointFromMFJSON</varname></primary></indexterm>
					<para>Input a temporal geometry point from a Moving Features JSON representation &Z_support;</para>
					<para><varname>tgeompointFromMFJSON(text): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
  "properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
  "datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
-- SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01
</programlisting>
				</listitem>

				<listitem id="tgeogpointFromMFJSON">
					<indexterm><primary><varname>tgeogpointFromMFJSON</varname></primary></indexterm>
					<para>Input a temporal geography point from a Moving Features JSON representation &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromMFJSON(text): tgeogpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeogpointFromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
  "properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
  "datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
-- SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01
</programlisting>
				</listitem>

				<listitem id="tgeompointFromBinary">
					<indexterm><primary><varname>tgeompointFromBinary</varname></primary></indexterm>
					<para>Input a temporal geometry point from a Well-Known Binary (WKB) representation &Z_support;</para>
					<para><varname>tgeompointFromBinary(bytea): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromBinary(
  '\x0181000000000000f03f0000000000000040005c6c29ffffffff'));
-- POINT(1 2)@2000-01-01
</programlisting>
				</listitem>

				<listitem id="tgeogpointFromBinary">
					<indexterm><primary><varname>tgeogpointFromBinary</varname></primary></indexterm>
					<para>Input a temporal geography point from a Well-Known Binary (WKB) representation &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromBinary(bytea): tgeogpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromBinary(
  '\x01b1000000000000f03f000000000000f03f000000000000f03f005c6c29ffffffff'));
-- SRID=4326;POINT Z (1 1 1)@2000-01-01
</programlisting>
				</listitem>

				<listitem id="tgeompointFromEWKB">
					<indexterm><primary><varname>tgeompointFromEWKB</varname></primary></indexterm>
					<para>Input a temporal geometry point from an Extended Well-Known Binary (EWKB) representation &Z_support;</para>
					<para><varname>tgeompointFromEWKB(bytea): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromEWKB(
  '\x01c1e40e0000000000000000f03f0000000000000040005c6c29ffffffff'));
-- SRID=3812;POINT(1 2)@2000-01-01
</programlisting>
				</listitem>

				<listitem id="tgeogpointFromEWKB">
					<indexterm><primary><varname>tgeogpointFromEWKB</varname></primary></indexterm>
					<para>Input a temporal geography point from an Extended Well-Known Binary (EWKB) representation &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromEWKB(bytea): tgeogpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeogpointFromEWKB(
  '\x01f1a41e0000000000000000f03f000000000000f03f000000000000f03f005c6c29ffffffff'));
-- SRID=7844;POINT Z (1 1 1)@2000-01-01
</programlisting>
				</listitem>

				<listitem id="tgeompointFromHexEWKB">
					<indexterm><primary><varname>tgeompointFromHexEWKB</varname></primary></indexterm>
					<para>Input a temporal geometry point from an Hexadecimal Extended Well-Known Binary (HexEWKB) representation &Z_support;</para>
					<para><varname>tgeompointFromHexEWKB(text): tgeompoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeompointFromHexEWKB(
  '01C1E40E0000000000000000F03F0000000000000040005C6C29FFFFFFFF'));
-- SRID=3812;POINT(1 2)@2000-01-01
</programlisting>
				</listitem>

				<listitem id="tgeogpointFromHexEWKB">
					<indexterm><primary><varname>tgeogpointFromHexEWKB</varname></primary></indexterm>
					<para>Input a temporal geography point from an Hexadecimal Extended Well-Known Binary (HexEWKB) representation &Z_support; &geography_support;</para>
					<para><varname>tgeogpointFromHexEWKB(text): tgeogpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(tgeogpointFromHexEWKB(
  '01F1A41E0000000000000000F03F000000000000F03F000000000000F03F005C6C29FFFFFFFF'));
-- SRID=7844;POINT Z (1 1 1)@2000-01-01
</programlisting>
				</listitem>
		</itemizedlist>
		</sect2>

		<sect2>
			<title>Spatial Reference System Functions</title>

			<itemizedlist>
				<listitem id="tpoint_SRID">
					<indexterm><primary><varname>SRID</varname></primary></indexterm>
					<para>Get the spatial reference identifier &Z_support; &geography_support;</para>
					<para><varname>SRID(tpoint): integer</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT SRID(tgeompoint 'Point(0 0)@2001-01-01');
-- 0
</programlisting>
				</listitem>

				<listitem id="tpoint_setSRID">
					<indexterm><primary><varname>setSRID</varname></primary></indexterm>
					<para>Set the spatial reference identifier &Z_support; &geography_support;</para>
					<para><varname>setSRID(tpoint): tpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)', 4326));
-- SRID=4326;[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02)
</programlisting>
					</listitem>

				<listitem id="tpoint_transform">
					<indexterm><primary><varname>transform</varname></primary></indexterm>
					<para>Transform to a different spatial reference &Z_support; &geography_support;</para>
					<para><varname>transform(tpoint,integer): tpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2001-01-01', 3812));
-- SRID=3812;POINT(648679.018035303 671067.055638114)@2001-01-01
</programlisting>
				</listitem>
		</itemizedlist>
		</sect2>

		<sect2>
			<title>Bounding Box Functions</title>

			<itemizedlist>
				<listitem id="tpoint_expandSpatial">
					<indexterm><primary><varname>expandSpatial</varname></primary></indexterm>
					<para>Get the spatiotemporal bounding box expanded in the spatial dimension by a float value &Z_support; &geography_support;</para>
					<para><varname>expandSpatial({geo,tpoint},float): stbox</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT expandSpatial(geography 'Linestring(0 0,1 1)', 2);
/* SRID=4326;GEODSTBOX Z((-1.000304586490452,-2,-2),
   (3,2.0174497483512503,2.0174524064372834)) */
SELECT expandSpatial(tgeompoint 'Point(0 0)@2001-01-01', 2);
-- STBOX XT((-2,-2),(2,2),[2001-01-01,2001-01-01])
</programlisting>
				</listitem>
		</itemizedlist>
		</sect2>

		<sect2>
			<title>Accessor Functions</title>
			<itemizedlist>
				<listitem id="getX">
					<indexterm><primary><varname>getX</varname></primary></indexterm>
					<para>Get the X coordinate values as a temporal float &Z_support; &geography_support;</para>
					<para><varname>getX(tpoint): tfloat</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT getX(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
  Point(5 6)@2000-01-03}');
-- {1@2000-01-01, 3@2000-01-02, 5@2000-01-03}
SELECT getX(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
  Point(7 8 9)@2000-01-03]');
-- Interp=Stepwise;[1@2000-01-01, 4@2000-01-02, 7@2000-01-03]
</programlisting>
				</listitem>

				<listitem id="getY">
					<indexterm><primary><varname>getY</varname></primary></indexterm>
					<para>Get the Y coordinate values as a temporal float &Z_support; &geography_support;</para>
					<para><varname>getY(tpoint): tfloat</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT getY(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
  Point(5 6)@2000-01-03}');
-- {2@2000-01-01, 4@2000-01-02, 6@2000-01-03}
SELECT getY(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
  Point(7 8 9)@2000-01-03]');
-- Interp=Stepwise;[2@2000-01-01, 5@2000-01-02, 8@2000-01-03]
</programlisting>
				</listitem>

				<listitem id="getZ">
					<indexterm><primary><varname>getZ</varname></primary></indexterm>
				<para>Get the Z coordinate values as a temporal float &Z_support; &geography_support;</para>
				<para><varname>getZ(tpoint): tfloat</varname></para>
				<programlisting language="sql" xml:space="preserve">
SELECT getZ(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
  Point(5 6)@2000-01-03}');
-- The temporal point do not have Z dimension
SELECT getZ(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
  Point(7 8 9)@2000-01-03]');
-- Interp=Stepwise;[3@2000-01-01, 6@2000-01-02, 9@2000-01-03]
</programlisting>
				</listitem>

				<listitem id="isSimple">
					<indexterm><primary><varname>isSimple</varname></primary></indexterm>
					<para>Returns true if the temporal point does not spatially self-intersect &Z_support;</para>
					<para><varname>isSimple(tpoint): boolean</varname></para>
					<para>Notice that a temporal sequence set point is simple if every composing sequence is simple.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT isSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(0 0)@2000-01-03]');
-- false
SELECT isSimple(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
  Point(2 0 2)@2000-01-03, Point(0 0 0)@2000-01-04]');
-- true
SELECT isSimple(tgeompoint '{[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02],
  [Point(1 1 1)@2000-01-03, Point(0 0 0)@2000-01-04]}');
-- true
</programlisting>
				</listitem>

				<listitem id="length">
					<indexterm><primary><varname>length</varname></primary></indexterm>
					<para>Get the length traversed by the temporal point &Z_support; &geography_support;</para>
					<para><varname>length(tpoint): float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02]');
-- 1.73205080756888
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
  Point(0 0 0)@2000-01-03]');
-- 3.46410161513775
SELECT length(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01,
  Point(1 1 1)@2000-01-02, Point(0 0 0)@2000-01-03]');
-- 0
</programlisting>
				</listitem>

				<listitem id="cumulativeLength">
					<indexterm><primary><varname>cumulativeLength</varname></primary></indexterm>
					<para>Get the cumulative length traversed by the temporal point &Z_support; &geography_support;</para>
					<para><varname>cumulativeLength(tpoint): tfloat_seq</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT round(cumulativeLength(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(1 0)@2000-01-03], [Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}'), 6);
-- {[0@2000-01-01, 1.414214@2000-01-02, 2.414214@2000-01-03],
  [2.414214@2000-01-04, 3.414214@2000-01-05]}
SELECT cumulativeLength(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01,
  Point(1 1 1)@2000-01-02, Point(0 0 0)@2000-01-03]');
-- Interp=Stepwise;[0@2000-01-01, 0@2000-01-03]
</programlisting>
				</listitem>

				<listitem id="speed">
					<indexterm><primary><varname>speed</varname></primary></indexterm>
					<para>Get the speed of the temporal point in units per second &Z_support; &geography_support;</para>
					<para><varname>speed(tpoint): tfloat_seqset</varname></para>
					<para>The temporal point must have linear interpolation</para>
					<programlisting language="sql" xml:space="preserve">
SELECT speed(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(1 0)@2000-01-03], [Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}') * 3600 * 24;
/* Interp=Stepwise;{[1.4142135623731@2000-01-01, 1@2000-01-02, 1@2000-01-03],
   [1@2000-01-04, 1@2000-01-05]} */
SELECT speed(tgeompoint 'Interp=Stepwise;[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(1 0)@2000-01-03]');
-- ERROR:  The temporal value must have linear interpolation
</programlisting>
				</listitem>

				<listitem id="twCentroid">
					<indexterm><primary><varname>twCentroid</varname></primary></indexterm>
					<para>Get the time-weighted centroid &Z_support;</para>
					<para><varname>twCentroid(tgeompoint): point</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2001-01-01,
  Point(0 1 1)@2001-01-02, Point(0 1 1)@2001-01-03, Point(0 0 0)@2001-01-04)}'));
-- POINT Z (0 0.666666666666667 0.666666666666667)
</programlisting>
				</listitem>

				<listitem id="azimuth">
					<indexterm><primary><varname>azimuth</varname></primary></indexterm>
					<para>Get the temporal azimuth &Z_support; &geography_support;</para>
					<para><varname>azimuth(tpoint): tfloat</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT degrees(azimuth(tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-02,
  Point(1 1 1)@2001-01-03, Point(0 0 0)@2001-01-04)'));
-- Interp=Stepwise;{[45@2001-01-01, 45@2001-01-02], [225@2001-01-03, 225@2001-01-04)}
</programlisting>
				</listitem>

				<listitem id="bearing">
					<indexterm><primary><varname>bearing</varname></primary></indexterm>
					<para>Get the temporal bearing &Z_support; &geography_support;</para>
					<para><varname>bearing({tpoint, point}, {tpoint, point}): tfloat</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT degrees(bearing(tgeompoint '[Point(1 1)@2001-01-01, Point(3 3)@2001-01-03]',
  geometry 'Point(2 2)'));
-- [45@2001-01-01, 0@2001-01-02, 225@2001-01-03]
SELECT round(degrees(bearing(tgeompoint '[Point(0 0)@2001-01-01, Point(2 0)@2001-01-03]',
  tgeompoint '[Point(2 1)@2001-01-01, Point(0 1)@2001-01-03]')), 3);
--  [63.435@2001-01-01, 0@2001-01-02, 296.565@2001-01-03]
SELECT round(degrees(bearing(tgeompoint '[Point(2 1)@2001-01-01, Point(0 1)@2001-01-03]',
  tgeompoint '[Point(0 0)@2001-01-01, Point(2 0)@2001-01-03]')), 3);
-- [243.435@2001-01-01, 116.565@2001-01-03]
</programlisting>
					<para>Please notice that this function currently does not accept two temporal geographic points.</para>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Manipulation Functions</title>

			<itemizedlist>
				<listitem id="tpoint_round">
					<indexterm><primary><varname>round</varname></primary></indexterm>
					<para>Round the coordinate values to a number of decimal places &Z_support; &geography_support;</para>
					<para><varname>round(tpoint,integer): tpoint</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(round(tgeompoint '{Point(1.12345 1.12345 1.12345)@2000-01-01,
  Point(2 2 2)@2000-01-02, Point(1.12345 1.12345 1.12345)@2000-01-03}', 2));
/* {POINT Z (1.12 1.12 1.12)@2000-01-01, POINT Z (2 2 2)@2000-01-02,
   POINT Z (1.12 1.12 1.12)@2000-01-03} */
SELECT asText(round(tgeogpoint 'Point(1.12345 1.12345)@2000-01-01', 2));
-- POINT(1.12 1.12)@2000-01-01
</programlisting>
				</listitem>

				<listitem id="makeSimple">
					<indexterm><primary><varname>makeSimple</varname></primary></indexterm>
					<para>Returns an array of fragments of the temporal point which are simple &Z_support;</para>
					<para><varname>makeSimple(tpoint): tgeompoint[]</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(0 0)@2000-01-03]'));
/* {"[POINT(0 0)@2000-01-01, POINT(1 1)@2000-01-02)",
   "[POINT(1 1)@2000-01-02, POINT(0 0)@2000-01-03]"} */
SELECT asText(makeSimple(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
  Point(2 0 2)@2000-01-03, Point(0 0 0)@2000-01-04]'));
/* {"[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02, POINT Z (2 0 2)@2000-01-03,
   POINT Z (0 0 0)@2000-01-04]"} */
SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(0 1)@2000-01-03, Point(1 0)@2000-01-04]'));
/* {POINT Z (1.12 1.12 1. {"[POINT(0 0)@2000-01-01, POINT(1 1)@2000-01-02, POINT(0 1)@2000-01-03)",
  "[POINT(0 1)@2000-01-03, POINT(1 0)@2000-01-04]"} */
SELECT asText(makeSimple(tgeompoint '{[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02],
  [Point(1 1 1)@2000-01-03, Point(0 0 0)@2000-01-04]}'));
/* {"{[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02],
   [POINT Z (1 1 1)@2000-01-03, POINT Z (0 0 0)@2000-01-04]}"} */
</programlisting>
				</listitem>

				<listitem id="simplify">
					<indexterm><primary><varname>simplify</varname></primary></indexterm>
					<para>Simplify a temporal point using a generalization of the <ulink url="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Douglas-Peucker algorithm</ulink> &Z_support;</para>
					<para><varname>simplify(tpoint,distance float,sync bool DEFAULT false): tpoint</varname></para>
					<para>The function removes points that are less than or equal to the distance passed as third argument, which is specified in the units of the coordinate system. The third argument specifies whether the Euclidean distance or the Synchronized Euclidean Distance (SED) is used. Notice that simplification applies only to temporal sequences or sequence sets with linear interpolation. In all other cases, a copy of the given temporal point is returned.</para>
					<programlisting language="sql" xml:space="preserve">
-- Euclidean distance
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
  Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
  Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 1.5)));
-- LINESTRING(0 4,1 1,4 3,5 0,6 4)
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
  Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
  Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 2)));
-- LINESTRING(0 4,5 0,6 4)
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
  Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
  Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4)));
-- LINESTRING(0 4,6 4)

-- Synchronized vs Euclidean distance
SELECT asText(simplify(tgeompoint '[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(3 1)@2000-01-04]', 1, false));
-- [POINT(1 1)@2000-01-01, POINT(3 1)@2000-01-04]
SELECT asText(simplify(tgeompoint '[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02,
  Point(3 1)@2000-01-04]', 1, true));
-- [POINT(1 1)@2000-01-01, POINT(2 2)@2000-01-02, POINT(3 1)@2000-01-04]
</programlisting>
					<para>The difference between using the synchronized or the spatial-only Euclidean distance is illustrated in the last two examples above. In the first example, which uses the Euclidean distance, the second instant is removed since the perperdicular distance between <varname>POINT(2 2)</varname> and the line defined by <varname>POINT(1 1)</varname> and <varname>POINT(3 1)</varname> is equal to 1. On the contrary, in the second example the second instant is kept since the projection of <varname>Point(2 2)</varname> at timestamp <varname>2000-01-02</varname> over the temporal line segment results in <varname>Point(1.66 1)</varname> and the distance between the original point and its projection is 1.05.</para>
					<para>A typical use for the <varname>simplify</varname> function is to reduce the size of a dataset, in particular for visualization purposes.</para>
				</listitem>

				<listitem id="geoMeasure">
					<indexterm><primary><varname>geoMeasure</varname></primary></indexterm>
					<para>Construct a geometry/geography with M measure from a temporal point and a temporal float &Z_support; &geography_support;</para>
					<para><varname>geoMeasure(tpoint,tfloat,segmentize=false): geo</varname></para>
					<para>The last <varname>segmentize</varname> argument states whether the resulting value is a either <varname>Linestring M</varname> or a <varname>MultiLinestring M</varname> where each component is a segment of two points.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2000-01-01,
  Point(2 2 2)@2000-01-02}', '{5@2000-01-01, 5@2000-01-02}'));
-- MULTIPOINT ZM (1 1 1 5,2 2 2 5)
SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
  [Point(1 1)@2000-01-03, Point(1 1)@2000-01-04]}',
  '{[5@2000-01-01, 5@2000-01-02],[7@2000-01-03, 7@2000-01-04]}'));
-- GEOMETRYCOLLECTION M (LINESTRING M (1 1 5,2 2 5),POINT M (1 1 7))
SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2000-01-01,
  Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]',
  '[5@2000-01-01, 7@2000-01-02, 5@2000-01-03]', true));
-- MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))
</programlisting>
					<para>A typical visualization for mobility data is to show on a map the trajectory of the moving object using different colors according to the speed. <xref linkend="figspeed" /> shows the result of the query below using a color ramp in QGIS.</para>
					<programlisting language="sql" xml:space="preserve">
WITH Temp(t) AS (
  SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-05,
    Point(2 0)@2001-01-08, Point(3 1)@2001-01-10, Point(4 0)@2001-01-11]'
)
SELECT ST_AsText(geoMeasure(t, round(speed(t) * 3600 * 24, 2), true))
FROM Temp;
-- MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),
-- (3 1 1.41,4 0 1.41))
</programlisting>
					<para>The following expression is used in QGIS to achieve this. The <varname>scale_linear</varname> function transforms the M value of each composing segment to the range [0, 1]. This value is then passed to the <varname>ramp_color</varname> function.</para>
					<programlisting language="sql" xml:space="preserve">
ramp_color(
  'RdYlBu',
  scale_linear(
    m(start_point(geometry_n($geometry,@geometry_part_num))),
    0, 2, 0, 1)
)
</programlisting>
					<figure id="figspeed" float="start">
							<title>Visualizing the speed of a moving object using a color ramp in QGIS.</title>
						<mediaobject>
							<imageobject><imagedata scale='30' fileref='images/speed.png' /></imageobject>
						</mediaobject>
					</figure>
				</listitem>

				<listitem id="asMVTGeom">
					<indexterm><primary><varname>asMVTGeom</varname></primary></indexterm>
					<para>Transform a temporal geometric point into the coordinate space of a Mapbox Vector Tile. The result is a couple composed of a <varname>geometry</varname> value and an array of associated timestamp values encoded as Unix epoch &Z_support;</para>
					<para><varname>asMVTGeom(tpoint,bounds,extent=4096,buffer=256,clip=true): geom_times</varname></para>
					<para>The parameters are as follows:</para>
					<itemizedlist>
						<listitem><para><varname>tpoint</varname> is the temporal point to transform</para></listitem>
						<listitem><para><varname>bounds</varname> is an <varname>stbox</varname> defining the geometric bounds of the tile contents without buffer</para></listitem>
						<listitem><para><varname>extent</varname> is the tile extent in tile coordinate space</para></listitem>
						<listitem><para><varname>buffer</varname> is the buffer distance in tile coordinate space</para></listitem>
						<listitem><para><varname>clip</varname> is a Boolean that determines if the resulting geometries and timestamps should be clipped or not</para></listitem>
					</itemizedlist>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText((mvt).geom), (mvt).times
FROM (SELECT asMVTGeom(tgeompoint '[Point(0 0)@2000-01-01, Point(100 100)@2000-01-02]',
  stbox 'STBOX X((40,40),(60,60))') AS mvt ) AS t;
-- LINESTRING(-256 4352,4352 -256) | {946714680,946734120}
SELECT ST_AsText((mvt).geom), (mvt).times
FROM (SELECT asMVTGeom(tgeompoint '[Point(0 0)@2000-01-01, Point(100 100)@2000-01-02]',
  stbox 'STBOX X((40,40),(60,60))', clip:=false) AS mvt ) AS t;
-- LINESTRING(-8192 12288,12288 -8192) | {946681200,946767600}
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Distance Functions and Operators</title>

			<itemizedlist>
				<listitem id="smallest_distance">
					<indexterm><primary><varname>|=|</varname></primary></indexterm>
					<para>Get the smallest distance ever &Z_support; &geography_support;</para>
					<para><varname>{geo,tpoint} |=| {geo,tpoint}: float</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[Point(0 0)@2001-01-02, Point(1 1)@2001-01-04, Point(0 0)@2001-01-06)'
  |=| geometry 'Linestring(2 2,2 1,3 1)';
-- 1
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03, Point(0 0)@2001-01-05)'
  |=| tgeompoint '[Point(2 0)@2001-01-02, Point(1 1)@2001-01-04, Point(2 2)@2001-01-06)';
-- 0.5
SELECT tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
  Point(0 0 0)@2001-01-05)' |=| tgeompoint '[Point(2 0 0)@2001-01-02,
  Point(1 1 1)@2001-01-04, Point(2 2 2)@2001-01-06)';
-- 0.5
SELECT tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01, Point(3 1)@2000-01-03]' |=|
  geometry 'Linestring(1 3,2 2,3 3)';
-- 1.4142135623731
</programlisting>
					<para>The operator <varname>|=|</varname> can be used for doing nearest neighbor searches using a GiST or an SP-GiST index (see <xref linkend="indexing_temporal_types" />). This operator corresponds to the PostGIS function <varname>ST_DistanceCPA</varname>, altough the latter requires both arguments to be a trajectory.</para>
				<programlisting language="sql" xml:space="preserve">
SELECT ST_DistanceCPA(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'::geometry);
-- 0.5
</programlisting>
				</listitem>

				<listitem id="nearestApproachInstant">
					<indexterm><primary><varname>nearestApproachInstant</varname></primary></indexterm>
					<para>Get the instant of the first temporal point at which the two arguments are at the nearest distance &Z_support; &geography_support;</para>
					<para><varname>nearestApproachInstant({geo,tpoint},{geo,tpoint}): tpoint</varname></para>
					<para>The function will only return the first instant that it finds if there are more than one. The resulting instant may be at an exclusive bound.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- POINT(2 1)@2000-01-02
SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- POINT(1 1)@2000-01-01
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,
  Point(2 2)@2000-01-03]', tgeompoint '(Point(1 1)@2000-01-01, Point(4 1)@2000-01-03]'));
-- POINT(1 1)@2000-01-01
SELECT asText(nearestApproachInstant(tgeompoint '[Point(0 0 0)@2001-01-01,
  Point(1 1 1)@2001-01-03, Point(0 0 0)@2001-01-05)', tgeompoint
  '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04, Point(2 2 2)@2001-01-06)'));
-- POINT Z (0.75 0.75 0.75)@2001-01-03 12:00:00+00
</programlisting>
					<para>Function <varname>nearestApproachInstant</varname> generalizes the PostGIS function <varname>ST_ClosestPointOfApproach</varname>. First, the latter function requires both arguments to be trajectories. Second, function <varname>nearestApproachInstant</varname> returns both the point and the timestamp of the nearest point of approach while the PostGIS function only provides the timestamp as shown next.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT to_timestamp(ST_ClosestPointOfApproach(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'::geometry));
-- 2001-01-03 12:00:00+00
</programlisting>
				</listitem>

				<listitem id="shortestLine">
					<indexterm><primary><varname>shortestLine</varname></primary></indexterm>
					<para>Get the line connecting the nearest approach point &Z_support; &geography_support;</para>
					<para><varname>shortestLine({geo,tpoint},{geo,tpoint}): geo</varname></para>
					<para>The function will only return the first line that it finds if there are more than one.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- LINESTRING(2 1,2 2)
SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- LINESTRING(1 1,2 2)
SELECT ST_AsText(shortestLine(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)',
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'));
-- LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)
</programlisting>
					<para>Function <varname>shortestLine</varname> can be used to obtain the result provided by the PostGIS function <varname>ST_CPAWithin</varname> when both arguments are trajectories as shown next.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT ST_Length(shortestLine(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)',
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)')) &lt;= 0.5;
-- true
SELECT ST_CPAWithin(
  tgeompoint '[Point(0 0 0)@2001-01-01, Point(1 1 1)@2001-01-03,
    Point(0 0 0)@2001-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2001-01-02, Point(1 1 1)@2001-01-04,
    Point(2 2 2)@2001-01-06)'::geometry, 0.5);
-- true
</programlisting>
				</listitem>
			</itemizedlist>

			<para>The temporal distance operator, denoted <varname>&lt;-&gt;</varname>, computes the distance at each instant of the intersection of the temporal extents of their arguments and results in a temporal float. Computing temporal distance is useful in many mobility applications. For example, a moving cluster (also known as convoy or flock) is defined as a set of objects that move close to each other for a long time interval. This requires to compute temporal distance between two moving objects.</para>

			<para>The temporal distance operator accepts a geometry/geography restricted to a point or a temporal point as arguments. Notice that the temporal types only consider linear interpolation between values, while the distance is a root of a quadratic function. Therefore, the temporal distance operator gives a linear approximation of the actual distance value for temporal sequence points. In this case, the arguments are synchronized in the time dimension, and for each of the composing line segments of the arguments, the spatial distance between the start point, the end point, and the nearest point of approach is computed, as shown in the examples below.</para>

			<itemizedlist>
				<listitem id="distance">
					<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
					<para>Get the temporal distance &Z_support; &geography_support;</para>
					<para><varname>{point,tpoint} &lt;-&gt; {point,tpoint}: tfloat</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03)' &lt;-&gt;
  geometry 'Point(0 1)';
-- [1@2001-01-01, 0.707106781186548@2001-01-02, 1@2001-01-03)
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03)' &lt;-&gt;
  tgeompoint '[Point(0 1)@2001-01-01, Point(1 0)@2001-01-03)';
-- [1@2001-01-01, 0@2001-01-02, 1@2001-01-03)
SELECT tgeompoint '[Point(0 1)@2001-01-01, Point(0 0)@2001-01-03)' &lt;-&gt;
  tgeompoint '[Point(0 0)@2001-01-01, Point(1 0)@2001-01-03)';
-- [1@2001-01-01, 0.707106781186548@2001-01-02, 1@2001-01-03)
SELECT tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)' &lt;-&gt;
  tgeompoint '[Point(0 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- [1@2001-01-01,1@2001-01-02)
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="spatial_relationships_temporal_points">
			<title>Spatial Relationships</title>

			<para>The topological relationships such as <varname>ST_Intersects</varname> and the distance relationships such as <varname>ST_DWithin</varname> can be generalized for temporal points. The arguments of these generalized functions are either a temporal point and a base type (that is, a <varname>geometry</varname> or a <varname>geography</varname>) or two temporal points. Furthermore, both arguments must be of the same base type, that is, these functions do not allow to mix a temporal geometry point (or a geometry) and a temporal geography point (or a geography).</para>

			<para>There are two versions of the spatial relationships:</para>
			<itemizedlist>
				<listitem>
					<para>The <emphasis>ever relationships</emphasis> determine whether the topological or distance relationship is ever satisfied (see <xref linkend="ever_always_comparison" />) and returns a <varname>boolean</varname>. Examples are the <varname>intersects</varname> and <varname>dwithin</varname> functions.</para>
				</listitem>

				<listitem>
					<para>The <emphasis>temporal relationships</emphasis> compute the topological or distance relationship at each instant and results in a <varname>tbool</varname>. Examples are the <varname>tintersects</varname> and <varname>tdwithin</varname> functions.</para>
				</listitem>
			</itemizedlist>

			<para>
				For example, the following query
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT intersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(0 2)@2001-01-01, Point(4 2)@2001-01-05)');
-- t
</programlisting>
			<para>
				tests whether the temporal point ever intersects the geometry. In this case, the query is equivalent to the following one
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT ST_Intersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  geometry 'Linestring(0 2,4 2)');
</programlisting>
			<para>
				where the second geometry is obtained by applying the <varname>trajectory</varname> function to the temporal point. In contrast, the query
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT tintersects(geometry 'Polygon((1 1,1 3,3 3,3 1,1 1))',
  tgeompoint '[Point(0 2)@2001-01-01, Point(4 2)@2001-01-05)');
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-04], (f@2001-01-04, f@2001-01-05)}
</programlisting>
			<para>
				computes at each instant whether the temporal point intersects the geometry. Similarly, the following query
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT dwithin(tgeompoint '[Point(3 1)@2001-01-01, Point(5 1)@2001-01-03)',
  tgeompoint '[Point(3 1)@2001-01-01, Point(1 1)@2001-01-03)', 2);
-- t
</programlisting>
			<para>
				tests whether the distance between the temporal points was ever less than or equal to 2, while the following query
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT tdwithin(tgeompoint '[Point(3 1)@2001-01-01, Point(5 1)@2001-01-03)',
  tgeompoint '[Point(3 1)@2001-01-01, Point(1 1)@2001-01-03)', 2);
-- {[t@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
</programlisting>
			<para>
				computes at each instant whether the distance between the temporal points is less than or equal to 2.
			</para>

			<para>
			The ever relationships are sometimes used in combination with a spatiotemporal index when computing the temporal relationships. For example, the following query
			</para>
			<programlisting language="sql" xml:space="preserve">
SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
WHERE intersects(T.Trip, R.Geom)
</programlisting>
			<para>
				which verifies whether a trip <varname>T</varname> (which is a temporal point) intersects a region <varname>R</varname> (which is a geometry), will benefit from a spatiotemporal index on the column <varname>T.Trip</varname> since the <varname>intersects</varname> function will automatically perform the bounding box comparison <varname>T.Trip &amp;&amp; R.Geom</varname>. This is further explained later in this document.
			</para>

			<para>Not all spatial relationships available in PostGIS have a meaningful generalization for temporal points. A generalized version of the following relationships are defined for temporal geometric points: <varname>intersects</varname>, <varname>disjoint</varname>, <varname>dwithin</varname>, <varname>contains</varname>, and <varname>touches</varname>, while for temporal geographic points only the three first ones are defined. Furthermore, not all combinations of parameters are meaningful for a given generalized function. For example, while <varname>tcontains(geometry, tpoint)</varname> is meaningful, <varname>tcontains(tpoint, geometry)</varname> is meaningful only when the geometry is a single point, and <varname>tcontains(tpoint, tpoint)</varname> is equivalent to <varname>tintersects(tpoint, geometry)</varname>. For this reason, only the first combination of parameters is defined for <varname>contains</varname> and <varname>tcontains</varname>.</para>

			<para>Finally, it is worth noting that the temporal relationships allow to mix 2D/3D geometries but in that case, the computation is only performed on 2D.</para>
		</sect2>

		<sect2>
			<title>Ever Spatial Relationships</title>
			<para>All these functions automatically include a bounding box comparison that makes use of any spatial indexes that are available on the arguments.</para>
			<itemizedlist>
				<listitem id="contains">
					<indexterm><primary><varname>contains</varname></primary></indexterm>
					<para>Ever contains</para>
					<para><varname>contains({geo,tgeompoint},{geo,tgeompoint}): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="disjoint">
					<indexterm><primary><varname>disjoint</varname></primary></indexterm>
					<para>Is ever disjoint &Z_support; &geography_support;</para>
					<para><varname>disjoint({geo,tpoint},{geo,tpoint}): boolean</varname></para>
						<programlisting language="sql" xml:space="preserve">
SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-03)');
-- false
SELECT disjoint(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2001-01-01, Point(1 1 0)@2001-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="dwithin">
					<indexterm><primary><varname>dwithin</varname></primary></indexterm>
					<para>Is ever at distance within &Z_support; &geography_support;</para>
					<para><varname>dwithin({geo,tpoint},{geo,tpoint},float): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT dwithin(geometry 'Point(1 1 1)',
  tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 0)@2000-01-02]', 1);
-- true
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02]', 1);
-- false
</programlisting>
				</listitem>

				<listitem id="intersects">
					<indexterm><primary><varname>intersects</varname></primary></indexterm>
					<para>Ever intersects &Z_support; &geography_support;</para>
					<para><varname>intersects({geo,tpoint},{geo,tpoint}): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2001-01-01, Point(1 1 1)@2001-01-03)');
-- false
SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint '[Point(0 0 1)@2001-01-01, Point(1 1 1)@2001-01-03)');
-- true
</programlisting>
				</listitem>

				<listitem id="touches">
					<indexterm><primary><varname>touches</varname></primary></indexterm>
					<para>Ever touches &Z_support;</para>
					<para><varname>touches({geo,tgeompoint},{geo,tgeompoint}): boolean</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-03)');
-- true
</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Temporal Spatial Relationships</title>
			<para>A common requirement regarding the temporal spatial relationships is to restrict the result of the relationship to the instants when the value of the result is true (alternatively, false). As an example, the following query computes for each trip the time spent traveling in the Brussels municipality.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT TripId, duration(atValue(tintersects(T.trip, M.geom), True))
FROM Trips T, Municipality M
WHERE M.Name = "Brussels" AND atValue(tintersects(T.trip, M.geom), True) IS NOT NULL;
</programlisting>
			<para>To simplify query writing, the temporal spatial relationships have an optional last parameter, which if given applies the <varname>atValue</varname> function (see <xref linkend="restriction_functions" />) to the result of the relationship. In this way, the above query can be written as follows.</para>
					<programlisting language="sql" xml:space="preserve">
SELECT TripId, duration(tintersects(T.trip, M.geom, True))
FROM Trips T, Municipality M
WHERE M.Name = "Brussels" AND tintersects(T.trip, M.geom, True) IS NOT NULL;
</programlisting>
			<itemizedlist>
				<listitem id="tcontains">
					<indexterm><primary><varname>tcontains</varname></primary></indexterm>
					<para>Temporal contains</para>
					<para><varname>tcontains(geometry, tgeompoint): tbool</varname></para>
					<para><varname>tcontains(geometry, tgeompoint,atValue boolean): tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)');
-- {[f@2001-01-01, f@2001-01-02], (t@2001-01-02, f@2001-01-03, f@2001-01-04)}
</programlisting>
				</listitem>

				<listitem id="tdisjoint">
					<indexterm><primary><varname>tdisjoint</varname></primary></indexterm>
					<para>Temporal disjoint &Z_support; &geography_support;</para>
					<para><varname>tdisjoint({geo,tpoint},{geo,tpoint}): tbool</varname></para>
					<para><varname>tdisjoint({geo,tpoint},{geo,tpoint},atValue boolean): tbool</varname></para>
					<para>The function only supports 3D or geographies for two temporal points</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)');
-- {[t@2001-01-01, f@2001-01-02, f@2001-01-03], (t@2001-01-03, t@2001-01-04]}
SELECT tdisjoint(tgeompoint '[Point(0 3)@2001-01-01, Point(3 0)@2001-01-05)',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-05)');
-- {[t@2001-01-01, f@2001-01-03], (t@2001-01-03, t@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="tdwithin">
					<indexterm><primary><varname>tdwithin</varname></primary></indexterm>
					<para>Temporal distance within &Z_support;</para>
					<para><varname>tdwithin({geompoint,tgeompoint},{geompoint,tgeompoint},float): tbool</varname></para>
					<para><varname>tdwithin({geompoint,tgeompoint},{geompoint,tgeompoint},float,atValue boolean): tbool</varname></para>
					<para>The function only allows 3D for two temporal points</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 0)@2001-01-04)', 1);
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04)}
SELECT tdwithin(tgeompoint '[Point(1 0)@2000-01-01, Point(1 4)@2000-01-05]',
  tgeompoint 'Interp=Stepwise;[Point(1 2)@2000-01-01, Point(1 3)@2000-01-05]', 1);
-- {[f@2000-01-01, t@2000-01-02, t@2000-01-04], (f@2000-01-04, t@2000-01-05]}
</programlisting>
				</listitem>

				<listitem id="tintersects">
					<indexterm><primary><varname>tintersects</varname></primary></indexterm>
					<para>Temporal intersects &Z_support; &geography_support;</para>
					<para><varname>tintersects({geo,tpoint},{geo,tpoint}): tbool</varname></para>
					<para><varname>tintersects({geo,tpoint},{geo,tpoint},atValue boolean): tbool</varname></para>
					<para>The function only supports 3D or geographies for two temporal points</para>
					<programlisting language="sql" xml:space="preserve">
SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-04)');
/* {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, t@2001-01-03],
   (f@2001-01-03, f@2001-01-04]} */
SELECT tintersects(tgeompoint '[Point(0 3)@2001-01-01, Point(3 0)@2001-01-05)',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 3)@2001-01-05)');
-- {[f@2001-01-01, t@2001-01-03], (f@2001-01-03, f@2001-01-05)}
</programlisting>
				</listitem>

				<listitem id="ttouches">
					<indexterm><primary><varname>ttouches</varname></primary></indexterm>
					<para>Temporal touches</para>
					<para><varname>ttouches({geo,tgeompoint},{geo,tgeompoint}): tbool</varname></para>
					<para><varname>ttouches({geo,tgeompoint},{geo,tgeompoint},atValue boolean): tbool</varname></para>
					<programlisting language="sql" xml:space="preserve">
SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
  tgeompoint '[Point(0 0)@2001-01-01, Point(3 0)@2001-01-04)');
-- {[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}
</programlisting>
				</listitem>
			</itemizedlist>
			</sect2>
	</sect1>

