<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 2. Set and Span Types</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="MobilityDB 1.1 User's Manual"><link rel="up" href="index.html" title="MobilityDB 1.1 User's Manual"><link rel="prev" href="ch01s08.html" title="Migrating from Version 1.0 to Version 1.1"><link rel="next" href="ch02s02.html" title="Constructors"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 2. Set and Span Types</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s08.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch02s02.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="set_span_types"></a>Chapter 2. Set and Span Types</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch02.html#idm593">Input and Output</a></span></dt><dt><span class="sect1"><a href="ch02s02.html">Constructors</a></span></dt><dt><span class="sect1"><a href="ch02s03.html">Conversions</a></span></dt><dt><span class="sect1"><a href="ch02s04.html">Accessors</a></span></dt><dt><span class="sect1"><a href="ch02s05.html">Transformations</a></span></dt><dt><span class="sect1"><a href="ch02s06.html">Spatial Reference System</a></span></dt><dt><span class="sect1"><a href="ch02s07.html">Set Operations</a></span></dt><dt><span class="sect1"><a href="ch02s08.html">Bounding Box Operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02s08.html#idm1203">Topological Operations</a></span></dt><dt><span class="sect2"><a href="ch02s08.html#idm1239">Position Operations</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s09.html">Distance Operations</a></span></dt><dt><span class="sect1"><a href="ch02s10.html">Comparisons</a></span></dt><dt><span class="sect1"><a href="ch02s11.html">Aggregations</a></span></dt><dt><span class="sect1"><a href="ch02s12.html">Indexing</a></span></dt></dl></div><p>
		MobilityDB provides <span class="emphasis"><em>set</em></span>, <span class="emphasis"><em>span</em></span>, and <span class="emphasis"><em>span set</em></span> types for representing set of values another type, which is called the <span class="emphasis"><em>base type</em></span>. Set types are akin to <span class="emphasis"><em>array types</em></span> in PostgreSQL restricted to one dimension, but enforce the constraint that sets do not have duplicates. Span and span set types in MobilityDB correspond to the <span class="emphasis"><em>range and multirange types</em></span> in PostgreSQL but have additional constraints. In particular, span types in MobilityDB are of fixed length and do not allow empty spans and infinite bounds. While span types provide similar functionality to range types, they enable increasing performance. In particular, the overhead of processing variable-length types is removed and, in addition, pointer arithmetics and binary search can be used.
	</p><p>
		The base types used for constructing set, span, and span set types are the types <code class="varname">integer</code>, <code class="varname">bigint</code>, <code class="varname">float</code>,  <code class="varname">text</code>, <code class="varname">date</code>, and <code class="varname">timestamptz</code> (timestamp with time zone) provided by PostgreSQL, the types <code class="varname">geometry</code> and <code class="varname">geography</code> provided by PostGIS, and the type <code class="varname">npoint</code> (network point) provided by MobilityDB (see <a class="xref" href="ch11.html" title="Chapter 11. Temporal Network Points">Chapter 11, <i>Temporal Network Points</i></a>). MobilityDB provides the following set and span types:
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">set</code>: <code class="varname">intset</code>, <code class="varname">bigintset</code>, <code class="varname">floatset</code>, <code class="varname">textset</code>, <code class="varname">dateset</code>,  <code class="varname">tstzset</code>,  <code class="varname">geomset</code>, <code class="varname">geogset</code>, <code class="varname">npointset</code>.</p></li><li class="listitem"><p><code class="varname">span</code>: <code class="varname">intspan</code>, <code class="varname">bigintspan</code>, <code class="varname">floatspan</code>, <code class="varname">datespan</code>, <code class="varname">tstzspan</code>.</p></li><li class="listitem"><p><code class="varname">spanset</code>: <code class="varname">intspanset</code>, <code class="varname">bigintspanset</code>, <code class="varname">floatspanset</code>, <code class="varname">datespanset</code>, <code class="varname">tstzspanset</code>.</p></li></ul></div><p>
	</p><p>
		We present next the functions and operators for set and span types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this in the signature of the functions and operators, we use the following notation:
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">set</code> represents any set type, such as <code class="varname">intset</code> or <code class="varname">tstzset</code>.</p></li><li class="listitem"><p><code class="varname">span</code> represents any span type, such as <code class="varname">intspan</code> or <code class="varname">tstzspanset</code>.</p></li><li class="listitem"><p><code class="varname">spanset</code> represents any span set type, such as <code class="varname">intspanset</code> or <code class="varname">tstzspanset</code>.</p></li><li class="listitem"><p><code class="varname">spans</code> represents any span or span set type, such as <code class="varname">intspan</code> or <code class="varname">tstzspanset</code>.</p></li><li class="listitem"><p><code class="varname">base</code> represents any base type of a set or span type, such as <code class="varname">integer</code> or <code class="varname">timestamptz</code></p></li><li class="listitem"><p><code class="varname">number</code> represents any base type of a number span type, such as <code class="varname">integer</code> or <code class="varname">float</code>,</p></li><li class="listitem"><p><code class="varname">numset</code> represents any number set type, such as <code class="varname">intset</code> or <code class="varname">floatset</code>.</p></li><li class="listitem"><p><code class="varname">numspans</code> represents any number span type, such as <code class="varname">intspan</code> or <code class="varname">floatspanset</code>.</p></li><li class="listitem"><p><code class="varname">numbers</code> represents any number set or range type, such as <code class="varname">integer</code>, <code class="varname">intset</code>, <code class="varname">intspan</code>, or <code class="varname">intspanset</code>,</p></li><li class="listitem"><p><code class="varname">dates</code> represents any time type with <code class="varname">date</code> granularity, that is, <code class="varname">date</code>, <code class="varname">dateset</code>, <code class="varname">datespan</code>, or <code class="varname">datespanset</code>,</p></li><li class="listitem"><p><code class="varname">times</code> represents any time type with <code class="varname">timestamptz</code> granularity, that is, <code class="varname">timestamptz</code>, <code class="varname">tstzset</code>, <code class="varname">tstzspan</code>, or <code class="varname">tstzspanset</code>,</p></li><li class="listitem"><p>A set of types such as <code class="varname">{set,spans}</code> represents any of the types listed,</p></li><li class="listitem"><p><code class="varname">type[]</code> represents an array of <code class="varname">type</code>.</p></li></ul></div><p>
		As an example, the signature of the contains operator (<code class="varname">@&gt;</code>) is as follows:
	</p><pre class="programlisting">
{set,spans} @&gt; {set,spans,base} → boolean
</pre><p>
		Notice that the signature above is an abridged version of the more precise signature below
	</p><pre class="programlisting">
set @&gt; {set,base} → boolean
spans @&gt; {spans,base} → boolean
</pre><p>
		since sets and spans cannot be mixed in operations and thus, for instance, we cannot ask wether a span contains a set. In the following, for conciseness, we use the abridged style of signatures above. Furthermore, the time part of the timestamps is omitted in most examples. Recall that in that case PostgreSQL assumes the time <code class="varname">00:00:00</code>.
	</p><p>
		In what follows, since span and span set types have similar functions and operators, when we speak about span types we mean both span and span set types, unless we explicitly refer to <span class="emphasis"><em>unit</em></span> span types and span <span class="emphasis"><em>set</em></span> types to distinguish them.
	</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm593"></a>Input and Output</h2></div></div></div><p>
			MobilityDB generalizes Open Geospatial Consortium's (<a class="ulink" href="https://www.ogc.org/" target="_top">OGC</a>) Well-Known Text (<a class="ulink" href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry" target="_top">WKT</a>) and Well-Known Binary (<a class="ulink" href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary" target="_top">WKB</a>) input and output format for all its types. In this way, applications can exchange data between them using a standardized exchange format. The WKT format is human-readable while the WKB format is more compact and more efficient than the WKT format. The WKB format can be output either as a binary string or as a character string encoded in hexadecimal ASCII.
		</p><p>
			The set types represent an <span class="emphasis"><em>ordered</em></span> set of <span class="emphasis"><em>distinct</em></span> values. A set must contain at least one element. Examples of set values are as follows:
		</p><pre class="programlisting">
SELECT tstzset '{2001-01-01 08:00:00, 2001-01-03 09:30:00}';
-- Singleton set
SELECT textset '{"highway"}';
-- Erroneous set: unordered elements
SELECT floatset '{3.5, 1.2}';
-- Erroneous set: duplicate elements
SELECT geomset '{"Point(1 1)", "Point(1 1)"}';
</pre><p>
			Notice that the elements of the sets <code class="varname">textset</code>, <code class="varname">geomset</code>, <code class="varname">geogset</code>, and <code class="varname">npointset</code> must be enclosed between double quotes. Notice also that geometries and geographies follow the order defined in PostGIS.
		</p><p>
			A value of a unit span type has two bounds, the <span class="emphasis"><em>lower bound</em></span> and the <span class="emphasis"><em>upper bound</em></span>, which are values of the underlying <span class="emphasis"><em>base type</em></span>. For example, a value of the <code class="varname">tstzspan</code> type has two bounds, which are <code class="varname">timestamptz</code> values. The bounds can be inclusive or exclusive. An inclusive bound means that the boundary instant is included in the span, while an exclusive bound means that the boundary instant is not included in the span. In the text form of a span value, inclusive and exclusive lower bounds are represented, respectively, by “<code class="varname">[</code>” and “<code class="varname">(</code>”. Likewise, inclusive and exclusive upper bounds are represented, respectively, by “<code class="varname">]</code>” and “<code class="varname">)</code>”. In a span value, the lower bound must be less than or equal to the upper bound. A span value with equal and inclusive bounds is called an <span class="emphasis"><em>instantaneous span</em></span> and corresponds to a base type value. Examples of span values are as follows:
		</p><pre class="programlisting">
SELECT intspan '[1, 3)';
SELECT floatspan '[1.5, 3.5]';
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-03 09:30:00)';
-- Instant spans
SELECT intspan '[1, 1]';
SELECT floatspan '[1.5, 1.5]';
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:00:00]';
-- Erroneous span: invalid bounds
SELECT tstzspan '[2001-01-01 08:10:00, 2001-01-01 08:00:00]';
-- Erroneous span: empty span
SELECT tstzspan '[2001-01-01 08:00:00, 2001-01-01 08:00:00)';
</pre><p>
			Values of <code class="varname">intspan</code>, <code class="varname">bigintspan</code>, and <code class="varname">datespan</code> are converted into <span class="emphasis"><em>normal form</em></span> so that equivalent values have identical representations. In the canonical representation of these types, the lower bound is inclusive and the upper bound is exclusive as shown in the following examples:
		</p><pre class="programlisting">
SELECT intspan '[1, 1]';
-- [1, 2)
SELECT bigintspan '(1, 3]';
--[2, 4)
SELECT datespan '[2001-01-01, 2001-01-03]';
-- [2001-01-01, 2001-01-04)
</pre><p>
			A value of a span set type represents an <span class="emphasis"><em>ordered</em></span> set of <span class="emphasis"><em>disjoint</em></span> span values. A span set value must contain at least one element, in which case it corresponds to a single span value. Examples of span set values are as follows:
		</p><pre class="programlisting">
SELECT floatspanset '{[8.1, 8.5],[9.2, 9.4]}';
-- Singleton spanset
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00]}';
-- Erroneous spanset: unordered elements
SELECT intspanset '{[3,4],[1,2]}';
-- Erroneous spanset: overlapping elements
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00],
  [2001-01-01 08:05:00, 2001-01-01 08:15:00]}';
</pre><p>
			Values of the span set types are converted into <span class="emphasis"><em>normal form</em></span> so that equivalent values have identical representations. For this, consecutive adjacent span values are merged when possible. Examples of transformation into normal form are as follows:
		</p><pre class="programlisting">
SELECT intspanset '{[1,2],[3,4]}';
-- {[1, 5)}
SELECT floatspanset '{[1.5,2.5],(2.5,4.5]}';
-- {[1.5, 4.5]}
SELECT tstzspanset '{[2001-01-01 08:00:00, 2001-01-01 08:10:00),
  [2001-01-01 08:10:00, 2001-01-01 08:10:00], (2001-01-01 08:10:00, 2001-01-01 08:20:00]}';
-- {[2001-01-01 08:00:00+00,2001-01-01 08:20:00+00]}
</pre><p>
			We give next the functions for input and output of set and span types in Well-Known Text and Well-Known Binary format. The default output format of all set and span types is the Well-Known Text format. The function <code class="varname">asText</code> given next enables to determine the output of floating point values.
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a name="setspan_asText"></a><a class="indexterm" name="idm637"></a><p>Return the Well-Known Text (WKT) representation</p><p><code class="varname">asText({floatset,floatspans},maxdecdigits=15) → text</code></p><p>The <code class="varname">maxdecdigits</code> argument can be used to set the maximum number of decimal places in the output of floating point values (default 15).</p><pre class="programlisting">
SELECT asText(floatset '{1.123456789,2.123456789}', 3);
-- {1.123, 2.123}
SELECT asText(floatspanset '{[1.55,2.55],[4,5]}',0);
-- {[2, 3], [4, 5]}
</pre></li><li class="listitem"><a name="setspan_asBinary"></a><a class="indexterm" name="idm647"></a><p>Return the Well-Known Binary (WKB) representation</p><p><code class="varname">asBinary({set,spans},endian text='') → bytea</code></p><p>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</p><pre class="programlisting">
SELECT asBinary(dateset '{2001-01-01, 2001-01-03}');
-- \x01050001020000006e01000070010000
SELECT asBinary(intspan '[1, 3)');
-- \x011300010100000003000000
SELECT asBinary(floatspanset '{[1, 2], [4, 5]}', 'XDR');
-- \x00000e00000002033ff000000000000040000000000000000340100000000000004014000000000000
</pre></li><li class="listitem"><a name="setspan_asHexWKB"></a><a class="indexterm" name="idm656"></a><p>Return the Hexadecimal Well-Known Binary (HexWKB) representation as text</p><p><code class="varname">asHexWKB({set,spans},endian text='') → text</code></p><p>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</p><pre class="programlisting">
SELECT asHexWKB(dateset '{2001-01-01, 2001-01-03}');
-- 01050001020000006E01000070010000
SELECT asHexWKB(intspan '[1, 3)');
-- 011300010100000003000000
SELECT asHexWKB(floatspanset '{[1, 2], [4, 5]}', 'XDR');
-- 00000E00000002033FF000000000000040000000000000000340100000000000004014000000000000
</pre></li><li class="listitem"><a name="setspan_FromBinary"></a><a class="indexterm" name="idm665"></a><a class="indexterm" name="idm668"></a><a class="indexterm" name="idm671"></a><p>Input from a Well-Known Binary (WKB) representation</p><p><code class="varname">settypeFromBinary(bytea) → set</code></p><p><code class="varname">spantypeFromBinary(bytea) → span</code></p><p><code class="varname">spansettypeFromBinary(bytea) → spanset</code></p><p>There is one function per set or span (set) type, the name of the function has as prefix the name of the type</p><pre class="programlisting">
SELECT datesetFromBinary('\x01050001020000006e01000070010000');
-- {2001-01-01, 2001-01-03}
SELECT intspanFromBinary('\x011300010100000003000000');
-- [1, 3)
SELECT floatspansetFromBinary(
  '\x00000e00000002033ff000000000000040000000000000000340100000000000004014000000000000');
-- {[1, 2], [4, 5]}
</pre></li><li class="listitem"><a name="setspan_FromHexWKB"></a><a class="indexterm" name="idm684"></a><a class="indexterm" name="idm687"></a><a class="indexterm" name="idm690"></a><p>Input from an Hexadecimal Well-Known Binary (HexWKB) representation</p><p><code class="varname">settypeFromHexWKB(text) → set</code></p><p><code class="varname">spantypeFromHexWKB(text) → span</code></p><p><code class="varname">spansettypeFromHexWKB(text) → spanset</code></p><p>There is one function per set or span (set) type, the name of the function has as prefix the name of the type.</p><pre class="programlisting">
SELECT datesetFromHexWKB('01050001020000006E01000070010000');
-- {2001-01-01, 2001-01-03}
SELECT intspanFromHexWKB('011300010100000003000000');
-- [1, 3)
SELECT floatspanFromHexWKB('01060001000000000000F83F0000000000000440');
-- [1.5, 2.5)
SELECT floatspansetFromHexWKB(
  '00000E00000002033FF000000000000040000000000000000340100000000000004014000000000000');
-- {[1, 2], [4, 5]}
</pre></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s08.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch02s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Migrating from Version 1.0 to Version 1.1 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Constructors</td></tr></table></div></body></html>
